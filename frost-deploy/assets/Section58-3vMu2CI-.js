import{j as i}from"./vendor-animation-0o8UKZ_1.js";import{L as n}from"./LessonLayout-WO30R0_w.js";import{D as s,E as r,C as t,T as l}from"./Callout-D6GJ8KQY.js";import{I as e,M as a}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-CKqQQJMA.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function g(){return i.jsxs(n,{sectionId:58,children:[i.jsx("h2",{children:"Performance Optimizations"}),i.jsx("p",{children:"While FROST is already efficient compared to other threshold signature schemes, several optimizations can further improve performance in production deployments."}),i.jsx("h3",{children:"Batch Verification"}),i.jsx("p",{children:"Instead of verifying each signature share individually, batch verification combines all checks into a single equation:"}),i.jsxs(s,{title:"Batch Verification Formula",children:[i.jsxs("p",{children:["For shares ",i.jsx(e,{children:"z_1, \\ldots, z_t"})," with random weights"," ",i.jsx(e,{children:"r_1, \\ldots, r_t"}),":"]}),i.jsx(a,{children:"[\\sum_i r_i \\cdot z_i]G \\stackrel{?}{=} \\sum_i r_i \\cdot (R_i + [\\lambda_i \\cdot c]Y_i)"})]}),i.jsx(r,{title:"Performance Savings",children:i.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[i.jsxs("li",{children:[i.jsx("strong",{children:"Individual verification:"})," ",i.jsx(e,{children:"t"})," separate scalar multiplications"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Batch verification:"})," approximately 2 scalar multiplications using multi-scalar multiplication algorithms"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Speedup factor:"})," approximately"," ",i.jsx(e,{children:"t/2"})," times faster"]})]})}),i.jsx("h3",{children:"Precomputation Tables"}),i.jsxs("p",{children:["For frequently used points like ",i.jsx(e,{children:"Y"})," and each"," ",i.jsx(e,{children:"Y_i"}),", precomputation dramatically speeds up scalar multiplication:"]}),i.jsxs(r,{title:"Precomputation Strategy",children:[i.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`# For public key Y:
Precompute: [Y], [2]Y, [4]Y, [8]Y, ...
Store in memory as lookup table

# During signing:
[c]Y computed via table lookups instead of
repeated point additions`}),i.jsx("p",{className:"mt-3",children:"The trade-off is memory usage vs. computation time. For frequently used points, the memory cost is easily justified."})]}),i.jsx("h3",{children:"Multi-Scalar Multiplication"}),i.jsxs(s,{title:"Multi-Scalar Multiplication",children:[i.jsxs("p",{children:["Computing ",i.jsx(e,{children:"[a]P + [b]Q"})," is more efficient than computing each term separately:"]}),i.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[i.jsxs("li",{children:[i.jsx("strong",{children:"Shamir's trick:"})," Process both scalars simultaneously, approximately 25% faster"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Straus algorithm:"})," Generalization to many points, approximately 40% faster"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Pippenger's algorithm:"})," Best for large batches, asymptotically optimal"]})]})]}),i.jsx("h3",{children:"Parallel Processing"}),i.jsxs(t,{type:"info",children:[i.jsx("strong",{children:"Parallelization Opportunities:"}),i.jsxs("ul",{className:"list-disc list-inside space-y-1 mt-2",children:[i.jsxs("li",{children:[i.jsx("strong",{children:"Preprocessing:"})," Generate multiple commitment pairs in parallel"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Verification:"})," Verify multiple shares simultaneously"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"DKG:"})," Polynomial evaluation for different participants"]})]})]}),i.jsx("h3",{children:"Protocol-Level Optimizations"}),i.jsxs(r,{title:"Preprocessing Buffer Strategy",children:[i.jsx("p",{children:"Maintain a buffer of preprocessed commitment pairs to avoid signing delays:"}),i.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-3",children:[i.jsx("li",{children:"Generate pairs during idle time"}),i.jsx("li",{children:"Refill buffer when it drops below threshold"}),i.jsx("li",{children:"Balance storage cost vs. signing latency"})]}),i.jsx("p",{className:"mt-3",children:"For high-throughput applications, maintaining 100+ pairs per participant ensures signing never waits for preprocessing."})]}),i.jsx("h3",{children:"Network Optimization"}),i.jsx(s,{title:"Communication Efficiency",children:i.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[i.jsxs("li",{children:[i.jsx("strong",{children:"Commitment compression:"})," Use compressed point encoding (33 bytes vs 65 bytes)"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Batch requests:"})," Combine multiple signing requests in single message"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Pipelining:"})," Start next signing session before current completes (with care)"]})]})}),i.jsx("h3",{children:"Benchmarks"}),i.jsxs(l,{title:"FROST Performance Characteristics",children:[i.jsx("p",{children:"On modern hardware (x86-64, single core):"}),i.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[i.jsxs("li",{children:[i.jsx("strong",{children:"Preprocessing:"})," approximately 1ms per commitment pair"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Signing:"})," approximately 0.5ms per signature share"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Aggregation:"})," approximately 1ms for verification + aggregation"]}),i.jsxs("li",{children:[i.jsx("strong",{children:"Total:"})," 2-3ms per threshold signature (after preprocessing)"]})]}),i.jsx("p",{className:"mt-4",children:"This makes FROST suitable for high-throughput applications like payment processors or custodial services."})]}),i.jsxs(t,{type:"info",children:[i.jsx("strong",{children:"Hardware Acceleration:"})," Some platforms provide hardware acceleration for elliptic curve operations (e.g., ARM Cryptographic Extensions). Using platform-specific optimizations can provide additional 2-4x speedup."]})]})}export{g as default};
