import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a}from"./LessonLayout-WO30R0_w.js";import{T as r,C as n,D as t,E as d}from"./Callout-D6GJ8KQY.js";import{I as i,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-CKqQQJMA.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function u(){return e.jsxs(a,{sectionId:16,children:[e.jsx("h2",{children:"The Transformation Theorem"}),e.jsx("p",{children:"This section presents the key mathematical insight that makes FROST possible: additive shares can be transformed into polynomial (Shamir) shares of the same secret using Lagrange coefficients."}),e.jsx("h3",{children:"The Problem"}),e.jsx("p",{children:"We have two types of shares that need to work together:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 my-4",children:[e.jsxs("li",{children:["Additive shares of ",e.jsx(i,{children:"k"}),":",e.jsx(i,{children:"k = k_1 + k_2 + \\cdots + k_t"})]}),e.jsxs("li",{children:["Polynomial shares of ",e.jsx(i,{children:"s"}),":",e.jsx(i,{children:"s = \\sum_{i \\in S} s_i \\cdot \\lambda_i"})]})]}),e.jsxs("p",{children:["To compute ",e.jsx(i,{children:"z = k + s \\cdot c"})," without reconstruction, we need both types of shares to be compatible."]}),e.jsx("h3",{children:"The Transformation"}),e.jsxs(r,{title:"Additive to Polynomial Conversion",children:[e.jsxs("p",{children:["Given additive shares ",e.jsx(i,{children:"k_1, k_2, \\ldots, k_t"})," of secret",e.jsx(i,{children:"k"})," where ",e.jsx(i,{children:"k = \\sum_i k_i"}),", the values:"]}),e.jsx(s,{children:"\\tilde{k}_i = \\frac{k_i}{\\lambda_i}"}),e.jsxs("p",{className:"mt-3",children:["are valid Shamir (polynomial) shares of the same secret ",e.jsx(i,{children:"k"}),", where ",e.jsx(i,{children:"\\lambda_i"})," are the Lagrange coefficients for the signing set."]})]}),e.jsx("h3",{children:"Why This Works"}),e.jsx("p",{children:"Let's verify that the transformed shares reconstruct to the same secret."}),e.jsx("p",{children:"For polynomial shares, reconstruction uses:"}),e.jsx(s,{children:"k = \\sum_{i \\in S} \\tilde{k}_i \\cdot \\lambda_i"}),e.jsxs("p",{children:["Substituting ",e.jsx(i,{children:"\\tilde{k}_i = k_i / \\lambda_i"}),":"]}),e.jsx(s,{children:"k = \\sum_{i \\in S} \\frac{k_i}{\\lambda_i} \\cdot \\lambda_i = \\sum_{i \\in S} k_i"}),e.jsxs("p",{children:["This equals ",e.jsx(i,{children:"k"})," by the definition of additive shares."]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"The Magic:"}),' Dividing by Lagrange coefficients cancels them out during reconstruction! This allows additive shares to be "dressed up" as polynomial shares.']}),e.jsx("h3",{children:"The Key Property"}),e.jsxs(t,{title:"Lagrange Coefficient Sum",children:[e.jsxs("p",{children:["For any set of points ",e.jsx(i,{children:"S"}),", the Lagrange coefficients sum to 1:"]}),e.jsx(s,{children:"\\sum_{i \\in S} \\lambda_i = 1"}),e.jsxs("p",{className:"mt-3",children:["This is because the constant polynomial ",e.jsx(i,{children:"1"})," interpolates through the points ",e.jsx(i,{children:"(x_i, 1)"})," for all ",e.jsx(i,{children:"i"}),"."]})]}),e.jsxs(d,{title:"Verifying the Sum Property",children:[e.jsxs("p",{className:"mb-4",children:["Using our earlier Lagrange coefficients for participants ","{1, 2, 3}",":"]}),e.jsx(s,{children:"\\lambda_1 = 3, \\quad \\lambda_2 = -3, \\quad \\lambda_3 = 1"}),e.jsx(s,{children:"\\lambda_1 + \\lambda_2 + \\lambda_3 = 3 + (-3) + 1 = 1 \\quad \\checkmark"})]}),e.jsx("h3",{children:"Deeper Understanding: The Algebra"}),e.jsx("p",{children:"Let's trace through why this transformation is mathematically valid."}),e.jsx("p",{children:"Starting with additive shares:"}),e.jsx(s,{children:"k = \\sum_{i \\in S} k_i"}),e.jsxs("p",{children:["We can write ",e.jsx(i,{children:"k"})," in a clever way using the fact that",e.jsx(i,{children:"\\sum_i \\lambda_i = 1"}),":"]}),e.jsx(s,{children:"k = k \\cdot 1 = k \\cdot \\sum_{i \\in S} \\lambda_i = \\sum_{i \\in S} k \\cdot \\lambda_i"}),e.jsxs("p",{children:["But we also have ",e.jsx(i,{children:"k = \\sum_j k_j"}),", so:"]}),e.jsx(s,{children:"k = \\sum_{i \\in S} \\left( \\sum_{j \\in S} k_j \\right) \\cdot \\lambda_i = \\sum_{i \\in S} \\sum_{j \\in S} k_j \\cdot \\lambda_i"}),e.jsx("p",{children:"Rearranging the double sum:"}),e.jsx(s,{children:"k = \\sum_{j \\in S} k_j \\cdot \\sum_{i \\in S} \\lambda_i = \\sum_{j \\in S} k_j \\cdot 1 = \\sum_{j \\in S} k_j"}),e.jsxs("p",{children:["This confirms the consistency. Now, if we define polynomial shares as",e.jsx(i,{children:"\\tilde{k}_i = k_i / \\lambda_i"}),":"]}),e.jsx(s,{children:"\\sum_{i \\in S} \\tilde{k}_i \\cdot \\lambda_i = \\sum_{i \\in S} \\frac{k_i}{\\lambda_i} \\cdot \\lambda_i = \\sum_{i \\in S} k_i = k"}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Important:"})," The converted polynomial shares depend on which participants are in set ",e.jsx(i,{children:"S"}),"! Different signing sets give different Lagrange coefficients, and therefore different",e.jsx(i,{children:"\\tilde{k}_i"})," values. This is fine because we only need consistency within a single signing session."]}),e.jsx("h3",{children:"The Inverse Transformation"}),e.jsx("p",{children:"We can also go the other direction:"}),e.jsxs(r,{title:"Polynomial to Additive Conversion",children:[e.jsxs("p",{children:["Given polynomial shares ",e.jsx(i,{children:"s_1, s_2, \\ldots, s_t"})," where",e.jsx(i,{children:"s = \\sum_i s_i \\cdot \\lambda_i"}),", the values:"]}),e.jsx(s,{children:"\\tilde{s}_i = s_i \\cdot \\lambda_i"}),e.jsxs("p",{className:"mt-3",children:["form additive shares of ",e.jsx(i,{children:"s"}),":"]}),e.jsx(s,{children:"s = \\sum_{i \\in S} \\tilde{s}_i = \\sum_{i \\in S} s_i \\cdot \\lambda_i"})]}),e.jsx("p",{children:"This inverse transformation is exactly what we need for the Schnorr response!"}),e.jsx("h3",{children:"Summary"}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4 my-6",children:[e.jsxs("div",{className:"p-4 rounded-xl bg-dark-800/50 border border-dark-700/50",children:[e.jsx("h4",{className:"font-semibold text-emerald-400 mb-2",children:"Additive to Polynomial"}),e.jsx(s,{children:"\\tilde{k}_i = \\frac{k_i}{\\lambda_i}"}),e.jsx("p",{className:"text-sm mt-2",children:"Divide by Lagrange coefficient"})]}),e.jsxs("div",{className:"p-4 rounded-xl bg-dark-800/50 border border-dark-700/50",children:[e.jsx("h4",{className:"font-semibold text-amber-400 mb-2",children:"Polynomial to Additive"}),e.jsx(s,{children:"\\tilde{s}_i = s_i \\cdot \\lambda_i"}),e.jsx("p",{className:"text-sm mt-2",children:"Multiply by Lagrange coefficient"})]})]}),e.jsxs(n,{type:"warning",children:[e.jsx("strong",{children:"Key Insight:"})," In FROST, we don't actually convert shares explicitly. Instead, we use the Lagrange coefficients in our computations directly. Each participant computes their contribution as if they had the converted shares, and the aggregation produces the correct result."]})]})}export{u as default};
