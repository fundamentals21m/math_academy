import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as t}from"./LessonLayout-sKo1Ukyt.js";import{D as o,E as n,C as a,T as r}from"./Callout-D6GJ8KQY.js";import{I as i,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-LWQys88K.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-ySXQbKre.js";function u(){return e.jsxs(t,{sectionId:53,children:[e.jsx("h2",{children:"Lagrange Coefficient Computation"}),e.jsx("p",{children:"Computing Lagrange coefficients correctly is essential for FROST. These coefficients enable the reconstruction of the secret through polynomial interpolation, but the computation involves rational arithmetic in a finite field."}),e.jsx("h3",{children:"The Lagrange Coefficient Formula"}),e.jsxs(o,{title:"Lagrange Coefficient",children:[e.jsxs("p",{children:["For a signing set ",e.jsx(i,{children:"S"})," and participant"," ",e.jsx(i,{children:"i \\in S"}),", the Lagrange coefficient at"," ",e.jsx(i,{children:"x = 0"})," is:"]}),e.jsx(s,{children:"\\lambda_i = \\prod_{j \\in S, j \\neq i} \\frac{0 - j}{i - j} = \\prod_{j \\in S, j \\neq i} \\frac{-j}{i - j}"})]}),e.jsx("h3",{children:"Naive Implementation (Wrong)"}),e.jsxs(n,{title:"Incorrect Floating-Point Approach",children:[e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`# WRONG: Uses floating-point division
lambda = 1
for j in S:
    if j != i:
        lambda *= (-j) / (i - j)  # Division!`}),e.jsx("p",{className:"mt-3 text-red-400",children:"This fails because division in a finite field requires modular inverse, not floating-point division!"})]}),e.jsxs(a,{type:"warning",children:[e.jsx("strong",{children:"Common Pitfall:"})," Division in ",e.jsx(i,{children:"\\mathbb{Z}_q"})," ","is not the same as regular division. The expression"," ",e.jsx(i,{children:"a/b \\pmod{q}"})," means"," ",e.jsx(i,{children:"a \\cdot b^{-1} \\pmod{q}"})," where"," ",e.jsx(i,{children:"b^{-1}"})," is the modular multiplicative inverse of"," ",e.jsx(i,{children:"b"}),"."]}),e.jsx("h3",{children:"Correct Implementation"}),e.jsxs(n,{title:"Proper Finite Field Computation",children:[e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`lambda_num = 1  # numerator
lambda_den = 1  # denominator

for j in S:
    if j != i:
        lambda_num = (lambda_num * (-j)) % q
        lambda_den = (lambda_den * (i - j)) % q

lambda_i = (lambda_num * mod_inverse(lambda_den, q)) % q`}),e.jsx("p",{className:"mt-3",children:"We accumulate the numerator and denominator separately, then compute the final result using one modular inverse operation."})]}),e.jsx("h3",{children:"Computing Modular Inverse"}),e.jsxs(r,{title:"Fermat's Little Theorem",children:[e.jsxs("p",{children:["For prime ",e.jsx(i,{children:"q"})," and"," ",e.jsx(i,{children:"a \\not\\equiv 0 \\pmod{q}"}),":"]}),e.jsx(s,{children:"a^{-1} \\equiv a^{q-2} \\pmod{q}"}),e.jsx("p",{className:"mt-4",children:"This provides a straightforward way to compute modular inverses using modular exponentiation."})]}),e.jsx("h3",{children:"Precomputation for Efficiency"}),e.jsx("p",{children:"For common threshold configurations, Lagrange coefficients can be precomputed:"}),e.jsxs(n,{title:"2-of-3 Precomputed Coefficients",children:[e.jsx("p",{children:"For a 2-of-3 threshold, there are only 3 possible signing sets:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx(i,{children:"S = \\{1, 2\\}"}),":"," ",e.jsx(i,{children:"\\lambda_1 = 2, \\lambda_2 = -1"})]}),e.jsxs("li",{children:[e.jsx(i,{children:"S = \\{1, 3\\}"}),":"," ",e.jsx(i,{children:"\\lambda_1 = 3/2, \\lambda_3 = -1/2"})]}),e.jsxs("li",{children:[e.jsx(i,{children:"S = \\{2, 3\\}"}),":"," ",e.jsx(i,{children:"\\lambda_2 = 3, \\lambda_3 = -2"})]})]}),e.jsx("p",{className:"mt-3",children:"These can be stored as precomputed values (in the finite field) to avoid runtime computation."})]}),e.jsxs(a,{type:"info",children:[e.jsx("strong",{children:"Critical Requirement:"})," All participants in a signing session must compute Lagrange coefficients for the ",e.jsx("em",{children:"same"})," signing set"," ",e.jsx(i,{children:"S"}),". If participants disagree on who is in the signing set, the signature will be invalid."]}),e.jsx("h3",{children:"Verification of Coefficients"}),e.jsxs(r,{title:"Lagrange Coefficient Sum",children:[e.jsxs("p",{children:["For any valid signing set ",e.jsx(i,{children:"S"})," with"," ",e.jsx(i,{children:"|S| \\geq t"}),", the Lagrange coefficients satisfy:"]}),e.jsx(s,{children:"\\sum_{i \\in S} \\lambda_i = 1"}),e.jsx("p",{className:"mt-4",children:"This property can be used as a sanity check for implementations."})]})]})}export{u as default};
