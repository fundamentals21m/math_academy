import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as n}from"./LessonLayout-sKo1Ukyt.js";import{D as i,C as r,T as t,E as a}from"./Callout-D6GJ8KQY.js";import{I as s,M as l}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-LWQys88K.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-ySXQbKre.js";function g(){return e.jsxs(n,{sectionId:34,children:[e.jsx("h2",{children:"Security Model"}),e.jsx("p",{children:"Understanding FROST's security requires examining the precise assumptions under which it operates and the guarantees it provides. This forms the foundation for trusting the protocol."}),e.jsx("h3",{children:"Cryptographic Assumptions"}),e.jsxs(i,{title:"Assumption 1: Discrete Logarithm Hardness",children:[e.jsxs("p",{children:["Given a group element ",e.jsx(s,{children:"Y = [s]G"}),", computing the scalar"," ",e.jsx(s,{children:"s"})," is computationally infeasible."]}),e.jsxs("p",{className:"mt-3",children:["For secp256k1, this means: given a point on the elliptic curve, finding the number of times you added ",e.jsx(s,{children:"G"})," to itself to get there is essentially impossible with current (and foreseeable classical) computing power."]})]}),e.jsxs(i,{title:"Assumption 2: Random Oracle Model",children:[e.jsxs("p",{children:["The hash functions ",e.jsx(s,{children:"H_1"})," and ",e.jsx(s,{children:"H_2"})," ","behave like truly random functions:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsx("li",{children:"Output appears uniformly random"}),e.jsx("li",{children:"Cannot predict output without computing the hash"}),e.jsx("li",{children:"Each distinct input gives an independent random output"})]}),e.jsx("p",{className:"mt-3",children:"In practice, we instantiate these with cryptographic hash functions like SHA-256, which are believed to approximate this ideal behavior."})]}),e.jsx("h3",{children:"Adversary Model"}),e.jsxs(i,{title:"Adversary Capabilities",children:[e.jsx("p",{children:"The adversary in FROST's security model can:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsxs("strong",{children:["Control up to ",e.jsx(s,{children:"t-1"})," participants:"]})," Has full access to their secret shares and can make them behave arbitrarily"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Choose messages:"})," Adaptively select which messages to request signatures on"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Observe all communication:"})," See all messages between honest parties and coordinator"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Control the network:"})," Delay, reorder, or drop messages (but not modify them due to authentication)"]})]})]}),e.jsxs(r,{type:"warning",children:[e.jsx("strong",{children:"Important Limitation:"})," FROST assumes the adversary chooses which"," ",e.jsx(s,{children:"t-1"})," participants to corrupt ",e.jsx("em",{children:"before"})," the protocol starts (static corruption). Adaptive corruption during execution requires additional techniques."]}),e.jsx("h3",{children:"Security Goals"}),e.jsxs(t,{title:"Goal 1: Unforgeability",children:[e.jsxs("p",{children:["An adversary controlling fewer than ",e.jsx(s,{children:"t"})," participants cannot create a valid signature on any message that was not signed by the honest participants."]}),e.jsx("p",{className:"mt-3",children:"Formally:"}),e.jsx(l,{children:"\\Pr[\\text{Forge}] \\leq \\text{negl}(\\lambda)"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"\\text{negl}(\\lambda)"})," is a negligible function of the security parameter."]})]}),e.jsxs(t,{title:"Goal 2: Secrecy",children:[e.jsxs("p",{children:["The long-term secret ",e.jsx(s,{children:"s"})," is never revealed, even after producing arbitrarily many signatures."]}),e.jsxs("p",{className:"mt-3",children:["More precisely: no probabilistic polynomial-time adversary can compute"," ",e.jsx(s,{children:"s"})," from observing the protocol execution."]})]}),e.jsxs(t,{title:"Goal 3: Zero-Knowledge (Signature Privacy)",children:[e.jsx("p",{children:"Signatures reveal no information about:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["Individual participants' secret shares ",e.jsx(s,{children:"s_i"})]}),e.jsx("li",{children:"Which subset of participants signed"}),e.jsxs("li",{children:["The threshold value ",e.jsx(s,{children:"t"})]}),e.jsxs("li",{children:["The total number of participants ",e.jsx(s,{children:"n"})]})]})]}),e.jsx("h3",{children:"What FROST Does NOT Guarantee"}),e.jsxs(i,{title:"Liveness (Availability)",children:[e.jsx("p",{children:"FROST does not guarantee that signing will always succeed. An adversary can cause the protocol to abort by:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsx("li",{children:"Refusing to participate"}),e.jsx("li",{children:"Providing invalid shares"}),e.jsx("li",{children:"Timing out"})]}),e.jsx("p",{className:"mt-3",children:"This is the trade-off for single-round efficiency. Robust variants exist but require more communication."})]}),e.jsx(i,{title:"Accountability",children:e.jsxs("p",{children:["While FROST can detect misbehavior and identify the misbehaving party, it cannot"," ",e.jsx("em",{children:"prove"})," this misbehavior to a third party without additional mechanisms."]})}),e.jsx("h3",{children:"Security Parameter Interpretation"}),e.jsxs(a,{title:"Concrete Security for Bitcoin (secp256k1)",children:[e.jsx("p",{children:"With secp256k1 parameters:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Group order:"})," ",e.jsx(s,{children:"q \\approx 2^{256}"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Discrete log security:"})," ~128 bits (due to Pollard's rho)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hash output:"})," 256 bits (SHA-256)"]})]}),e.jsxs("p",{className:"mt-3",children:["This means an attacker needs approximately ",e.jsx(s,{children:"2^{128}"})," ","operations to break FROST - comparable to breaking any single-party Schnorr signature."]})]}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"The Key Insight:"})," FROST's security is tightly bound to the discrete logarithm problem. If you trust single-party Schnorr signatures, you can trust FROST with the same confidence level."]}),e.jsx("h3",{children:"Trust Model Summary"}),e.jsx(i,{title:"What You Must Trust",children:e.jsxs("ol",{className:"list-decimal list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Discrete log hardness:"})," The mathematical foundation"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hash function security:"})," SHA-256 behaves like a random oracle"]}),e.jsxs("li",{children:[e.jsxs("strong",{children:["At least ",e.jsx(s,{children:"n - t + 1"})," honest participants:"]})," ","Equivalently, at most ",e.jsx(s,{children:"t - 1"})," compromised"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Correct implementation:"})," No bugs in the code"]})]})}),e.jsx("p",{children:"The next section examines specific attack scenarios that FROST prevents, demonstrating how these security properties hold against realistic threats."})]})}export{g as default};
