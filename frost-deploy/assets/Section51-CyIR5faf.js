import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as r}from"./LessonLayout-MHc1mXdO.js";import{E as t,C as n,D as a}from"./Callout-D6GJ8KQY.js";import{I as i,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-Dwb7rnsM.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function j(){return e.jsxs(r,{sectionId:51,children:[e.jsx("h2",{children:"Elliptic Curve Point Arithmetic"}),e.jsxs("p",{children:["Implementing FROST requires efficient and secure elliptic curve operations. The fundamental operation is ",e.jsx("strong",{children:"scalar multiplication"}),": computing"," ",e.jsx(i,{children:"[k]G"})," where ",e.jsx(i,{children:"k"})," is a scalar and ",e.jsx(i,{children:"G"})," is the generator point."]}),e.jsx("h3",{children:"The Naive Double-and-Add Method"}),e.jsxs("p",{children:["Given the binary representation of ",e.jsx(i,{children:"k"}),":"]}),e.jsx(s,{children:"k = k_0 + k_1 \\cdot 2 + k_2 \\cdot 4 + \\ldots"}),e.jsx("p",{children:"The basic algorithm computes:"}),e.jsx(t,{title:"Double-and-Add Algorithm",children:e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`Q = O (identity)
P = G
for each bit k_i of k:
    if k_i == 1: Q = Q + P
    P = 2P  (point doubling)
return Q`})}),e.jsxs(n,{type:"warning",children:[e.jsx("strong",{children:"Timing Attack Vulnerability:"})," The branch on secret bit"," ",e.jsx(i,{children:"k_i"})," leaks information through timing differences. An attacker measuring execution time can potentially recover the secret scalar."]}),e.jsx("h3",{children:"Constant-Time Scalar Multiplication"}),e.jsx("p",{children:"For cryptographic security, we must eliminate timing variations that depend on secret values. The solution is constant-time operations:"}),e.jsxs(t,{title:"Constant-Time Double-and-Add",children:[e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`for each bit k_i:
    Q_temp = Q + P
    Q = conditional_select(k_i, Q_temp, Q)  // no branch!
    P = 2P`}),e.jsxs("p",{className:"mt-3",children:["The ",e.jsx("code",{children:"conditional_select"})," function always performs the same operations regardless of the condition value, using bitwise operations instead of branches."]})]}),e.jsx("h3",{children:"Fixed-Base Optimization"}),e.jsxs("p",{children:["For the known generator point ",e.jsx(i,{children:"G"}),", we can precompute a table of multiples:"]}),e.jsx(s,{children:"[G], [2]G, [3]G, \\ldots, [15]G"}),e.jsx("p",{children:"Using a windowed method that processes 4 bits at a time provides significant speedup while maintaining security."}),e.jsxs(a,{title:"Multi-Scalar Multiplication",children:[e.jsxs("p",{children:["Computing ",e.jsx(i,{children:"[a]P + [b]Q"})," together is more efficient than computing each separately:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Shamir's trick:"})," approximately 25% faster"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Straus algorithm:"})," approximately 40% faster for many points"]})]})]}),e.jsx("h3",{children:"Variable-Time Operations"}),e.jsxs("p",{children:["For ",e.jsx("em",{children:"public"})," values only, we can use faster variable-time algorithms. In verification, both ",e.jsx(i,{children:"z"})," and ",e.jsx(i,{children:"c"})," are public, so computing ",e.jsx(i,{children:"[z]G"})," and"," ",e.jsx(i,{children:"[c]Y"})," can use optimized non-constant-time code."]}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Implementation Principle:"})," Use constant-time operations for any computation involving secret values. Variable-time optimizations are only safe for public inputs."]})]})}export{j as default};
