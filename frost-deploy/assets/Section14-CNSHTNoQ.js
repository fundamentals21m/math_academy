import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l}from"./LessonLayout-sKo1Ukyt.js";import{C as r,D as n,E as t,T as h}from"./Callout-D6GJ8KQY.js";import{I as s,M as i}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-LWQys88K.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-ySXQbKre.js";function g(){return e.jsxs(l,{sectionId:14,children:[e.jsx("h2",{children:"Why SSS Alone Doesn't Give Threshold Signatures"}),e.jsxs("p",{children:["We now have all the pieces of Shamir Secret Sharing: polynomial encoding, Lagrange interpolation, and Feldman verification. But there's a fundamental problem when we try to use this for threshold ",e.jsx("em",{children:"signatures"}),"."]}),e.jsx("h3",{children:"The Reconstruction Problem"}),e.jsx("p",{children:"Consider what happens when we try to create a threshold Schnorr signature naively:"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-3 my-4",children:[e.jsxs("li",{children:["The private key ",e.jsx(s,{children:"s"})," is shared via Shamir's scheme"]}),e.jsx("li",{children:"To sign, participants bring their shares together"}),e.jsxs("li",{children:["They reconstruct ",e.jsx(s,{children:"s = \\sum_i s_i \\cdot \\lambda_i"})]}),e.jsxs("li",{children:["Someone computes ",e.jsx(s,{children:"z = k + s \\cdot c"})]})]}),e.jsxs(r,{type:"error",children:[e.jsx("strong",{children:"The Fatal Flaw:"})," At step 3, the secret ",e.jsx(s,{children:"s"}),"is reconstructed on ",e.jsx("em",{children:"some device"}),". That device now knows the private key and becomes a single point of failure - exactly what we were trying to avoid!"]}),e.jsx("h3",{children:"The Schnorr Response Challenge"}),e.jsx("p",{children:"Recall the Schnorr signing formula:"}),e.jsx(i,{children:"z = k + s \\cdot c"}),e.jsxs("p",{children:["To compute this without reconstructing ",e.jsx(s,{children:"s"}),", we need to handle two secret values:"]}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4 my-6",children:[e.jsxs("div",{className:"p-4 rounded-xl bg-dark-800/50 border border-dark-700/50",children:[e.jsx("h4",{className:"font-semibold text-indigo-400 mb-2",children:"Long-term Secret: s"}),e.jsxs("ul",{className:"space-y-2 text-sm",children:[e.jsx("li",{children:"The private key"}),e.jsx("li",{children:"Shared once during key generation"}),e.jsx("li",{children:"Shamir polynomial shares"}),e.jsx("li",{children:"Never changes (unless key refresh)"})]})]}),e.jsxs("div",{className:"p-4 rounded-xl bg-dark-800/50 border border-dark-700/50",children:[e.jsx("h4",{className:"font-semibold text-amber-400 mb-2",children:"Ephemeral Secret: k"}),e.jsxs("ul",{className:"space-y-2 text-sm",children:[e.jsx("li",{children:"The nonce"}),e.jsx("li",{children:"Different for every signature"}),e.jsx("li",{children:"Must be random and secret"}),e.jsx("li",{children:"Must never be reused"})]})]})]}),e.jsx("h3",{children:"The Nonce Problem"}),e.jsxs(n,{title:"The Dual Secret Challenge",children:[e.jsxs("p",{children:["To compute ",e.jsx(s,{children:"z = k + s \\cdot c"})," collaboratively:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-3",children:[e.jsxs("li",{children:["We need shares of ",e.jsx(s,{children:"s"})," (from Shamir sharing at key generation)"]}),e.jsxs("li",{children:["We ",e.jsx("em",{children:"also"})," need shares of ",e.jsx(s,{children:"k"})," (fresh for each signature)"]}),e.jsxs("li",{children:["Neither ",e.jsx(s,{children:"s"})," nor ",e.jsx(s,{children:"k"})," should ever be reconstructed"]})]})]}),e.jsx("p",{children:"This raises several questions:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 my-4",children:[e.jsxs("li",{children:["How do we share ",e.jsx(s,{children:"k"})," without running a full DKG each time?"]}),e.jsxs("li",{children:["How do we combine shares of ",e.jsx(s,{children:"s"})," and ",e.jsx(s,{children:"k"}),"?"]}),e.jsxs("li",{children:["How do we compute the group commitment ",e.jsx(s,{children:"R = [k]G"}),"?"]})]}),e.jsx("h3",{children:"Failed Approach: Shamir Share Everything"}),e.jsxs(t,{title:"Why Full Shamir for k Doesn't Work",children:[e.jsxs("p",{className:"mb-4",children:["Suppose we run Shamir sharing for ",e.jsx(s,{children:"k"})," each time we sign:"]}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Coordination overhead:"})," Need a dealer to choose ",e.jsx(s,{children:"k"}),"and distribute shares - but who is the dealer? They'd know ",e.jsx(s,{children:"k"}),"!"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Multiple rounds:"})," Shamir distribution requires communication, adding latency to each signature"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Single point of failure:"})," Whoever generates ",e.jsx(s,{children:"k"}),"knows it, defeating the purpose"]})]})]}),e.jsx("h3",{children:"The Key Observation"}),e.jsxs("p",{children:["Shamir (polynomial) shares have a crucial property for ",e.jsx(s,{children:"s"}),": they allow ",e.jsx("em",{children:"any"})," ",e.jsx(s,{children:"t"})," participants to reconstruct. But for the nonce ",e.jsx(s,{children:"k"}),", we have a different requirement."]}),e.jsxs(h,{title:"The FROST Insight",children:[e.jsxs("p",{children:["For the ephemeral nonce ",e.jsx(s,{children:"k"}),", we can use ",e.jsx("strong",{children:"additive shares"})," instead of polynomial shares:"]}),e.jsx(i,{children:"k = k_1 + k_2 + \\cdots + k_t"}),e.jsxs("p",{className:"mt-3",children:["Each participant ",e.jsx(s,{children:"i"})," generates their own random",e.jsx(s,{children:"k_i"})," without coordination!"]})]}),e.jsx("h3",{children:"Additive vs Polynomial Shares"}),e.jsx("div",{className:"overflow-x-auto my-6",children:e.jsxs("table",{className:"w-full border-collapse",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left p-3",children:"Property"}),e.jsx("th",{className:"text-left p-3",children:"Shamir (Polynomial)"}),e.jsx("th",{className:"text-left p-3",children:"Additive"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700/50",children:[e.jsx("td",{className:"p-3",children:"Threshold"}),e.jsxs("td",{className:"p-3",children:[e.jsx(s,{children:"t"}),"-of-",e.jsx(s,{children:"n"})]}),e.jsxs("td",{className:"p-3",children:[e.jsx(s,{children:"t"}),"-of-",e.jsx(s,{children:"t"})," (all needed)"]})]}),e.jsxs("tr",{className:"border-b border-dark-700/50",children:[e.jsx("td",{className:"p-3",children:"Generation"}),e.jsx("td",{className:"p-3",children:"Requires coordination"}),e.jsx("td",{className:"p-3",children:"Non-interactive"})]}),e.jsxs("tr",{className:"border-b border-dark-700/50",children:[e.jsx("td",{className:"p-3",children:"Reconstruction"}),e.jsx("td",{className:"p-3",children:e.jsx(s,{children:"\\sum s_i \\cdot \\lambda_i"})}),e.jsx("td",{className:"p-3",children:e.jsx(s,{children:"\\sum k_i"})})]}),e.jsxs("tr",{className:"border-b border-dark-700/50",children:[e.jsx("td",{className:"p-3",children:"Use in FROST"}),e.jsxs("td",{className:"p-3",children:["Long-term secret ",e.jsx(s,{children:"s"})]}),e.jsxs("td",{className:"p-3",children:["Ephemeral nonce ",e.jsx(s,{children:"k"})]})]})]})]})}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"The Insight:"})," We don't need threshold reconstruction for the nonce! For signing, we already know which ",e.jsx(s,{children:"t"})," participants are participating. Each generates their own nonce share, and we just add them up."]}),e.jsx("h3",{children:"The Remaining Challenge"}),e.jsx("p",{children:"But wait - there's still a problem. In the Schnorr response:"}),e.jsx(i,{children:"z = k + s \\cdot c"}),e.jsxs("p",{children:["We're adding ",e.jsx(s,{children:"k"})," (additively shared) and ",e.jsx(s,{children:"s \\cdot c"}),"(polynomially shared). These are different types of shares! How do we combine them?"]}),e.jsxs(r,{type:"warning",children:[e.jsx("strong",{children:"The Mathematical Challenge:"})," We need a way to convert between additive and polynomial shares, or to compute with both types simultaneously. This is the key insight of FROST, and we'll explore it in the next section."]}),e.jsx("h3",{children:"Summary: What We Need"}),e.jsx(n,{title:"Requirements for Threshold Schnorr",children:e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:["Long-term key ",e.jsx(s,{children:"s"}),": Polynomial shares (t-of-n flexibility)"]}),e.jsxs("li",{children:["Ephemeral nonce ",e.jsx(s,{children:"k"}),": Additive shares (non-interactive)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"A way to combine them"})," without reconstruction"]}),e.jsx("li",{children:"Security against parallel session attacks (coming later)"})]})}),e.jsx("p",{children:"The next section reveals the mathematical trick that makes this possible: the share conversion theorem."})]})}export{g as default};
