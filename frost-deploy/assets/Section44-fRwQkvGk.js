import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as c}from"./LessonLayout-WO30R0_w.js";import{D as i,C as n,E as t,T as l}from"./Callout-D6GJ8KQY.js";import{I as s,M as r}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-CKqQQJMA.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function g(){return e.jsxs(c,{sectionId:44,children:[e.jsx("h2",{children:"Proactive Secret Sharing (Share Refreshing)"}),e.jsxs("p",{children:["Long-lived secret shares are at risk of gradual compromise. Over time, an attacker might slowly gather shares from different participants. ",e.jsx("strong",{children:"Proactive secret sharing"})," ","addresses this by periodically refreshing shares without changing the underlying secret."]}),e.jsx("h3",{children:"The Problem"}),e.jsxs(i,{title:"Mobile Adversary",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"mobile adversary"})," can corrupt different participants at different times:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["Time period 1: Corrupts ",e.jsx(s,{children:"P_1"}),", learns"," ",e.jsx(s,{children:"s_1"})]}),e.jsxs("li",{children:["Time period 2: Corrupts ",e.jsx(s,{children:"P_2"}),", learns"," ",e.jsx(s,{children:"s_2"})]}),e.jsx("li",{children:"..."}),e.jsxs("li",{children:["Eventually: Has ",e.jsx(s,{children:"t"})," shares, can reconstruct"," ",e.jsx(s,{children:"s"})]})]})]}),e.jsxs(n,{type:"warning",children:[e.jsx("strong",{children:"The Threat:"})," Even if the adversary never controls"," ",e.jsx(s,{children:"t"})," parties simultaneously, they can accumulate enough information over time to reconstruct the secret."]}),e.jsx("h3",{children:"The Solution: Share Refreshing"}),e.jsxs(i,{title:"Core Idea",children:[e.jsx("p",{children:"Periodically generate new shares of the same secret:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsx("li",{children:"Old shares become useless"}),e.jsxs("li",{children:["Secret ",e.jsx(s,{children:"s"})," remains unchanged"]}),e.jsxs("li",{children:["Public key ",e.jsx(s,{children:"Y"})," remains unchanged"]}),e.jsx("li",{children:"Attacker's accumulated knowledge becomes stale"})]})]}),e.jsx("h3",{children:"Mathematical Technique"}),e.jsxs(i,{title:"Setup",children:[e.jsxs("p",{children:["Original secret ",e.jsx(s,{children:"s = f(0)"})," for polynomial"," ",e.jsx(s,{children:"f"})," of degree ",e.jsx(s,{children:"t-1"}),"."]}),e.jsxs("p",{className:"mt-3",children:["Current shares: ",e.jsx(s,{children:"s_1 = f(1), s_2 = f(2), \\ldots, s_n = f(n)"})]})]}),e.jsxs(i,{title:"Refresh Protocol",children:[e.jsxs("p",{children:["Each participant ",e.jsx(s,{children:"P_i"})," generates a random polynomial"," ",e.jsx(s,{children:"g_i(x)"})," of degree ",e.jsx(s,{children:"t-1"})," with:"]}),e.jsx(r,{children:"g_i(0) = 0"}),e.jsxs("p",{className:"mt-3",children:["This is crucial: the constant term is zero, so adding"," ",e.jsx(s,{children:"g_i"})," doesn't change the secret."]})]}),e.jsxs(t,{title:"Polynomial Construction",children:[e.jsxs("p",{children:["Participant ",e.jsx(s,{children:"P_i"})," chooses random coefficients:"]}),e.jsx(r,{children:"g_i(x) = b_{i1} \\cdot x + b_{i2} \\cdot x^2 + \\cdots + b_{i(t-1)} \\cdot x^{t-1}"}),e.jsxs("p",{className:"mt-3",children:["Note: No constant term (equivalent to setting ",e.jsx(s,{children:"b_{i0} = 0"}),")."]})]}),e.jsx(i,{title:"Share Distribution",children:e.jsxs("p",{children:["Each ",e.jsx(s,{children:"P_i"})," sends ",e.jsx(s,{children:"g_i(j)"})," to participant ",e.jsx(s,{children:"P_j"})," for all ",e.jsx(s,{children:"j"}),"."]})}),e.jsxs(i,{title:"New Share Computation",children:[e.jsxs("p",{children:["Each participant ",e.jsx(s,{children:"P_j"})," computes their new share:"]}),e.jsx(r,{children:"s'_j = s_j + \\sum_{i=1}^{n} g_i(j)"})]}),e.jsx("h3",{children:"Why It Works"}),e.jsxs(l,{title:"Secret Preservation",children:[e.jsx("p",{children:"The new shares reconstruct to the same secret:"}),e.jsx(r,{children:"\\sum_{j \\in S} s'_j \\cdot \\lambda_j = \\sum_{j \\in S} \\left( s_j + \\sum_{i=1}^{n} g_i(j) \\right) \\cdot \\lambda_j"}),e.jsx(r,{children:"= \\sum_{j \\in S} s_j \\cdot \\lambda_j + \\sum_{j \\in S} \\sum_{i=1}^{n} g_i(j) \\cdot \\lambda_j"}),e.jsx(r,{children:"= s + \\sum_{i=1}^{n} \\sum_{j \\in S} g_i(j) \\cdot \\lambda_j"}),e.jsx(r,{children:"= s + \\sum_{i=1}^{n} g_i(0)"}),e.jsx(r,{children:"= s + \\sum_{i=1}^{n} 0 = s \\quad \\checkmark"})]}),e.jsxs(l,{title:"Old Shares Useless",children:[e.jsxs("p",{children:["Old shares ",e.jsx(s,{children:"s_j"})," and new shares"," ",e.jsx(s,{children:"s'_j"})," are statistically independent (given only"," ",e.jsx(s,{children:"t-1"})," of each)."]}),e.jsxs("p",{className:"mt-3",children:["An adversary with ",e.jsx(s,{children:"t-1"})," old shares and"," ",e.jsx(s,{children:"t-1"})," new shares still cannot reconstruct"," ",e.jsx(s,{children:"s"}),"."]})]}),e.jsx("h3",{children:"Refresh Schedule"}),e.jsxs(i,{title:"Epoch-Based Refresh",children:[e.jsx("p",{children:"Define security epochs:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Epoch length:"})," Time window where adversary can corrupt up to"," ",e.jsx(s,{children:"t-1"})," parties"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Refresh timing:"})," End of each epoch"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Security guarantee:"})," Adversary must corrupt"," ",e.jsx(s,{children:"t"})," parties within single epoch"]})]})]}),e.jsxs(t,{title:"Example Schedule",children:[e.jsx("p",{children:"For a high-security setup:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsx("li",{children:"Epoch: 1 month"}),e.jsx("li",{children:"Threshold: 3-of-5"}),e.jsx("li",{children:"Security: Adversary must compromise 3 parties within 1 month"}),e.jsx("li",{children:"After refresh, all previously stolen shares become worthless"})]})]}),e.jsx("h3",{children:"Verifiable Refresh"}),e.jsxs(i,{title:"Adding Verification",children:[e.jsx("p",{children:"To ensure participants honestly perform refresh, use VSS commitments:"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["Each ",e.jsx(s,{children:"P_i"})," publishes commitments"," ",e.jsx(s,{children:"[b_{i1}]G, [b_{i2}]G, \\ldots"})]}),e.jsxs("li",{children:["Recipients verify: ",e.jsx(s,{children:"[g_i(j)]G = j \\cdot [b_{i1}]G + j^2 \\cdot [b_{i2}]G + \\cdots"})]}),e.jsx("li",{children:"Malicious contributions are detected and excluded"})]})]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"The Power of Proactive Security:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:"Defeats mobile/gradual adversaries"}),e.jsx("li",{children:"No change to public key or addresses"}),e.jsx("li",{children:"Can be done while system is operational"}),e.jsx("li",{children:"Provides long-term security guarantees"})]})]}),e.jsx("h3",{children:"FROST Integration"}),e.jsx("p",{children:"Proactive refresh integrates naturally with FROST: the refreshed shares work identically in the signing protocol. The only change is periodic execution of the refresh protocol."})]})}export{g as default};
