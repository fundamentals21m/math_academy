import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as o}from"./LessonLayout-WO30R0_w.js";import{D as t,T as l,E as r,C as n}from"./Callout-D6GJ8KQY.js";import{I as s,M as i}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-CKqQQJMA.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function g(){return e.jsxs(o,{sectionId:36,children:[e.jsx("h2",{children:"Security Proof Structure"}),e.jsxs("p",{children:["How do cryptographers prove that FROST is secure? The answer lies in"," ",e.jsx("strong",{children:"reduction proofs"})," - showing that breaking FROST is at least as hard as solving well-studied mathematical problems."]}),e.jsx("h3",{children:"The Reduction Framework"}),e.jsxs(t,{title:"Proof by Reduction",children:[e.jsxs("p",{children:['A reduction proof shows: "If algorithm ',e.jsx(s,{children:"\\mathcal{A}"})," can break our protocol with probability ",e.jsx(s,{children:"\\varepsilon"}),", then we can use ",e.jsx(s,{children:"\\mathcal{A}"})," to solve the hard problem with probability ",e.jsx(s,{children:"\\geq f(\\varepsilon)"}),'."']}),e.jsxs("p",{className:"mt-3",children:["Since the hard problem is assumed infeasible,"," ",e.jsx(s,{children:"\\varepsilon"})," must also be negligible."]})]}),e.jsxs(l,{title:"Main Security Theorem",children:[e.jsx("p",{children:"If the discrete logarithm problem is hard, FROST is unforgeable under chosen-message attack in the random oracle model."}),e.jsx("p",{className:"mt-3",children:"Contrapositive form:"}),e.jsx(i,{children:"\\text{If Forger } \\mathcal{F} \\text{ breaks FROST with prob } \\varepsilon"}),e.jsx(i,{children:"\\text{Then } \\exists \\text{ algorithm solving DL with prob } \\geq \\frac{\\varepsilon^2}{\\text{poly}(\\lambda)}"})]}),e.jsx("h3",{children:"Proof Steps Overview"}),e.jsxs(t,{title:"Step 1: Setup",children:[e.jsxs("p",{children:["Given a discrete log challenge ",e.jsx(s,{children:"\\omega \\in G"})," (we want to find ",e.jsx(s,{children:"x"})," such that ",e.jsx(s,{children:"\\omega = [x]G"}),"), embed it in the FROST public key."]}),e.jsxs("p",{className:"mt-3",children:["The simulator sets up the FROST environment so that solving for the group secret"," ",e.jsx(s,{children:"s"})," would reveal ",e.jsx(s,{children:"x"}),"."]})]}),e.jsxs(t,{title:"Step 2: Simulation",children:[e.jsxs("p",{children:["Simulate the FROST environment for the forger ",e.jsx(s,{children:"\\mathcal{F}"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"DKG:"})," Embed ",e.jsx(s,{children:"\\omega"})," as one participant's contribution to the public key"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Preprocessing:"})," Simulate commitment generation"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Signing:"})," Program random oracles to enable signing simulation without knowing the secret"]})]})]}),e.jsxs(r,{title:"Random Oracle Programming",children:[e.jsxs("p",{children:["The simulator controls hash functions ",e.jsx(s,{children:"H_1, H_2"}),". When the forger queries ",e.jsx(s,{children:"H_2(R, Y, m)"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["If this is a new query, choose random ",e.jsx(s,{children:"c"})," and store the mapping"]}),e.jsx("li",{children:"If previously queried, return the stored value"})]}),e.jsx("p",{className:"mt-3",children:'This allows the simulator to "program" the hash output to values that make simulation possible.'})]}),e.jsxs(t,{title:"Step 3: Forking",children:[e.jsxs("p",{children:["Run ",e.jsx(s,{children:"\\mathcal{F}"})," twice with the same randomness but different random oracle outputs."]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"First run:"})," ",e.jsx(s,{children:"\\mathcal{F}"})," produces forgery"," ",e.jsx(s,{children:"(R, z, m)"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Fork point:"})," At the challenge query, return different hash output"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Second run:"})," ",e.jsx(s,{children:"\\mathcal{F}"})," produces"," ",e.jsx(s,{children:"(R, z', m)"})," with same ",e.jsx(s,{children:"R"})," but different ",e.jsx(s,{children:"z'"})]})]})]}),e.jsxs(t,{title:"Step 4: Extraction",children:[e.jsx("p",{children:"Use the two forgeries to extract the discrete log:"}),e.jsx(i,{children:"z = k + s \\cdot c"}),e.jsx(i,{children:"z' = k + s \\cdot c'"}),e.jsx("p",{className:"mt-3",children:"Subtracting these equations:"}),e.jsx(i,{children:"z - z' = s \\cdot (c - c')"}),e.jsx("p",{className:"mt-3",children:"Solving for s:"}),e.jsx(i,{children:"s = \\frac{z - z'}{c - c'}"})]}),e.jsxs(t,{title:"Step 5: Recovery",children:[e.jsxs("p",{children:["Extract the original challenge ",e.jsx(s,{children:"x"})," from computed"," ",e.jsx(s,{children:"s"}),"."]}),e.jsxs("p",{className:"mt-3",children:["Due to how we embedded ",e.jsx(s,{children:"\\omega"})," in the public key, knowing"," ",e.jsx(s,{children:"s"})," allows us to compute ",e.jsx(s,{children:"x"}),"."]})]}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"The Forking Lemma:"})," The probability of successful forking depends on the original success probability. If the forger succeeds with probability"," ",e.jsx(s,{children:"\\varepsilon"})," after ",e.jsx(s,{children:"q"})," queries:",e.jsx(i,{children:"\\Pr[\\text{successful fork}] \\geq \\frac{\\varepsilon^2}{q}"})]}),e.jsx("h3",{children:"Key Technical Challenges"}),e.jsxs(r,{title:"Challenge 1: Simulating Without the Secret",children:[e.jsxs("p",{children:["The simulator doesn't know ",e.jsx(s,{children:"s"})," but must produce valid-looking signatures when ",e.jsx(s,{children:"\\mathcal{F}"})," requests them."]}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Solution:"})," Choose ",e.jsx(s,{children:"z"})," randomly first, then program ",e.jsx(s,{children:"H_2"})," to return the value that makes verification pass:"]}),e.jsx(i,{children:"c = H_2(R, Y, m) \\text{ set so that } [z]G = R + [c]Y"})]}),e.jsxs(r,{title:"Challenge 2: Embedding the Challenge",children:[e.jsx("p",{children:"Must embed the DL challenge without the forger detecting the simulation."}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Solution:"})," Distribute ",e.jsx(s,{children:"\\omega"})," across polynomial commitments so that"," ",e.jsx(s,{children:"Y = \\omega + [\\text{known terms}]G"}),"."]})]}),e.jsx("h3",{children:"Why This Proves Security"}),e.jsxs(l,{title:"Security Conclusion",children:[e.jsx("p",{children:"The reduction shows:"}),e.jsx(i,{children:"\\varepsilon_{\\text{FROST}} \\leq \\sqrt{q \\cdot \\varepsilon_{\\text{DL}}}"}),e.jsxs("p",{className:"mt-3",children:["If ",e.jsx(s,{children:"\\varepsilon_{\\text{DL}}"})," is negligible (discrete log is hard), then ",e.jsx(s,{children:"\\varepsilon_{\\text{FROST}}"})," must also be negligible."]})]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"The Security Guarantee:"})," Breaking FROST requires either:",e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:"Solving the discrete logarithm problem (believed impossible)"}),e.jsx("li",{children:"Finding collisions/preimages in the hash function (believed impossible)"})]}),"Both are considered computationally infeasible, so FROST is secure."]})]})}export{g as default};
