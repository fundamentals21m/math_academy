import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l}from"./LessonLayout-MHc1mXdO.js";import{D as t,E as n,T as a,C as r}from"./Callout-D6GJ8KQY.js";import{I as i,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-Dwb7rnsM.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function f(){return e.jsxs(l,{sectionId:50,children:[e.jsx("h2",{children:"Finite Field Arithmetic"}),e.jsx("p",{children:"All the mathematics in FROST operates within finite fields. Understanding finite field arithmetic is essential for implementing FROST correctly and securely."}),e.jsx("h3",{children:"The Field"}),e.jsxs(t,{title:"Integers Modulo q",children:[e.jsxs("p",{children:["FROST operates in ",e.jsx(i,{children:"\\mathbb{Z}_q"}),", the integers modulo"," ",e.jsx(i,{children:"q"}),":"]}),e.jsx(s,{children:"\\mathbb{Z}_q = \\{0, 1, 2, \\ldots, q-1\\}"}),e.jsx("p",{className:"mt-3",children:"For secp256k1, the group order is:"}),e.jsx(s,{children:"q = \\texttt{FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE}"}),e.jsx(s,{children:"\\quad\\; \\texttt{BAAEDCE6 AF48A03B BFD25E8C D0364141}"}),e.jsxs("p",{className:"mt-3",children:["This is approximately ",e.jsx(i,{children:"2^{256}"}),"."]})]}),e.jsx("h3",{children:"Basic Operations"}),e.jsxs(t,{title:"Addition",children:[e.jsx(s,{children:"(a + b) \\mod q"}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(i,{children:"a + b \\geq q"}),", subtract ",e.jsx(i,{children:"q"}),"."]})]}),e.jsxs(t,{title:"Subtraction",children:[e.jsx(s,{children:"(a - b) \\mod q"}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(i,{children:"a - b < 0"}),", add ",e.jsx(i,{children:"q"}),"."]})]}),e.jsxs(t,{title:"Multiplication",children:[e.jsx(s,{children:"(a \\cdot b) \\mod q"}),e.jsxs("p",{className:"mt-2",children:["Compute ",e.jsx(i,{children:"a \\cdot b"})," as multi-precision integer, then reduce modulo ",e.jsx(i,{children:"q"}),"."]})]}),e.jsx("h3",{children:"Division (Multiplicative Inverse)"}),e.jsxs(t,{title:"Modular Inverse",children:[e.jsxs("p",{children:["Division in ",e.jsx(i,{children:"\\mathbb{Z}_q"})," is multiplication by the inverse:"]}),e.jsx(s,{children:"a / b \\equiv a \\cdot b^{-1} \\pmod{q}"}),e.jsxs("p",{className:"mt-3",children:["where ",e.jsx(i,{children:"b^{-1}"})," is the unique element such that:"]}),e.jsx(s,{children:"b \\cdot b^{-1} \\equiv 1 \\pmod{q}"})]}),e.jsxs(n,{title:"Computing Inverse",children:[e.jsx("p",{children:"Two main methods:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Extended Euclidean Algorithm:"})," ",e.jsx(i,{children:"O(\\log q)"})," ","operations"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Fermat's Little Theorem:"})," ",e.jsx(i,{children:"b^{-1} \\equiv b^{q-2} \\pmod{q}"})]})]})]}),e.jsxs(a,{title:"Fermat's Little Theorem",children:[e.jsxs("p",{children:["For prime ",e.jsx(i,{children:"q"})," and"," ",e.jsx(i,{children:"b \\not\\equiv 0 \\pmod{q}"}),":"]}),e.jsx(s,{children:"b^{q-1} \\equiv 1 \\pmod{q}"}),e.jsx("p",{className:"mt-3",children:"Therefore:"}),e.jsx(s,{children:"b^{-1} \\equiv b^{q-2} \\pmod{q}"})]}),e.jsx("h3",{children:"Lagrange Coefficients in Practice"}),e.jsxs(n,{title:"Correct Computation",children:[e.jsxs("p",{children:["The Lagrange coefficient for participant ",e.jsx(i,{children:"i"})," in signing set"," ",e.jsx(i,{children:"S"}),":"]}),e.jsx(s,{children:"\\lambda_i = \\prod_{j \\in S, j \\neq i} \\frac{-j}{i - j}"}),e.jsx("p",{className:"mt-3",children:"Implementation:"}),e.jsx("pre",{className:"bg-gray-800 p-4 rounded mt-2 text-sm overflow-x-auto",children:`// Compute Lagrange coefficient for participant i in set S
fn lagrange_coefficient(i: u32, S: &[u32], q: &BigInt) -> BigInt {
    let mut numerator = BigInt::one();
    let mut denominator = BigInt::one();

    for &j in S {
        if j != i {
            // numerator *= -j (mod q)
            numerator = (numerator * (q - BigInt::from(j))) % q;
            // denominator *= (i - j) (mod q)
            let diff = if i > j {
                BigInt::from(i - j)
            } else {
                q - BigInt::from(j - i)
            };
            denominator = (denominator * diff) % q;
        }
    }

    // lambda_i = numerator * denominator^(-1) (mod q)
    (numerator * mod_inverse(&denominator, q)) % q
}`})]}),e.jsx("h3",{children:"Implementation Challenges"}),e.jsxs(t,{title:"Big Integer Arithmetic",children:[e.jsx("p",{children:"Native 64-bit integers cannot hold 256-bit values. Solutions:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Multi-precision libraries:"})," GMP, OpenSSL BIGNUM"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Fixed-size big integers:"})," uint256 types"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Language-specific:"})," Python's native arbitrary precision"]})]})]}),e.jsxs(t,{title:"Constant-Time Operations",children:[e.jsx("p",{children:"Naive implementations leak information via timing:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx(i,{children:"\\texttt{if (bit == 1)}"})," takes different time based on bit value"]}),e.jsx("li",{children:"Memory access patterns reveal secret data"}),e.jsx("li",{children:"CPU branch prediction leaks information"})]}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Solution:"})," Use constant-time conditional operations:"]}),e.jsx(s,{children:"\\texttt{result = (mask \\& a) | ((!mask) \\& b)}"})]}),e.jsxs(t,{title:"Modular Reduction",children:[e.jsxs("p",{children:["Efficient reduction modulo ",e.jsx(i,{children:"q"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Barrett reduction:"})," Precompute approximate inverse of"," ",e.jsx(i,{children:"q"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Montgomery form:"})," Work in transformed representation"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Special primes:"})," secp256k1's ",e.jsx(i,{children:"q"})," allows faster reduction"]})]})]}),e.jsx("h3",{children:"Elliptic Curve Operations"}),e.jsxs(t,{title:"Point Addition",children:[e.jsxs("p",{children:["For points ",e.jsx(i,{children:"P = (x_1, y_1)"})," and"," ",e.jsx(i,{children:"Q = (x_2, y_2)"})," on secp256k1:"]}),e.jsx(s,{children:"\\lambda = \\frac{y_2 - y_1}{x_2 - x_1}"}),e.jsx(s,{children:"x_3 = \\lambda^2 - x_1 - x_2"}),e.jsx(s,{children:"y_3 = \\lambda(x_1 - x_3) - y_1"}),e.jsxs("p",{className:"mt-3",children:["All operations are modulo the field prime ",e.jsx(i,{children:"p"}),"."]})]}),e.jsxs(t,{title:"Scalar Multiplication",children:[e.jsxs("p",{children:["Compute ",e.jsx(i,{children:"[k]G"})," (add ",e.jsx(i,{children:"G"})," to itself"," ",e.jsx(i,{children:"k"})," times) efficiently using double-and-add:"]}),e.jsx("pre",{className:"bg-gray-800 p-4 rounded mt-2 text-sm overflow-x-auto",children:`fn scalar_multiply(k: &BigInt, G: &Point) -> Point {
    let mut result = Point::infinity(); // identity
    let mut temp = G.clone();

    for bit in k.bits() {
        if bit {
            result = point_add(&result, &temp);
        }
        temp = point_double(&temp);
    }
    result
}`}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Warning:"})," This naive version has timing side channels. Use constant-time implementations in production."]})]}),e.jsx("h3",{children:"Summary"}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Key Implementation Requirements:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:"Use vetted big integer libraries"}),e.jsx("li",{children:"All operations in constant time"}),e.jsx("li",{children:"Careful modular arithmetic (handle negatives correctly)"}),e.jsx("li",{children:"Secure random number generation"}),e.jsx("li",{children:"Zero memory containing secrets when done"})]})]}),e.jsx("p",{children:"The mathematics of finite fields is beautiful, but the implementation details matter enormously for security. A mathematically correct but poorly implemented FROST is still vulnerable. Use established libraries and follow cryptographic engineering best practices."}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Congratulations!"}),e.jsxs("p",{className:"mt-2",children:["You've completed the mathematical journey through FROST. From the single point of failure problem to finite field arithmetic, you now understand not just ",e.jsx("em",{children:"what"})," ","FROST does, but ",e.jsx("em",{children:"why"})," and ",e.jsx("em",{children:"how"})," it works. This knowledge enables you to evaluate implementations, understand security properties, and appreciate the elegant mathematics that makes threshold signatures possible."]})]})]})}export{f as default};
