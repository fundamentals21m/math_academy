const i=[{id:1,type:"multiple-choice",question:"What is $x^2$ when $x=3$?",options:["$3$","$6$","$9$","$12$"],correctIndex:0,difficulty:"easy",explanation:"$3^2 = 9$"},{id:2,type:"multiple-choice",question:"Which of the following is a linear function?",options:["$f(x) = mx + b$","$f(x) = 2^x$","$f(x) = x^2$","$f(x) = x/x$"],correctIndex:0,difficulty:"medium",explanation:"A linear function has the form $f(x) = mx + b$ where $m$ and $b$ are constants."},{id:3,type:"numeric",question:"Calculate: $3 \\times 5 + 2$",correctAnswer:17,numericRange:{min:0,max:100,precision:0},difficulty:"easy",explanation:"$3 \\times 5 = 15$, then $15 + 2 = 17$"},{id:4,type:"numeric",question:"What is the value of $\\int_0^1 2x \\, dx$?",correctAnswer:1,numericRange:{min:0,max:100,precision:2},difficulty:"medium",explanation:"$$\\int_0^1 2x \\, dx = x^2 \\Big|_0^1 = 1 - 0 = 1$$"},{id:5,type:"text",question:"What is the name of the function $f(x) = \\log_a(x)$?",correctAnswer:"logarithm",difficulty:"medium",explanation:"A function of the form $f(x) = \\log_a(x)$ is called a logarithm."},{id:6,type:"text",question:"In the equation $y = mx + b$, what letter represents the slope?",correctAnswer:"m",difficulty:"easy",explanation:"The slope is represented by the letter $m$ in the linear equation $y = mx + b$."}],t=[{id:1,type:"multiple-choice",question:"In a $(t, n)$-threshold scheme, what does the parameter $t$ represent?",options:["The total number of shares created","The minimum number of shares needed to reconstruct the secret","The maximum number of participants who can be compromised","The degree of the polynomial used for sharing"],correctIndex:1,difficulty:"easy",explanation:"In a $(t, n)$-threshold scheme, $t$ represents the threshold - the minimum number of shares required to reconstruct the secret. Any $t$ shares can recover $s$, while $t-1$ shares reveal nothing."},{id:2,type:"multiple-choice",question:"In a 2-of-3 threshold scheme, what happens if an attacker steals exactly 1 share?",options:["They can reconstruct half of the secret","They can reconstruct the secret with enough computation","They learn zero information about the secret","They can forge signatures but not recover the key"],correctIndex:2,difficulty:"medium",explanation:"A key property of threshold schemes is that $t-1$ shares reveal nothing about the secret. In a 2-of-3 scheme, having only 1 share provides zero information about $s$."},{id:3,type:"multiple-choice",question:'What is the "single point of failure problem" that threshold schemes aim to solve?',options:["The problem of slow transaction verification on blockchain","The high cost of on-chain multisig transactions","The difficulty of generating truly random numbers","The risk that one compromised device or lost key means total loss of funds"],correctIndex:3,difficulty:"easy",explanation:"The single point of failure problem is that a single private key, if stolen or lost, results in complete loss of control over the associated funds. Threshold schemes distribute this risk across multiple parties."},{id:4,type:"numeric",question:"In a 3-of-5 threshold scheme, how many shares can an attacker possess while still learning nothing about the secret?",correctAnswer:2,numericRange:{min:0,max:5,precision:0},difficulty:"easy",explanation:"In a $t$-of-$n$ threshold scheme, an attacker can possess up to $t-1$ shares without learning anything about the secret. For a 3-of-5 scheme, this means $3-1=2$ shares."},{id:5,type:"multiple-choice",question:"Which of the following is NOT a challenge mentioned for building threshold signature schemes?",options:["The polynomial coefficients must all be prime numbers","$t-1$ shares must reveal zero information","Must be compatible with signature operations, not just reconstruction","Exactly $t$ shares needed, no more, no less"],correctIndex:0,difficulty:"medium",explanation:"The three main challenges are: the threshold property (exactly $t$ shares needed), information-theoretic security ($t-1$ shares reveal nothing), and usability with signatures (being able to sign without reconstructing). There is no requirement for polynomial coefficients to be prime."}],n=[{id:1,type:"multiple-choice",question:"What is a major limitation of traditional Bitcoin multisig for threshold security?",options:["It cannot support more than 2 participants","Each signature adds ~64 bytes on-chain, making transactions expensive","It requires all participants to be online simultaneously","It only works with ECDSA, not Schnorr signatures"],correctIndex:1,difficulty:"easy",explanation:"Traditional multisig requires each participant to submit a separate signature (~64 bytes each) on-chain. A 5-of-7 multisig requires 5 signatures, causing chain bloat and higher fees."},{id:2,type:"multiple-choice",question:"Why does Shamir Secret Sharing (SSS) alone fail to provide threshold signatures?",options:["SSS only works with prime fields, not elliptic curves","SSS cannot support thresholds greater than 3","To use the secret for signing, shares must be reconstructed in one place","SSS requires trusted setup that cannot be verified"],correctIndex:2,difficulty:"medium",explanation:"SSS is designed to reconstruct static secrets. To create a signature, the secret $s$ must be reassembled on a single computer, creating a single point of failure at the moment of reconstruction."},{id:3,type:"multiple-choice",question:"What privacy weakness exists in on-chain Bitcoin multisig transactions?",options:["The transaction amounts are visible to all observers","The message being signed is published in plaintext","The IP addresses of participants are logged","The threshold structure (e.g., 2-of-3) is revealed on-chain"],correctIndex:3,difficulty:"medium",explanation:"On-chain multisig reveals the exact threshold structure to all observers. Everyone can see that Alice uses 2-of-3, which may leak information about her security setup."},{id:4,type:"multiple-choice",question:"In Shamir Secret Sharing, what mathematical object encodes the secret?",options:["The constant term $f(0)$ of a polynomial","The leading coefficient of a polynomial","The hash of all polynomial coefficients","The product of all share values"],correctIndex:0,difficulty:"easy",explanation:"In Shamir Secret Sharing, the secret $s$ is encoded as the constant term of a polynomial: $f(0) = s$. The polynomial is $f(x) = s + a_1 x + a_2 x^2 + \\ldots + a_{t-1} x^{t-1}$."},{id:5,type:"multiple-choice",question:"Which combination of properties does FROST achieve that neither multisig nor SSS alone can provide?",options:["Threshold property and quantum resistance","On-chain efficiency, privacy, and no secret reconstruction","Unlimited participants and zero transaction fees","Instant finality and cross-chain compatibility"],correctIndex:1,difficulty:"hard",explanation:"FROST uniquely combines: on-chain efficiency (single signature), privacy (threshold hidden), and security (secret never reconstructed). Multisig lacks efficiency/privacy; SSS reconstructs the secret."}],o=[{id:1,type:"multiple-choice",question:'What does "Signature Indistinguishability" mean in FROST?',options:["All FROST signatures look identical to each other","FROST signatures cannot be verified by standard Schnorr verifiers","A FROST signature looks identical to a single-party Schnorr signature on-chain","The signing participants cannot be distinguished from each other"],correctIndex:2,difficulty:"medium",explanation:"Signature indistinguishability means a FROST threshold signature appears identical to a regular single-party Schnorr signature: 1 public key, 1 signature on-chain, regardless of $t$ or $n$."},{id:2,type:"multiple-choice",question:"In FROST, when is the private key $s$ reconstructed in one place?",options:["During key generation","During signing","During verification","Never - it is never reconstructed"],correctIndex:3,difficulty:"easy",explanation:"A key property of FROST is that the private key $s$ never exists in one place. Not during key generation, not during signing, never. This eliminates the single point of failure."},{id:3,type:"multiple-choice",question:"What is the Schnorr signature equation that FROST distributes?",options:["$z = k + s \\cdot c$","$z = k \\cdot s + c$","$z = k - s \\cdot c$","$z = k / (s + c)$"],correctIndex:0,difficulty:"medium",explanation:"The Schnorr signature response is $z = k + s \\cdot c$, where $k$ is the nonce, $s$ is the secret key, and $c$ is the challenge hash. FROST computes this collaboratively without reconstructing $k$ or $s$."},{id:4,type:"multiple-choice",question:"In FROST, how is the secret key $s$ shared among participants?",options:["XOR-based sharing: $s = s_1 \\oplus s_2 \\oplus \\ldots$","Shamir sharing with Lagrange coefficients: $s = \\sum_i s_i \\cdot \\lambda_i$","Additive sharing: $s = s_1 + s_2 + \\ldots$","Hash-based sharing: $s = H(s_1 \\| s_2 \\| \\ldots)$"],correctIndex:1,difficulty:"hard",explanation:"In FROST, the secret key is Shamir-shared, meaning $s = \\sum_i s_i \\cdot \\lambda_i$ where $\\lambda_i$ are the Lagrange coefficients. This allows any $t$ participants to sign."},{id:5,type:"multiple-choice",question:"How many communication rounds does FROST signing require (with preprocessing)?",options:["Zero rounds - completely non-interactive","Two rounds","One round","Three rounds"],correctIndex:2,difficulty:"medium",explanation:"FROST achieves single-round signing with preprocessing. After the setup phase, participants can sign with just one round of communication, making it highly efficient."}],a=[{id:1,type:"multiple-choice",question:"Which property is NOT required for an abelian group $(G, +)$?",options:["Existence of an identity element","Existence of inverses for each element","Commutativity: $g_1 + g_2 = g_2 + g_1$","Divisibility: any element can be divided by any non-zero element"],correctIndex:3,difficulty:"medium",explanation:"An abelian group requires: identity, inverses, associativity, and commutativity. Divisibility is not a group property - groups have multiplication (repeated addition) but not general division."},{id:2,type:"multiple-choice",question:"What does the notation $[s]G$ represent in elliptic curve cryptography?",options:["Scalar multiplication: $G$ added to itself $s$ times","The scalar $s$ encoded as a point","The discrete logarithm of $G$ with base $s$","A hash of $s$ concatenated with $G$"],correctIndex:0,difficulty:"easy",explanation:"$[s]G$ denotes scalar multiplication: $[s]G = \\underbrace{G + G + \\cdots + G}_{s \\text{ times}}$. The bracket notation emphasizes that $s$ is a scalar and $G$ is a group element."},{id:3,type:"multiple-choice",question:"What is the Discrete Logarithm Problem in elliptic curves?",options:["Given $s$, computing $Y = [s]G$ is hard","Given $Y = [s]G$, computing $s$ is hard","Given $G$, finding any point on the curve is hard","Given two points, computing their sum is hard"],correctIndex:1,difficulty:"medium",explanation:"The Discrete Logarithm Problem states that given $Y = [s]G$, computing $s$ is computationally infeasible. This is the one-way function that secures elliptic curve cryptography."},{id:4,type:"multiple-choice",question:"Which equation demonstrates the linearity property that makes threshold signatures possible?",options:["$[s_1]G \\cdot [s_2]G = [s_1 \\cdot s_2]G$","$[s_1 + s_2]G = [s_1]G \\cdot [s_2]G$","$[s_1]G + [s_2]G = [s_1 + s_2]G$","$[s]G + [s]G = [s^2]G$"],correctIndex:2,difficulty:"hard",explanation:"The linearity property $[s_1]G + [s_2]G = [s_1 + s_2]G$ is fundamental to threshold signatures. It allows combining partial computations from multiple parties without revealing individual secrets."},{id:5,type:"multiple-choice",question:"In Bitcoin's secp256k1 curve, approximately how many operations would be needed to solve the discrete log problem?",options:["$2^{64}$ operations","$2^{512}$ operations","$2^{256}$ operations","$2^{128}$ operations"],correctIndex:3,difficulty:"hard",explanation:"For secp256k1, no known algorithm can compute the discrete log in less than approximately $2^{128}$ operations, making it computationally infeasible with current technology."}],s=[{id:1,type:"multiple-choice",question:"In Schnorr signing, what is computed as $z = k + s \\cdot c$?",options:["The response","The challenge","The commitment","The public key"],correctIndex:0,difficulty:"easy",explanation:"The response $z$ is computed as $z = k + s \\cdot c$ where $k$ is the nonce, $s$ is the secret key, and $c$ is the challenge. This is the key computation in Schnorr signing."},{id:2,type:"multiple-choice",question:"What does the Schnorr verification equation check?",options:["$[z]G = R - [c]Y$","$[z]G = R + [c]Y$","$[z]G = R \\cdot [c]Y$","$[z]G = [c]R + Y$"],correctIndex:1,difficulty:"medium",explanation:"Schnorr verification checks that $[z]G = R + [c]Y$ where $R$ is the commitment, $Y$ is the public key, and $c$ is the challenge hash $c = H(R \\| Y \\| m)$."},{id:3,type:"multiple-choice",question:"In a Schnorr signature $\\sigma = (R, z)$, what is $R$?",options:["A random scalar chosen by the signer","The hash of the message being signed","The commitment point $R = [k]G$ where $k$ is the nonce","The public key of the signer"],correctIndex:2,difficulty:"medium",explanation:"$R = [k]G$ is the commitment - a curve point computed by scalar multiplying the generator $G$ by the random nonce $k$. It commits the signer to their nonce choice."},{id:4,type:"numeric",question:"Given $s = 7$, $k = 13$, and $c = 5$, what is the Schnorr response $z = k + s \\cdot c$?",correctAnswer:48,numericRange:{min:0,max:1e3,precision:0},difficulty:"easy",explanation:"$z = k + s \\cdot c = 13 + 7 \\cdot 5 = 13 + 35 = 48$"},{id:5,type:"multiple-choice",question:"How is the challenge $c$ computed in Schnorr signatures?",options:["$c = R + Y + m$","$c$ is a random value chosen by the verifier","$c = k \\cdot s \\mod q$","$c = H(R \\| Y \\| m)$ where $H$ is a hash function"],correctIndex:3,difficulty:"medium",explanation:"The challenge $c$ is computed as $c = H(R \\| Y \\| m)$, hashing the commitment $R$, public key $Y$, and message $m$ together. This binds the signature to the specific message and public key."}],r=[{id:1,type:"multiple-choice",question:"Starting from $z = k + s \\cdot c$, what is the first step in proving $[z]G = R + [c]Y$?",options:["Apply scalar multiplication to get $[k + s \\cdot c]G$","Substitute $Y = [s]G$ into the equation","Compute the hash $c = H(R \\| Y \\| m)$","Factor out $G$ from both sides"],correctIndex:0,difficulty:"medium",explanation:"The proof starts by substituting the definition $z = k + s \\cdot c$ into $[z]G$, giving us $[k + s \\cdot c]G$ on the left side."},{id:2,type:"multiple-choice",question:"Which algebraic property allows us to write $[k + s \\cdot c]G = [k]G + [s \\cdot c]G$?",options:["Commutativity of scalar multiplication","Distributivity of scalar addition over point multiplication","Associativity of the group operation","The discrete logarithm hardness assumption"],correctIndex:1,difficulty:"hard",explanation:"Distributivity states that $[a + b]G = [a]G + [b]G$. This allows us to split the scalar sum into a sum of points."},{id:3,type:"multiple-choice",question:"In the verification proof, we use $R = [k]G$ and $Y = [s]G$. What relationship completes the proof?",options:["$[s \\cdot c]G = [s]G \\cdot [c]G$","$[s \\cdot c]G = [s + c]G$","$[s \\cdot c]G = [c]([s]G) = [c]Y$","$[s \\cdot c]G = [s]G + [c]G$"],correctIndex:2,difficulty:"hard",explanation:"The key relationship is $[s \\cdot c]G = [c]([s]G) = [c]Y$, using the associativity of scalar multiplication: multiplying by $c$ then by $G$ equals multiplying $[s]G$ by $c$."},{id:4,type:"multiple-choice",question:"What does the verification equation $[z]G = R + [c]Y$ prove about the signer?",options:["The signer knows the message $m$","The signer used a hardware wallet","The signer has access to the blockchain","The signer knows the secret $s$ corresponding to public key $Y$"],correctIndex:3,difficulty:"medium",explanation:"The verification equation proves the signer knows $s$. To produce a valid $z = k + s \\cdot c$ for a commitment $R = [k]G$ and challenge $c$, the signer must know $s$."},{id:5,type:"multiple-choice",question:"Why is the linearity property $[s_1]G + [s_2]G = [s_1 + s_2]G$ crucial for FROST?",options:["It enables combining partial signature shares without revealing individual secrets","It allows faster computation of scalar multiplication","It makes signatures smaller on-chain","It provides quantum resistance"],correctIndex:0,difficulty:"hard",explanation:"Linearity allows FROST participants to compute $z_i = k_i + s_i \\lambda_i \\cdot c$ locally, and when summed: $\\sum z_i = k + s \\cdot c$. The final signature is correct without anyone computing $s$ directly."}],c=[{id:1,type:"multiple-choice",question:'What does the "soundness" property of Schnorr signatures guarantee?',options:["Signatures are always exactly 64 bytes","No one can create a valid signature without knowing the secret key","Verification always completes in constant time","The same message always produces the same signature"],correctIndex:1,difficulty:"easy",explanation:"Soundness means no one can forge a valid signature without knowing the secret key $s$. Without $s$, an attacker cannot compute $z = k + s \\cdot c$ for any chosen $k$."},{id:2,type:"multiple-choice",question:'What does the "zero-knowledge" property mean for Schnorr signatures?',options:["The signature contains zero bytes of data","Verification requires zero computational resources","The signature reveals no information about the secret key beyond what the public key already reveals","The signer learns nothing about the message they are signing"],correctIndex:2,difficulty:"medium",explanation:"Zero-knowledge means signatures reveal nothing about $s$ beyond what could be computed from $Y = [s]G$ alone. Both $z$ and $R$ appear random, and multiple signatures do not leak cumulative information."},{id:3,type:"multiple-choice",question:"In the simulation argument for zero-knowledge, how is a valid-looking signature created without knowing $s$?",options:["By solving the discrete logarithm problem","By guessing the nonce $k$ correctly","By reusing a previous valid signature","By choosing random $z$ and $c$, then computing $R = [z]G - [c]Y$"],correctIndex:3,difficulty:"hard",explanation:"A simulator chooses random $z$ and $c$, then computes $R = [z]G - [c]Y$. This $(R, z)$ passes verification but was created without knowing $s$, proving real signatures reveal nothing."},{id:4,type:"multiple-choice",question:'Why is the hash function modeled as a "random oracle" in Schnorr security proofs?',options:["To prevent attackers from predicting $H(R \\| Y \\| m)$ before committing to $R$","To ensure signatures are always the same length","To make verification faster","To allow deterministic signature generation"],correctIndex:0,difficulty:"hard",explanation:'The random oracle model ensures attackers cannot predict $H(R \\| Y \\| m)$ without first choosing $R$. This prevents "working backwards" from a desired challenge to forge a signature.'},{id:5,type:"multiple-choice",question:"What security properties must FROST preserve from standard Schnorr signatures?",options:["Only soundness","Soundness, zero-knowledge, and no secret reconstruction","Only zero-knowledge","Determinism and reproducibility"],correctIndex:1,difficulty:"medium",explanation:"FROST must preserve: soundness (cannot forge without $t$ participants), zero-knowledge (signatures reveal nothing about shares), and add the property that $s$ is never reconstructed."}],l=[{id:1,type:"multiple-choice",question:"If you sign two messages $m_1$ and $m_2$ with the same nonce $k$, what can an attacker extract?",options:["Only the message hashes","The nonce $k$ but not the private key","The private key $s$","Nothing useful without the public key"],correctIndex:2,difficulty:"easy",explanation:"With two signatures using the same nonce: $z_1 = k + s \\cdot c_1$ and $z_2 = k + s \\cdot c_2$. Subtracting gives $z_1 - z_2 = s(c_1 - c_2)$, so $s = (z_1 - z_2)/(c_1 - c_2)$."},{id:2,type:"multiple-choice",question:"Given $z_1 - z_2 = s \\cdot (c_1 - c_2)$, what formula extracts the private key $s$?",options:["$s = (z_1 - z_2) \\cdot (c_1 - c_2)$","$s = (z_1 + z_2) / (c_1 + c_2)$","$s = (c_1 - c_2) / (z_1 - z_2)$","$s = (z_1 - z_2) / (c_1 - c_2)$"],correctIndex:3,difficulty:"medium",explanation:"From $z_1 - z_2 = s \\cdot (c_1 - c_2)$, we solve for $s$ by dividing: $s = (z_1 - z_2) / (c_1 - c_2)$. This simple algebra completely breaks the signature scheme."},{id:3,type:"numeric",question:"Given $s = 7$, $k = 13$, $c_1 = 5$, $c_2 = 3$: if $z_1 = 48$ and $z_2 = 34$, verify that $(z_1 - z_2)/(c_1 - c_2)$ equals $s$.",correctAnswer:7,numericRange:{min:0,max:100,precision:0},difficulty:"easy",explanation:"$(z_1 - z_2)/(c_1 - c_2) = (48 - 34)/(5 - 3) = 14/2 = 7 = s$. The attacker recovers the private key with simple arithmetic."},{id:4,type:"multiple-choice",question:"Which real-world incident was caused by nonce reuse in ECDSA signatures?",options:["The PlayStation 3 private key extraction","The DAO hack in Ethereum","The Mt. Gox exchange collapse","The Bitcoin block size debate"],correctIndex:0,difficulty:"medium",explanation:"In 2010, Sony used a constant nonce for all PS3 ECDSA signatures. Hackers extracted Sony's private key and could then sign any code to run on the PS3."},{id:5,type:"multiple-choice",question:"In FROST, how is nonce reuse prevented?",options:["Nonces are derived deterministically from the message","Each participant generates $(d_i, e_i)$ pairs used exactly once, then deleted","A central coordinator assigns unique nonces to each participant","Nonces are stored on the blockchain to prevent reuse"],correctIndex:1,difficulty:"hard",explanation:"FROST participants generate nonce pairs $(d_i, e_i)$ during preprocessing. Each pair is used exactly once for signing and then securely deleted. State management ensures no reuse across sessions."}],h=[{id:1,type:"multiple-choice",question:"In Shamir Secret Sharing, where is the secret encoded in the polynomial $f(x) = s + a_1 x + a_2 x^2 + \\ldots$?",options:["In the leading coefficient $a_{t-1}$","In the sum of all coefficients","In the constant term $f(0) = s$","In the degree of the polynomial"],correctIndex:2,difficulty:"easy",explanation:"The secret is the constant term: $f(0) = s$. This is the key insight of Shamir's scheme - evaluating the polynomial at $x=0$ gives the secret."},{id:2,type:"multiple-choice",question:"For a $t$-of-$n$ threshold scheme, what is the degree of the sharing polynomial?",options:["$n$","$t$","$n - 1$","$t - 1$"],correctIndex:3,difficulty:"medium",explanation:"The polynomial has degree $t-1$ so that exactly $t$ points uniquely determine it. This is because a polynomial of degree $t-1$ has $t$ coefficients and needs $t$ equations to solve."},{id:3,type:"multiple-choice",question:"How are shares generated from the polynomial $f(x)$?",options:["By evaluating $f(i)$ at distinct non-zero points for each participant $i$","By computing $f(0)$ for each participant","By computing the derivative $f'(x)$ at each point","By factoring the polynomial into linear terms"],correctIndex:0,difficulty:"easy",explanation:"Shares are points on the polynomial: participant $i$ receives $(i, f(i))$. The $x$-coordinates must be distinct and non-zero (since $f(0) = s$ is the secret)."},{id:4,type:"numeric",question:"For the polynomial $f(x) = 42 + 17x + 8x^2$, what is the share value $f(2)$?",correctAnswer:108,numericRange:{min:0,max:500,precision:0},difficulty:"medium",explanation:"$f(2) = 42 + 17(2) + 8(2^2) = 42 + 34 + 32 = 108$"},{id:5,type:"multiple-choice",question:"Why does a polynomial of degree $t-1$ require exactly $t$ points to determine?",options:["Because each point eliminates one possible polynomial","Because the polynomial has $t$ coefficients, needing $t$ equations","Because of the discrete logarithm problem","Because $t-1$ points always form a unique line"],correctIndex:1,difficulty:"hard",explanation:"A degree $t-1$ polynomial $f(x) = a_0 + a_1 x + \\ldots + a_{t-1} x^{t-1}$ has $t$ unknown coefficients. Each point $(x_i, f(x_i))$ gives one linear equation. We need $t$ equations to solve for $t$ unknowns."}],d=[{id:1,type:"multiple-choice",question:"What is the Lagrange basis polynomial $L_i(x)$ designed to satisfy?",options:["$L_i(x_i) = 0$ and $L_i(x_j) = 1$ for $j \\neq i$","$L_i(x) = x_i$ for all $x$","$L_i(x_i) = 1$ and $L_i(x_j) = 0$ for $j \\neq i$","$L_i(x) = 1$ for all $x$"],correctIndex:2,difficulty:"medium",explanation:`The Lagrange basis polynomial $L_i(x)$ equals 1 at its "own" point $x_i$ and equals 0 at all other points $x_j$ for $j \\neq i$. This "picks out" each point's contribution.`},{id:2,type:"multiple-choice",question:"What is the formula for the Lagrange basis polynomial $L_i(x)$?",options:["$L_i(x) = \\sum_{j \\neq i} \\frac{x - x_j}{x_i - x_j}$","$L_i(x) = \\sum_{j \\neq i} (x - x_j)(x_i - x_j)$","$L_i(x) = \\prod_{j \\neq i} \\frac{x_i - x_j}{x - x_j}$","$L_i(x) = \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}$"],correctIndex:3,difficulty:"hard",explanation:"The Lagrange basis polynomial is $L_i(x) = \\prod_{j \\neq i} \\frac{x - x_j}{x_i - x_j}$. The product of terms ensures $L_i(x_j) = 0$ when any $(x - x_j) = 0$, and the denominator normalizes so $L_i(x_i) = 1$."},{id:3,type:"multiple-choice",question:"How is the secret $s = f(0)$ recovered using Lagrange interpolation?",options:["$s = \\sum_{i=1}^{t} y_i \\cdot L_i(0)$","$s = \\prod_{i=1}^{t} y_i \\cdot L_i(0)$","$s = \\sum_{i=1}^{t} y_i / L_i(0)$","$s = y_1 \\cdot L_1(0) - y_2 \\cdot L_2(0)$"],correctIndex:0,difficulty:"medium",explanation:"The secret is recovered as $s = f(0) = \\sum_{i=1}^{t} y_i \\cdot L_i(0) = \\sum_{i=1}^{t} y_i \\cdot \\lambda_i$, a weighted sum of share values using Lagrange coefficients evaluated at 0."},{id:4,type:"numeric",question:"For shares at $x = 1, 2, 3$, compute $\\lambda_1 = \\frac{(0-2)(0-3)}{(1-2)(1-3)}$.",correctAnswer:3,numericRange:{min:-10,max:10,precision:0},difficulty:"medium",explanation:"$\\lambda_1 = \\frac{(0-2)(0-3)}{(1-2)(1-3)} = \\frac{(-2)(-3)}{(-1)(-2)} = \\frac{6}{2} = 3$"},{id:5,type:"multiple-choice",question:"What important property do Lagrange coefficients $\\lambda_i$ always satisfy?",options:["$\\prod_i \\lambda_i = 1$","$\\sum_i \\lambda_i = 1$","$\\sum_i \\lambda_i = 0$","$\\lambda_i > 0$ for all $i$"],correctIndex:1,difficulty:"hard",explanation:"The Lagrange coefficients always sum to 1: $\\sum_i \\lambda_i = 1$. This is because $\\sum_i L_i(x) = 1$ for all $x$ (the basis polynomials form a partition of unity)."}],u=[{id:1,type:"numeric",question:"Given shares $(1, 67), (2, 108), (3, 165)$ and Lagrange coefficients $\\lambda_1 = 3$, $\\lambda_2 = -3$, $\\lambda_3 = 1$, compute $s = \\sum y_i \\lambda_i$.",correctAnswer:42,numericRange:{min:0,max:500,precision:0},difficulty:"medium",explanation:"$s = 67 \\cdot 3 + 108 \\cdot (-3) + 165 \\cdot 1 = 201 - 324 + 165 = 42$"},{id:2,type:"multiple-choice",question:"When using a different subset of shares for reconstruction, what changes?",options:["The reconstructed secret $s$ changes","The polynomial degree changes","The Lagrange coefficients $\\lambda_i$ change but the result $s$ is the same","Nothing changes - coefficients and result are identical"],correctIndex:2,difficulty:"medium",explanation:"Different subsets give different Lagrange coefficients (since $\\lambda_i$ depends on which $x_j$ are in the set), but the reconstructed secret $s = \\sum y_i \\lambda_i$ is always the same."},{id:3,type:"numeric",question:"For shares at $x = 1, 3, 4$, compute $\\lambda_1 = \\frac{(0-3)(0-4)}{(1-3)(1-4)}$.",correctAnswer:2,numericRange:{min:-10,max:10,precision:0},difficulty:"hard",explanation:"$\\lambda_1 = \\frac{(0-3)(0-4)}{(1-3)(1-4)} = \\frac{(-3)(-4)}{(-2)(-3)} = \\frac{12}{6} = 2$"},{id:4,type:"multiple-choice",question:"Verify: For $\\lambda_1 = 3$, $\\lambda_2 = -3$, $\\lambda_3 = 1$, does $\\sum \\lambda_i = 1$?",options:["No, the sum is 0","No, the sum is 3","Cannot determine without the shares","Yes, $3 + (-3) + 1 = 1$"],correctIndex:3,difficulty:"easy",explanation:"$\\lambda_1 + \\lambda_2 + \\lambda_3 = 3 + (-3) + 1 = 1$ \\checkmark. This sum-to-one property is a useful sanity check during implementation."},{id:5,type:"multiple-choice",question:"In FROST, why do we NOT actually reconstruct the secret $s$ using Lagrange interpolation?",options:["We use Lagrange coefficients to compute with shares directly, avoiding reconstruction","Lagrange interpolation is too slow for practical use","FROST uses a different mathematical framework entirely","The secret is stored encrypted on a blockchain instead"],correctIndex:0,difficulty:"hard",explanation:"In FROST, each participant computes $s_i \\cdot \\lambda_i$ locally with their share. The sum gives the effect of using $s$ without anyone computing $s$ directly. This is the key to threshold signing."}],p=[{id:1,type:"multiple-choice",question:"What type of security does Shamir Secret Sharing provide against an attacker with $t-1$ shares?",options:["Computational security - hard to break but theoretically possible","Information-theoretic security - impossible to break even with infinite computing power","Heuristic security - secure in practice but unproven","Probabilistic security - likely secure with high probability"],correctIndex:1,difficulty:"medium",explanation:"Shamir SSS provides information-theoretic security: with $t-1$ shares, every possible secret is equally consistent with the known shares. No amount of computation can determine the true secret."},{id:2,type:"multiple-choice",question:"With 2 shares from a degree-2 polynomial, how many different secrets are consistent with those shares?",options:["Exactly 2 possible secrets","A finite number equal to the field size $q$","Infinitely many - every possible secret value","Only 1 if the shares are correct"],correctIndex:2,difficulty:"hard",explanation:"For every possible secret $s^*$, there exists exactly one degree-2 polynomial passing through the 2 known points with $f(0) = s^*$. Thus infinitely many secrets (or all $q$ values in a finite field) are equally consistent."},{id:3,type:"multiple-choice",question:"Given $t-1$ points and a target secret $s^*$, why does exactly one consistent polynomial exist?",options:["Because the discrete logarithm is hard to compute","Because Lagrange interpolation always succeeds","Because polynomials are uniquely determined by their roots","Because we have $t$ constraints ($t-1$ points plus $f(0) = s^*$) and $t$ unknown coefficients"],correctIndex:3,difficulty:"hard",explanation:"A degree $t-1$ polynomial has $t$ coefficients. With $t-1$ known points plus the constraint $f(0) = s^*$, we have $t$ linear equations in $t$ unknowns, which has exactly one solution."},{id:4,type:"multiple-choice",question:"How does information-theoretic security differ from computational security?",options:["Computational security can be broken with enough time; information-theoretic cannot be broken at all","Information-theoretic requires larger key sizes","Information-theoretic only works with prime fields","They are equivalent for practical purposes"],correctIndex:0,difficulty:"medium",explanation:"Computational security (e.g., discrete log) assumes breaking is infeasible but not impossible. Information-theoretic security means the information literally does not exist - no computation can extract it."},{id:5,type:"multiple-choice",question:"For secp256k1 with field size $q \\approx 2^{256}$, what is an attacker's probability of guessing the secret with $t-1$ shares?",options:["$1/2$ (50% chance)","$1/q \\approx 1/2^{256}$ (astronomically small)","$1/t$ (depends on threshold)","$0$ (impossible)"],correctIndex:1,difficulty:"medium",explanation:"With $t-1$ shares, every secret in $\\mathbb{Z}_q$ is equally likely. The probability of guessing correctly is $1/q \\approx 1/2^{256}$, which is astronomically small."}],m=[{id:1,type:"multiple-choice",question:"What problem does Feldman Verifiable Secret Sharing (VSS) solve that plain Shamir SSS cannot?",options:["Reducing the number of shares needed for reconstruction","Making reconstruction faster with parallel computation","Allowing participants to verify their shares are correct without trusting the dealer","Enabling shares to be updated without changing the secret"],correctIndex:2,difficulty:"easy",explanation:"Feldman VSS allows participants to verify their shares are valid. A malicious dealer giving incorrect shares would be detected, whereas plain Shamir requires trusting the dealer."},{id:2,type:"multiple-choice",question:"In Feldman VSS, what are the commitments $C_j = [a_j]G$?",options:["Hashes of the polynomial coefficients","Random values chosen by participants","Encrypted versions of the shares","Curve points computed by scalar-multiplying the generator by each coefficient"],correctIndex:3,difficulty:"medium",explanation:"Commitments are $C_j = [a_j]G$ - each polynomial coefficient $a_j$ multiplied by the generator $G$. These hide the coefficients (discrete log hard) but allow verification."},{id:3,type:"multiple-choice",question:"What equation does participant $i$ check to verify their share $s_i$ in Feldman VSS?",options:["$[s_i]G = C_0 + [i]C_1 + [i^2]C_2 + \\ldots + [i^{t-1}]C_{t-1}$","$[s_i]G = C_0 \\cdot C_1 \\cdot \\ldots \\cdot C_{t-1}$","$s_i = C_0 + i \\cdot C_1 + i^2 \\cdot C_2 + \\ldots$","$[s_i]G = H(C_0, C_1, \\ldots, C_{t-1})$"],correctIndex:0,difficulty:"hard",explanation:'The verification equation is $[s_i]G = C_0 + [i]C_1 + [i^2]C_2 + \\ldots + [i^{t-1}]C_{t-1}$. This is the polynomial evaluated "in the exponent" - it equals $[f(i)]G$ if the share is correct.'},{id:4,type:"multiple-choice",question:'What is a "verification share" $Y_j$ in Feldman VSS?',options:["A backup copy of participant $j$'s share","The public key $[s_j]G$ corresponding to participant $j$'s secret share","A hash that participant $j$ uses to prove they participated","The dealer's signature on participant $j$'s share"],correctIndex:1,difficulty:"medium",explanation:"A verification share $Y_j = [s_j]G$ is the public key for participant $j$'s secret share. Anyone can compute it from the commitments, enabling signature share verification in FROST."},{id:5,type:"multiple-choice",question:"If a dealer sends participant 2 an incorrect share $s_2' = 200$ instead of the correct $s_2 = 108$, what happens during verification?",options:["Verification passes because the dealer controls the commitments","The other participants cannot detect the cheating","Verification fails: $[200]G \\neq C_0 + [2]C_1 + [4]C_2$","The incorrect share is automatically corrected"],correctIndex:2,difficulty:"medium",explanation:"The verification equation $[s_2']G = [200]G$ will not equal $C_0 + [2]C_1 + [4]C_2 = [108]G$ because the commitments were published for the correct polynomial. Participant 2 detects the cheating."}],g=[{id:1,type:"multiple-choice",question:"Why does naively using Shamir Secret Sharing for threshold Schnorr signatures fail?",options:["Shamir shares are too large to fit in a signature","Shamir polynomials are incompatible with elliptic curves","Lagrange interpolation is too slow for real-time signing","The secret $s$ must be reconstructed to compute $z = k + s \\cdot c$, creating a single point of failure"],correctIndex:3,difficulty:"medium",explanation:"To compute the Schnorr response $z = k + s \\cdot c$, naive SSS would require reconstructing $s$ on some device. That device then knows the full private key - exactly the single point of failure we wanted to avoid."},{id:2,type:"multiple-choice",question:"What are the two types of secrets needed for Schnorr threshold signing?",options:["The long-term secret $s$ and the ephemeral nonce $k$","The message hash and the public key","The challenge $c$ and the response $z$","The commitment $R$ and the signature $\\sigma$"],correctIndex:0,difficulty:"easy",explanation:"Schnorr signing requires the long-term secret key $s$ (Shamir-shared, used for all signatures) and an ephemeral nonce $k$ (fresh for each signature, must never be reused)."},{id:3,type:"multiple-choice",question:"Why can't we simply run full Shamir sharing for the nonce $k$ each time we sign?",options:["Shamir sharing only works with prime fields","A dealer would need to choose $k$, meaning they would know it - defeating the purpose","Nonces must be larger than the prime field order","Lagrange coefficients cannot be computed for nonces"],correctIndex:1,difficulty:"hard",explanation:"Shamir sharing requires a dealer to generate the polynomial. If someone generates $k$ and distributes shares, they know $k$. Combined with $s$, they could forge signatures - creating a single point of failure."},{id:4,type:"multiple-choice",question:"What is the FROST insight for handling the nonce $k$?",options:["Use the same nonce for all signatures","Derive the nonce deterministically from the message","Use additive shares $k = k_1 + k_2 + \\ldots + k_t$ where each participant generates their own $k_i$","Have a trusted third party generate all nonces"],correctIndex:2,difficulty:"medium",explanation:"FROST uses additive nonce shares: each participant generates their own random $k_i$, and $k = \\sum k_i$. This requires no coordination or trusted dealer - each participant acts independently."},{id:5,type:"multiple-choice",question:"What is the mathematical challenge in computing $z = k + s \\cdot c$ with both additive shares ($k$) and polynomial shares ($s$)?",options:["Additive and polynomial shares use different prime fields","Polynomial shares require more participants than additive shares","The challenge $c$ depends on knowing $s$ first","They are different types of shares that cannot be directly combined"],correctIndex:3,difficulty:"hard",explanation:"The nonce $k$ is additively shared ($k = \\sum k_i$) while $s$ is polynomially shared ($s = \\sum s_i \\lambda_i$). FROST's key innovation is a way to compute with both types without reconstruction."}],f=[{id:1,type:"multiple-choice",question:"In Shamir (polynomial) secret sharing, what is the minimum number of shares needed to reconstruct a secret when using a degree $t-1$ polynomial?",options:["$t-1$ shares","$t$ shares","$t+1$ shares","All $n$ shares"],correctIndex:1,difficulty:"easy",explanation:"A degree $t-1$ polynomial has $t$ coefficients, so $t$ points are needed to uniquely determine it. Any $t$ of $n$ shares can reconstruct the secret."},{id:2,type:"multiple-choice",question:"What is the key difference between additive shares and Shamir (polynomial) shares?",options:["Additive shares require ALL shares to reconstruct, while Shamir allows any $t$-of-$n$","Additive shares are more secure than Shamir shares","Shamir shares are simpler to compute than additive shares","Additive shares can only be used for encryption, not signatures"],correctIndex:0,difficulty:"medium",explanation:"Additive secret sharing is $t$-of-$t$ (all shares needed), while Shamir secret sharing provides threshold flexibility with any $t$-of-$n$ shares sufficient for reconstruction."},{id:3,type:"multiple-choice",question:"In FROST, why are Shamir shares used for the long-term secret key $s$ but additive shares used for the nonce $k$?",options:["Additive shares are more secure for nonces","Shamir shares provide threshold flexibility for signing, while additive shares allow non-interactive nonce generation","Shamir shares are faster to compute","Additive shares work better with elliptic curves"],correctIndex:1,difficulty:"medium",explanation:"The long-term key $s$ uses Shamir shares so any $t$ participants can sign. The nonce $k$ uses additive shares because we already know which $t$ participants are signing, and each can generate their $k_i$ independently without coordination."},{id:4,type:"multiple-choice",question:"Given additive shares $k_1 = 47$, $k_2 = 83$, and $k_3 = 120$, what is the shared secret $k$?",options:["$47$","$83$","$120$","$250$"],correctIndex:3,difficulty:"easy",explanation:"For additive shares, the secret is simply the sum: $k = k_1 + k_2 + k_3 = 47 + 83 + 120 = 250$."},{id:5,type:"multiple-choice",question:"Which formula correctly represents Shamir secret reconstruction using Lagrange coefficients?",options:["$s = \\sum_{i \\in S} s_i$","$s = \\prod_{i \\in S} s_i \\cdot \\lambda_i$","$s = \\sum_{i \\in S} s_i \\cdot \\lambda_i$","$s = \\max_{i \\in S} s_i \\cdot \\lambda_i$"],correctIndex:2,difficulty:"medium",explanation:"Shamir reconstruction uses weighted sum with Lagrange coefficients: $s = \\sum_{i \\in S} s_i \\cdot \\lambda_i$. The $\\lambda_i$ values depend on which participants are in the signing set $S$."}],$=[{id:1,type:"multiple-choice",question:"According to the transformation theorem, how can additive shares $k_i$ be converted to polynomial shares $\\tilde{k}_i$?",options:["$\\tilde{k}_i = k_i + \\lambda_i$","$\\tilde{k}_i = k_i \\cdot \\lambda_i$","$\\tilde{k}_i = k_i - \\lambda_i$","$\\tilde{k}_i = k_i / \\lambda_i$"],correctIndex:3,difficulty:"medium",explanation:"To convert additive shares to polynomial shares, divide by the Lagrange coefficient: $\\tilde{k}_i = k_i / \\lambda_i$. This works because when reconstructed via $\\sum \\tilde{k}_i \\cdot \\lambda_i$, the coefficients cancel."},{id:2,type:"multiple-choice",question:"What fundamental property of Lagrange coefficients makes the share conversion theorem work?",options:["They sum to 1: $\\sum_{i \\in S} \\lambda_i = 1$","They are always positive integers","They are always less than the secret","They are always prime numbers"],correctIndex:0,difficulty:"hard",explanation:"The Lagrange coefficients for any set $S$ sum to 1: $\\sum_{i \\in S} \\lambda_i = 1$. This follows from the fact that the constant polynomial 1 interpolates through points $(x_i, 1)$ for all $i$."},{id:3,type:"multiple-choice",question:"To convert polynomial shares $s_i$ to additive shares $\\tilde{s}_i$, which formula is correct?",options:["$\\tilde{s}_i = s_i / \\lambda_i$","$\\tilde{s}_i = s_i \\cdot \\lambda_i$","$\\tilde{s}_i = s_i + \\lambda_i$","$\\tilde{s}_i = s_i - \\lambda_i$"],correctIndex:1,difficulty:"medium",explanation:"Polynomial to additive conversion uses multiplication: $\\tilde{s}_i = s_i \\cdot \\lambda_i$. These form additive shares because $\\sum_i \\tilde{s}_i = \\sum_i s_i \\cdot \\lambda_i = s$ (the polynomial reconstruction formula)."},{id:4,type:"multiple-choice",question:"If participants $\\{1, 2, 3\\}$ have Lagrange coefficients $\\lambda_1 = 3$, $\\lambda_2 = -3$, $\\lambda_3 = 1$, what is their sum?",options:["$0$","$1$","$3$","$7$"],correctIndex:1,difficulty:"easy",explanation:"$\\lambda_1 + \\lambda_2 + \\lambda_3 = 3 + (-3) + 1 = 1$. This confirms the fundamental property that Lagrange coefficients always sum to 1."},{id:5,type:"multiple-choice",question:"Why do converted polynomial shares $\\tilde{k}_i = k_i / \\lambda_i$ depend on the signing set $S$?",options:["Because $k_i$ changes based on the signing set","Because the conversion formula is different for each set","Because Lagrange coefficients $\\lambda_i$ depend on which participants are in $S$","Because the hash function depends on $S$"],correctIndex:2,difficulty:"hard",explanation:"The Lagrange coefficient $\\lambda_i$ for participant $i$ depends on which other participants are in the signing set $S$. Different signing sets produce different $\\lambda_i$ values, and thus different converted shares."}],y=[{id:1,type:"multiple-choice",question:"Given additive nonce shares $k_1 = 100$, $k_2 = 200$, $k_3 = 150$ and Lagrange coefficients $\\lambda_1 = 3$, $\\lambda_2 = -3$, $\\lambda_3 = 1$, what is $\\tilde{k}_2$ (the polynomial share for participant 2)?",options:["$100/3$","$-200/3$","$150$","$600$"],correctIndex:1,difficulty:"medium",explanation:"Using the transformation $\\tilde{k}_i = k_i / \\lambda_i$, we get $\\tilde{k}_2 = 200 / (-3) = -200/3$."},{id:2,type:"multiple-choice",question:"When verifying the polynomial share reconstruction $k = \\sum \\tilde{k}_i \\cdot \\lambda_i$ with converted shares, what happens to the Lagrange coefficients?",options:["They are doubled","They are squared","They become negative","They cancel out, leaving the original additive sum"],correctIndex:3,difficulty:"hard",explanation:"When reconstructing: $\\sum \\tilde{k}_i \\cdot \\lambda_i = \\sum (k_i / \\lambda_i) \\cdot \\lambda_i = \\sum k_i$. The Lagrange coefficients cancel, giving back the original additive sum."},{id:3,type:"multiple-choice",question:"In modular arithmetic (used in practice), how is division by $\\lambda_i$ computed?",options:["Using multiplication by the modular inverse of $\\lambda_i$","Using floating point division","Using subtraction","Using the square root"],correctIndex:0,difficulty:"medium",explanation:"In modular arithmetic mod $q$, division by $\\lambda_i$ is computed as multiplication by its modular inverse: $k_i / \\lambda_i = k_i \\cdot \\lambda_i^{-1} \\mod q$. There are no fractions in the actual computation."},{id:4,type:"multiple-choice",question:"If polynomial shares of the secret $s$ are $s_1 = 42$, $s_2 = 67$, $s_3 = 31$ with $\\lambda_1 = 3$, $\\lambda_2 = -3$, $\\lambda_3 = 1$, what is the additive share $\\tilde{s}_1$?",options:["$42$","$126$","$14$","$-126$"],correctIndex:1,difficulty:"easy",explanation:"Converting polynomial to additive: $\\tilde{s}_1 = s_1 \\cdot \\lambda_1 = 42 \\cdot 3 = 126$."},{id:5,type:"multiple-choice",question:"What is the main purpose of share conversion in FROST?",options:["To make shares smaller for storage","To enable combining additively-shared nonces with polynomially-shared secret keys","To encrypt the shares","To verify the shares are correct"],correctIndex:1,difficulty:"medium",explanation:"Share conversion allows FROST to combine the additively-shared nonce $k$ with the polynomially-shared secret key $s$ in the Schnorr response formula $z = k + s \\cdot c$, enabling distributed computation without reconstruction."}],b=[{id:1,type:"multiple-choice",question:"What is the FROST signature share formula for participant $i$?",options:["$z_i = k_i + s_i \\cdot c$","$z_i = k_i \\cdot \\lambda_i + s_i \\cdot c$","$z_i = k_i + s_i \\cdot \\lambda_i \\cdot c$","$z_i = k_i + s_i + \\lambda_i + c$"],correctIndex:2,difficulty:"medium",explanation:"The FROST signature share is $z_i = k_i + s_i \\cdot \\lambda_i \\cdot c$. The Lagrange coefficient $\\lambda_i$ multiplies the secret share $s_i$, converting polynomial shares to additive form during aggregation."},{id:2,type:"multiple-choice",question:"When signature shares $z_i$ are aggregated as $z = \\sum z_i$, what does the result equal?",options:["$z = k \\cdot s \\cdot c$","$z = (k + s) \\cdot c$","$z = k - s \\cdot c$","$z = k + s \\cdot c$ (the standard Schnorr response)"],correctIndex:3,difficulty:"medium",explanation:"Aggregating $\\sum z_i = \\sum (k_i + s_i \\cdot \\lambda_i \\cdot c) = \\sum k_i + c \\cdot \\sum s_i \\cdot \\lambda_i = k + s \\cdot c$. This is exactly the standard Schnorr response formula."},{id:3,type:"multiple-choice",question:"Why does each signature share $z_i$ reveal nothing about the secret share $s_i$?",options:["Because the random nonce share $k_i$ masks the key share contribution","Because $s_i$ is encrypted","Because $\\lambda_i$ hides the value","Because the challenge $c$ is secret"],correctIndex:0,difficulty:"hard",explanation:"The random nonce share $k_i$ acts as a one-time pad, masking the contribution $s_i \\cdot \\lambda_i \\cdot c$. An observer seeing $z_i$ cannot extract $s_i$ without knowing $k_i$."},{id:4,type:"multiple-choice",question:"In the formula $z_i = k_i + s_i \\cdot \\lambda_i \\cdot c$, which values does participant $i$ NOT know?",options:["The challenge $c$","Other participants' shares $s_j$ and $k_j$","Their own Lagrange coefficient $\\lambda_i$","The message being signed"],correctIndex:1,difficulty:"easy",explanation:"Each participant knows their own values ($s_i$, $k_i$, $\\lambda_i$) and public values ($c$, message). They do NOT know other participants' secret shares $s_j$ or nonce shares $k_j$."},{id:5,type:"multiple-choice",question:"Given $k_1 = 100$, $s_1 = 42$, $\\lambda_1 = 3$, $c = 5$, what is the signature share $z_1$?",options:["$247$","$630$","$730$","$100$"],correctIndex:2,difficulty:"medium",explanation:"$z_1 = k_1 + s_1 \\cdot \\lambda_1 \\cdot c = 100 + 42 \\cdot 3 \\cdot 5 = 100 + 630 = 730$."}],v=[{id:1,type:"multiple-choice",question:"Which of the following is NOT a property that FROST achieves simultaneously?",options:["No secret reconstruction during signing","Non-interactive nonce generation","Requires all $n$ participants to sign","Signatures indistinguishable from single-party Schnorr"],correctIndex:2,difficulty:"easy",explanation:"FROST achieves threshold flexibility where any $t$ of $n$ can sign, NOT requiring all $n$ participants. This is one of its key advantages over simpler additive schemes."},{id:2,type:"multiple-choice",question:"In the naive (insecure) approach to threshold signing, what security vulnerability exists?",options:["The signature is too large","The verification fails","The nonces cannot be generated","The secret $s$ is temporarily exposed when shares are reconstructed"],correctIndex:3,difficulty:"medium",explanation:"In naive threshold signing, shares are collected and reconstructed to compute $s$, then $z = k + s \\cdot c$. This briefly exposes the full secret at the reconstruction point, creating a single point of failure."},{id:3,type:"multiple-choice",question:"What historical cryptographic techniques does FROST build upon?",options:["Shamir secret sharing, Schnorr signatures, and Feldman VSS","Only Shamir secret sharing from 1979","Only Schnorr signatures from 1989","Only RSA encryption"],correctIndex:0,difficulty:"medium",explanation:"FROST synthesizes multiple foundational techniques: Shamir secret sharing (1979), Schnorr signatures (1989), Feldman verifiable secret sharing (1987), and modern threshold signature research."},{id:4,type:"multiple-choice",question:"Why can different signing sets (e.g., $\\{1,2,3\\}$ vs $\\{1,3,5\\}$) all produce valid signatures for the same public key?",options:["Because the public key changes for each signing set","Because Lagrange coefficients adjust the weighting so any $t$ shares reconstruct $s$","Because the signatures are different for each set","Because the nonces are shared between sets"],correctIndex:1,difficulty:"hard",explanation:"Different signing sets use different Lagrange coefficients $\\lambda_i$, but these coefficients always weight the shares correctly so that $\\sum s_i \\cdot \\lambda_i = s$ regardless of which $t$ participants are involved."},{id:5,type:"multiple-choice",question:"What remaining security challenge does FROST need to address beyond share conversion?",options:["Making signatures smaller","Choosing better random numbers","Preventing malicious manipulation across parallel signing sessions (Drijvers attack)","Speeding up hash computations"],correctIndex:2,difficulty:"hard",explanation:"Share conversion solves the mathematical problem of combining different share types, but a malicious participant could still manipulate nonces across parallel sessions. FROST addresses this with its binding mechanism."}],_=[{id:1,type:"multiple-choice",question:"What mathematical technique does the Drijvers attack exploit to forge signatures?",options:["Brute force key search","Hash collision attacks","Factoring large primes","Wagner's generalized birthday algorithm (k-tree algorithm)"],correctIndex:3,difficulty:"medium",explanation:"The Drijvers attack uses Wagner's k-tree algorithm to solve a k-sum problem, finding linear combinations of challenges across parallel signing sessions that can be used to forge a signature."},{id:2,type:"multiple-choice",question:"Approximately how many operations does the Drijvers attack require using Wagner's algorithm?",options:["$2^{256}$ operations (infeasible)","$2^{128}$ operations","$\\approx 2^{32}$ operations (feasible)","$2^{16}$ operations"],correctIndex:2,difficulty:"hard",explanation:"Wagner's algorithm reduces the complexity from the naive $2^{256}$ to approximately $2^{32}$ operations, which is feasible with modern hardware in minutes to hours."},{id:3,type:"multiple-choice",question:"What is a prerequisite for the Drijvers attack to succeed?",options:["The adversary must have access to multiple parallel signing sessions","The adversary must control all participants","The adversary must know the secret key","The adversary must break the hash function"],correctIndex:0,difficulty:"medium",explanation:"The Drijvers attack requires multiple parallel signing sessions to be active simultaneously. The adversary opens many sessions with honest participants and combines information across them."},{id:4,type:"multiple-choice",question:"Which property of Schnorr signatures does the Drijvers attack exploit?",options:["The hash function is collision-resistant","The linear algebraic structure: $z_j = k_j + s \\cdot c_j$","The signature size is fixed","The use of elliptic curves"],correctIndex:1,difficulty:"hard",explanation:"The attack exploits the linear structure $z_j = k_j + s \\cdot c_j$. By manipulating contributions across sessions, the adversary can construct $\\sum z_j$ that corresponds to a forged challenge $c^*$."},{id:5,type:"multiple-choice",question:"Before FROST, what difficult choice did threshold signature schemes face?",options:["Between security and signature size","Between using elliptic curves and RSA","Between allowing parallelism (fast but vulnerable) and sequential-only (secure but slow)","Between public and private verification"],correctIndex:2,difficulty:"medium",explanation:"Pre-FROST schemes had to choose: allow parallel sessions (practical for high throughput) and be vulnerable to Drijvers attack, or require sequential signing (secure but extremely slow)."}],x=[{id:1,type:"multiple-choice",question:"Why does limiting parallelism (sequential signing only) fail as a solution to the Drijvers attack?",options:["It makes signatures larger","It requires more participants","It breaks the mathematical security","It defeats the purpose of threshold signatures for high-throughput applications"],correctIndex:3,difficulty:"easy",explanation:"Sequential-only signing would reduce throughput from thousands of signatures per second to about 10 (network latency dominated), making it impractical for institutional custody, exchanges, and Lightning nodes."},{id:2,type:"multiple-choice",question:"What is wrong with requiring message pre-commitment as a defense against Drijvers attack?",options:["It reduces flexibility (message must be known early) and doesn't fully prevent the attack","It doubles the signature size","It requires more computational power","It breaks Schnorr verification"],correctIndex:0,difficulty:"medium",explanation:"Message pre-commitment reduces flexibility (e.g., Bitcoin transactions may need last-minute fee adjustments) and only shifts the attack window rather than eliminating it entirely."},{id:3,type:"multiple-choice",question:'Why does an "all-or-nothing abort" protocol fail as a solution?',options:["It makes signatures invalid","It creates DoS vulnerability and cannot identify the misbehaving party","It requires too much storage","It breaks the threshold property"],correctIndex:1,difficulty:"medium",explanation:"All-or-nothing abort allows one malicious party to stop all signing (denial of service), provides no accountability to identify the bad actor, and the attack may succeed before detection."},{id:4,type:"multiple-choice",question:"What is the common thread in why all naive solutions fail?",options:["They all require too much computation","They all break the signature format","They try to restrict the adversary without binding responses to session state","They all require more participants"],correctIndex:2,difficulty:"hard",explanation:"All naive solutions try to limit what the adversary can do. The key insight is that rather than restricting capabilities, we should make it impossible to benefit from parallel sessions by cryptographically binding each response to its context."},{id:5,type:"multiple-choice",question:"What are the four requirements for a real solution to the Drijvers attack?",options:["Speed, size, simplicity, security","Sequential only, pre-commitment, abort protocol, larger threshold","More participants, larger keys, longer signatures, faster hashing","Parallel sessions, no message pre-commitment, graceful degradation, mathematical security reduction"],correctIndex:3,difficulty:"hard",explanation:"A real solution must: support parallel sessions for throughput, allow late message selection, detect misbehavior without global abort, and have provable security reduction to discrete log."}],w=[{id:1,type:"multiple-choice",question:"What is the formula for the binding value $\\rho_i$ in FROST?",options:["$\\rho_i = H_1(i, m, B)$","$\\rho_i = H_1(m)$","$\\rho_i = H_1(s_i, k_i)$","$\\rho_i = H_1(Y)$"],correctIndex:0,difficulty:"easy",explanation:"The binding value is $\\rho_i = H_1(i, m, B)$ where $i$ is the participant index, $m$ is the message, and $B$ is the list of all commitments for this signing session."},{id:2,type:"multiple-choice",question:"In the binding value formula, what does $B$ represent?",options:["The Bitcoin address","The list of all commitment pairs: $[(1, D_1, E_1), (2, D_2, E_2), ...]$","The block hash","The balance of the wallet"],correctIndex:1,difficulty:"medium",explanation:"$B$ is the commitment list containing all participants' commitment pairs $(D_i, E_i)$ along with their indices. This binds each response to the specific set of commitments in this session."},{id:3,type:"multiple-choice",question:"Why are two commitments $(D_i, E_i)$ needed per participant instead of one?",options:["To make the signature larger","To use more storage","To enable the binding formula $R_i = D_i + [\\rho_i]E_i$ with session-specific flexibility","To require more computation"],correctIndex:2,difficulty:"hard",explanation:"The dual commitment structure allows computing $R_i = D_i + [\\rho_i]E_i$, where the binding value $\\rho_i$ (unknown at commitment time) scales $E_i$. A single commitment wouldn't provide this flexibility."},{id:4,type:"multiple-choice",question:"What happens to all $\\rho_i$ values if any single commitment $D_j$ or $E_j$ changes?",options:["Only $\\rho_j$ changes","Only the coordinator's $\\rho$ changes","No $\\rho_i$ values change","All $\\rho_i$ values change because they all depend on $B$"],correctIndex:3,difficulty:"medium",explanation:"All binding values $\\rho_i = H_1(i, m, B)$ depend on the full commitment list $B$. Changing any commitment changes $B$, which changes the hash output for ALL participants."},{id:5,type:"multiple-choice",question:"What is the formula for the group commitment $R$ using individual binding values?",options:["$R = \\sum_{i \\in S} (D_i + [\\rho_i]E_i)$","$R = \\sum_{i \\in S} D_i$","$R = \\prod_{i \\in S} D_i \\cdot E_i$","$R = D_1 \\cdot E_1$"],correctIndex:0,difficulty:"medium",explanation:"The group commitment is $R = \\sum_{i \\in S} R_i = \\sum_{i \\in S} (D_i + [\\rho_i]E_i)$. Each individual commitment $R_i$ incorporates both the pre-committed values and the session-specific binding."}],T=[{id:1,type:"multiple-choice",question:"What is the FROST modified nonce formula for participant $i$?",options:["$k_i = d_i$","$k_i = d_i + e_i \\cdot \\rho_i$","$k_i = d_i + e_i$","$k_i = d_i \\cdot e_i \\cdot \\rho_i$"],correctIndex:1,difficulty:"easy",explanation:"FROST uses $k_i = d_i + e_i \\cdot \\rho_i$, where $d_i$ and $e_i$ are pre-committed random values, and $\\rho_i$ is the session-specific binding value."},{id:2,type:"multiple-choice",question:"In the formula $k_i = d_i + e_i \\cdot \\rho_i$, which values are secret (never published)?",options:["Only $\\rho_i$","Only $d_i$","$d_i$ and $e_i$ (the random scalars)","All three values"],correctIndex:2,difficulty:"medium",explanation:"The scalars $d_i$ and $e_i$ are secret, stored securely after preprocessing and deleted after use. Only their commitments $D_i = [d_i]G$ and $E_i = [e_i]G$ are public."},{id:3,type:"multiple-choice",question:"What is the role of $d_i$ in the modified nonce formula?",options:["It verifies the commitment","It binds the nonce to the message","It encrypts the signature share","It provides base randomness independent of the session"],correctIndex:3,difficulty:"medium",explanation:"$d_i$ provides base randomness that ensures unpredictability even if $\\rho_i$ becomes known. It's independent of any session-specific information."},{id:4,type:"multiple-choice",question:"How is the public commitment $R_i$ verified from the secret nonce $k_i$?",options:["$R_i = [k_i]G$, which equals $D_i + [\\rho_i]E_i$","$R_i = D_i - E_i$","$R_i = [k_i]Y$","$R_i = H(k_i)$"],correctIndex:0,difficulty:"hard",explanation:"$R_i = [k_i]G = [d_i + e_i \\cdot \\rho_i]G = [d_i]G + [e_i \\cdot \\rho_i]G = D_i + [\\rho_i]E_i$. The commitment can be computed publicly from $(D_i, E_i, \\rho_i)$."},{id:5,type:"multiple-choice",question:"Why does the formula $k_i = d_i + e_i \\cdot \\rho_i$ prevent cross-session attacks?",options:["Because $d_i$ changes every session","Because $\\rho_i$ depends on ALL commitments, so changing any commitment changes all binding values","Because $e_i$ is always 1","Because the formula uses multiplication"],correctIndex:1,difficulty:"hard",explanation:"Since $\\rho_i = H_1(i, m, B)$ depends on all commitments in $B$, the adversary cannot know $\\rho_i$ until after committing to $(D_i, E_i)$. Changing commitments changes all $\\rho_i$ values unpredictably."}],k=[{id:1,type:"multiple-choice",question:"What is the complete FROST signature share formula?",options:["$z_i = k_i + s_i \\cdot c$","$z_i = d_i + s_i \\cdot c$","$z_i = d_i + e_i \\cdot \\rho_i + \\lambda_i \\cdot s_i \\cdot c$","$z_i = e_i \\cdot \\rho_i + s_i$"],correctIndex:2,difficulty:"medium",explanation:"The complete formula is $z_i = d_i + e_i \\cdot \\rho_i + \\lambda_i \\cdot s_i \\cdot c$, combining the bound nonce $(d_i + e_i \\cdot \\rho_i)$ with the weighted secret share contribution $(\\lambda_i \\cdot s_i \\cdot c)$."},{id:2,type:"multiple-choice",question:"In the formula $z_i = d_i + e_i \\cdot \\rho_i + \\lambda_i \\cdot s_i \\cdot c$, what does the term $d_i + e_i \\cdot \\rho_i$ represent?",options:["The secret key contribution","The challenge hash","The Lagrange coefficient","The bound nonce $k_i$"],correctIndex:3,difficulty:"easy",explanation:"The term $d_i + e_i \\cdot \\rho_i$ is the effective nonce $k_i$ that is bound to the session via $\\rho_i$."},{id:3,type:"multiple-choice",question:"What is the challenge $c$ in the FROST signing formula computed as?",options:["$c = H_2(R, Y, m)$","$c = H_2(m)$","$c = H_2(s, k)$","$c = H_2(\\rho_i)$"],correctIndex:0,difficulty:"medium",explanation:"The challenge is $c = H_2(R, Y, m)$ where $R$ is the group commitment, $Y$ is the group public key, and $m$ is the message. This is the standard Schnorr challenge."},{id:4,type:"multiple-choice",question:"When all signature shares $z_i$ are aggregated as $z = \\sum_{i \\in S} z_i$, the result equals:",options:["$z = k \\cdot c + s$","$z = k + s \\cdot c$ (standard Schnorr response)","$z = k - s \\cdot c$","$z = k / s \\cdot c$"],correctIndex:1,difficulty:"medium",explanation:"Expanding: $z = \\sum(d_i + e_i \\cdot \\rho_i) + c \\cdot \\sum \\lambda_i \\cdot s_i = k + s \\cdot c$, which is exactly the standard Schnorr response formula."},{id:5,type:"multiple-choice",question:`What makes FROST's signature share formula "magical" from a security perspective?`,options:["It produces smaller signatures","It uses quantum-resistant cryptography","No single party ever knows $s$ or $k$, yet the combined shares produce a valid Schnorr signature","It doesn't require a hash function"],correctIndex:2,difficulty:"hard",explanation:"The remarkable property is that the group computes $z = k + s \\cdot c$ without any participant ever reconstructing $s$ (the secret key) or $k$ (the group nonce). The secrets remain distributed throughout."}],S=[{id:1,type:"multiple-choice",question:"In FROST's binding mechanism, when must the adversary commit to $D_1, E_1$?",options:["After seeing all other commitments and the message","After the signature is complete","After computing the challenge $c$","Before seeing other participants' commitments or the binding values"],correctIndex:3,difficulty:"medium",explanation:"The adversary must publish $(D_1, E_1)$ BEFORE seeing other participants' commitments, the message, or any binding values $\\rho_i$. This is the commit-before-know constraint."},{id:2,type:"multiple-choice",question:"What happens when an adversary changes their commitment $D_1$ to $D_1'$ after seeing others?",options:["ALL binding values $\\rho_i$ for ALL participants change","No binding values change","Only their own $\\rho_1$ changes","The signature becomes invalid"],correctIndex:0,difficulty:"hard",explanation:"Since all $\\rho_i = H_1(i, m, B)$ depend on the commitment list $B$, changing any commitment changes $B$, which changes ALL binding values for ALL participants unpredictably."},{id:3,type:"multiple-choice",question:"Why does binding break the linear algebra required by Wagner's algorithm?",options:["It makes the math slower","Sessions become entangled - changing anything in one session changes everything unpredictably","It uses a different hash function","It increases the signature size"],correctIndex:1,difficulty:"hard",explanation:"Wagner's algorithm needs independent challenges across sessions that can be linearly combined. Binding makes sessions entangled: any change propagates unpredictably through the hash function."},{id:4,type:"multiple-choice",question:'In the "binding cascade," what is the correct chain of effects when an adversary changes a commitment?',options:["Challenge changes directly","Only the final signature changes","Commitment change -> $B$ changes -> all $\\rho_i$ change -> all $R_i$ change -> $R$ changes -> $c$ changes unpredictably","The secret key is revealed"],correctIndex:2,difficulty:"hard",explanation:"The cascade: (1) Commitment changes (2) $B$ changes (3) ALL $\\rho_i$ change (4) ALL $R_i = D_i + [\\rho_i]E_i$ change (5) $R = \\sum R_i$ changes (6) $c = H_2(R, Y, m)$ changes unpredictably."},{id:5,type:"multiple-choice",question:"What security level does FROST achieve with binding, compared to without?",options:["Same security level ($2^{32}$ operations)","Worse security but faster signing","Slightly better ($2^{64}$ operations)","From $\\approx 2^{32}$ (attackable) to $\\approx 2^{256}$ (discrete log security)"],correctIndex:3,difficulty:"medium",explanation:"Without binding, Drijvers attack requires only $\\approx 2^{32}$ operations. With binding, security is reduced to the discrete log problem, requiring $\\approx 2^{256}$ operations - cryptographically secure."}],q=[{id:1,type:"multiple-choice",question:"What does EUF-CMA security mean for a signature scheme?",options:["Existential Unforgeability under Chosen Message Attack - adversary cannot forge on any new message even after seeing signatures on chosen messages","Signatures can be forged with some probability","Signatures are encrypted","Messages must be fixed in advance"],correctIndex:0,difficulty:"hard",explanation:"EUF-CMA means an adversary who can request signatures on any messages of their choice still cannot produce a valid signature on a message that was never signed."},{id:2,type:"multiple-choice",question:"FROST's security reduction proves that if an adversary can forge with probability $\\varepsilon$, then:",options:["The discrete log problem is easy","The discrete log can be solved with probability related to $\\varepsilon^2$","The hash function is broken","The signature is invalid"],correctIndex:1,difficulty:"hard",explanation:'The reduction shows: if FROST can be broken with probability $\\varepsilon$, then discrete log can be solved with probability $\\geq \\varepsilon^2 / (2n_H + (\\pi+1)n_P + 1)$. This is a "security reduction."'},{id:3,type:"multiple-choice",question:"What proof technique is used in FROST's security reduction?",options:["Direct proof","Proof by contradiction","Forking lemma (run adversary twice with different random oracle answers)","Induction"],correctIndex:2,difficulty:"hard",explanation:'The forking lemma runs the adversary twice, "forking" at a critical point with different random oracle outputs. If both runs produce forgeries, the discrete log can be extracted by comparing them.'},{id:4,type:"multiple-choice",question:"Why does FROST's security bound have $\\varepsilon^2$ (quadratic loss) in the numerator?",options:["Because FROST uses two commitments","Because the threshold is $t=2$","Because there are two hash functions","Because the forking lemma requires both forks to succeed, probability $\\approx \\varepsilon \\cdot \\varepsilon$"],correctIndex:3,difficulty:"hard",explanation:"The forking lemma requires BOTH forked executions to produce forgeries. If each succeeds with probability $\\varepsilon$, both succeed with probability approximately $\\varepsilon^2$."},{id:5,type:"multiple-choice",question:"In FROST's security bound, what does $n_H$ represent?",options:["The number of hash queries the adversary makes","The number of honest participants","The hash output length","The number of signatures produced"],correctIndex:0,difficulty:"medium",explanation:"$n_H$ is the number of queries the adversary makes to the hash oracles $H_1$ and $H_2$. More queries give the adversary more chances to find useful values, slightly weakening the bound."}],R=[{id:1,type:"multiple-choice",question:"In a 3-of-5 FROST scheme where an adversary controls participants 1 and 2, can they forge a signature without honest cooperation?",options:["Yes, they have enough shares","No, they control fewer than $t=3$ shares needed","Yes, if they work fast enough","It depends on the message"],correctIndex:1,difficulty:"easy",explanation:"With threshold $t=3$, the adversary needs 3 shares to sign. Controlling only 2 participants (below threshold), they cannot forge without cooperation from at least one honest party."},{id:2,type:"multiple-choice",question:"Why can't an adversary extract the secret $s$ from having 2 shares of a degree-2 polynomial?",options:["The shares are encrypted","The shares are too large","2 equations with 3 unknowns - every possible secret is consistent with the known points","The polynomial is hidden"],correctIndex:2,difficulty:"hard",explanation:"A degree-2 polynomial has 3 coefficients ($a_0, a_1, a_2$). With only 2 points, we have 2 equations but 3 unknowns. Information-theoretically, the secret $s = a_0$ could be any value."},{id:3,type:"multiple-choice",question:"Why can't an adversary extract honest participant $i$'s secret share $s_i$ from their signature share $z_i$?",options:["The hash function hides it","The signature share is encrypted","The Lagrange coefficient is secret","The random nonce contribution $k_i = d_i + e_i \\cdot \\rho_i$ masks the key share"],correctIndex:3,difficulty:"medium",explanation:"In $z_i = d_i + e_i \\cdot \\rho_i + \\lambda_i \\cdot s_i \\cdot c$, the random nonce contribution acts as a one-time pad. Without knowing $d_i$ and $e_i$, the adversary cannot extract $s_i$."},{id:4,type:"multiple-choice",question:"If an adversary submits an invalid signature share, what happens?",options:["The share is detected via verification equation $[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$","The signature still works","All participants must restart","The adversary gains information"],correctIndex:0,difficulty:"medium",explanation:"Invalid shares are detected using the verification equation $[z_i]G \\stackrel{?}{=} R_i + [\\lambda_i \\cdot c]Y_i$. The adversary is identified and their share rejected."},{id:5,type:"multiple-choice",question:"In a 3-of-5 scheme, if the adversary controls 2 participants, what CAN they do?",options:["Forge signatures","Refuse to participate (denial of service), but honest parties 3,4,5 can still sign","Extract the group secret","Decrypt all messages"],correctIndex:1,difficulty:"medium",explanation:"The adversary can refuse to participate or submit invalid shares (detected). However, honest parties 3, 4, 5 form a valid signing set of size 3 and can sign without the adversary."}],I=[{id:1,type:"multiple-choice",question:"What are the three main phases of the FROST protocol?",options:["Setup, Sign, Verify","Commit, Challenge, Response","Key Generation (DKG), Preprocessing, Signing","Share, Reconstruct, Aggregate"],correctIndex:2,difficulty:"easy",explanation:"FROST operates in three phases: (1) Key Generation (DKG) - done once to create shares, (2) Preprocessing - done in batches to prepare commitments, (3) Signing - fast, single-round per signature."},{id:2,type:"multiple-choice",question:"How many communication rounds does FROST signing require (with preprocessing done in advance)?",options:["Three rounds","Two rounds","Zero rounds (non-interactive)","One round (single-round signing)"],correctIndex:3,difficulty:"easy",explanation:"FROST's headline feature is single-round signing: coordinator sends $(m, B)$, each signer responds with $z_i$. This is possible because preprocessing prepares commitments in advance."},{id:3,type:"multiple-choice",question:"What does the preprocessing phase produce?",options:["Commitment pairs $(D_i, E_i)$ and private nonces $(d_i, e_i)$","The group public key $Y$","The final signature","The challenge hash $c$"],correctIndex:0,difficulty:"medium",explanation:"Preprocessing generates $\\pi$ commitment pairs $(D_i, E_i)$ (public) along with their corresponding secret nonces $(d_i, e_i)$. Each pair is used exactly once for signing."},{id:4,type:"multiple-choice",question:"After DKG completes, what does each participant $P_i$ have?",options:["Only the group public key $Y$","Secret share $s_i$, verification share $Y_i$, and group public key $Y$","The complete secret $s$","All other participants' shares"],correctIndex:1,difficulty:"medium",explanation:"Each participant has: their secret share $s_i$ (private), their verification share $Y_i = [s_i]G$ (public), and the group public key $Y = [s]G$ (public). No one knows the full secret $s$."},{id:5,type:"multiple-choice",question:"What is the parameter $\\pi$ in FROST preprocessing?",options:["The mathematical constant 3.14159...","The number of participants","The preprocessing batch size (number of commitment pairs per batch)","The threshold value"],correctIndex:2,difficulty:"medium",explanation:"$\\pi$ is the preprocessing batch size - the number of commitment pairs $(D_i, E_i)$ generated in each preprocessing phase. Larger $\\pi$ means more signatures before needing to re-preprocess."}],F=[{id:1,type:"multiple-choice",question:"In FROST DKG, what does each participant $P_i$ generate in Round 1?",options:["Only a random number","Other participants' shares","The final signature","A random polynomial $f_i(x)$, Feldman commitments, and a proof of knowledge"],correctIndex:3,difficulty:"medium",explanation:"In Round 1, each $P_i$ samples a degree $t-1$ polynomial $f_i(x)$, computes Feldman commitments to coefficients $([a_{i,0}]G, [a_{i,1}]G, ...)$, and generates a Schnorr proof of knowledge for $a_{i,0}$."},{id:2,type:"multiple-choice",question:"What are Feldman commitments used for in FROST DKG?",options:["To allow verification that received shares are consistent with committed coefficients","To encrypt the shares","To hide the public key","To speed up computation"],correctIndex:0,difficulty:"hard",explanation:"Feldman commitments $C_i = ([a_{i,0}]G, ..., [a_{i,t-1}]G)$ allow recipients to verify shares: $[s_{j,i}]G \\stackrel{?}{=} \\sum_k [i^k]C_{j,k}$ without revealing the polynomial coefficients."},{id:3,type:"multiple-choice",question:"How is the group secret $s$ computed in FROST DKG?",options:["One participant chooses it","$s = \\sum_{i=1}^n a_{i,0}$ (sum of all participants' constant terms)","$s = a_{1,0}$ (first participant's term)","$s$ is randomly generated after DKG"],correctIndex:1,difficulty:"hard",explanation:"The group secret is $s = f(0) = \\sum_i f_i(0) = \\sum_i a_{i,0}$. Each participant contributes their constant term, so no single party knows $s$ (only their own contribution)."},{id:4,type:"multiple-choice",question:"Why does FROST DKG require a proof of knowledge for $a_{i,0}$?",options:["To make the protocol faster","To encrypt the shares","To ensure each participant actually knows their contribution and isn't just copying others","To reduce storage requirements"],correctIndex:2,difficulty:"hard",explanation:"The proof of knowledge (a Schnorr proof) ensures each participant actually knows their secret contribution $a_{i,0}$. Without this, an adversary could copy commitments from others."},{id:5,type:"multiple-choice",question:"How is each participant's final share $s_i$ computed after DKG Round 2?",options:["$s_i = f_1(i)$","$s_i$ is randomly assigned","$s_i = s / n$","$s_i = \\sum_{j=1}^n s_{j,i} = \\sum_{j=1}^n f_j(i)$"],correctIndex:3,difficulty:"medium",explanation:"Each participant's share is the sum of shares received from all others: $s_i = \\sum_j f_j(i)$. This is a share of the combined polynomial $f(x) = \\sum_j f_j(x)$."}],O=[{id:1,type:"multiple-choice",question:"What does each participant generate during FROST preprocessing?",options:["$\\pi$ commitment pairs $(D_{i,j}, E_{i,j})$ with corresponding secret nonces $(d_{i,j}, e_{i,j})$","A new secret share","The final signature","New Lagrange coefficients"],correctIndex:0,difficulty:"easy",explanation:"During preprocessing, each participant generates $\\pi$ pairs of random scalars $(d_{i,j}, e_{i,j})$ and their curve point commitments $(D_{i,j} = [d_{i,j}]G, E_{i,j} = [e_{i,j}]G)$."},{id:2,type:"multiple-choice",question:'Why is preprocessing called "non-interactive"?',options:["It happens automatically","Each participant generates their commitments independently without coordination","No computation is required","It uses a trusted setup"],correctIndex:1,difficulty:"medium",explanation:"Preprocessing is non-interactive because each participant independently generates and publishes their commitments. No communication or coordination between participants is required."},{id:3,type:"multiple-choice",question:"What happens if a commitment pair $(d_i, e_i)$ is reused for multiple signatures?",options:["The signatures are more efficient","Nothing - reuse is safe","Catastrophic key extraction attack becomes possible (similar to nonce reuse)","The signatures are slightly larger"],correctIndex:2,difficulty:"hard",explanation:"Reusing nonces enables key extraction. If the same $(d_i, e_i)$ is used with different messages/sessions, an attacker can solve for the secret share $s_i$, similar to the classic Schnorr nonce reuse attack."},{id:4,type:"multiple-choice",question:"What must happen to the secret nonces $(d_i, e_i)$ immediately after they are used for signing?",options:["They should be backed up","They should be shared with other participants","They should be stored for auditing","They must be securely deleted and never reused"],correctIndex:3,difficulty:"medium",explanation:"After use, the secret nonces $(d_i, e_i)$ must be immediately and securely deleted to prevent accidental reuse. This is a critical security requirement."},{id:5,type:"multiple-choice",question:"For a batch size $\\pi = 1000$, how much storage is approximately needed per participant for the private nonces?",options:["~64 KB (1000 pairs of 32-byte scalars)","~1 KB","~1 MB","~1 GB"],correctIndex:0,difficulty:"medium",explanation:"1000 pairs of 256-bit (32-byte) scalars requires $1000 \\times 2 \\times 32 = 64,000$ bytes $\\approx$ 64 KB. This enables 1000 signatures before needing new preprocessing."}],z=[{id:1,type:"multiple-choice",question:"What does the coordinator send to initiate a FROST signing round?",options:["Only the message $m$","The message $m$ and commitment list $B = [(i, D_i, E_i) : i \\in S]$","The secret key","The final signature"],correctIndex:1,difficulty:"easy",explanation:"The coordinator sends $(m, B)$ where $m$ is the message to sign and $B$ is the list of commitments from all participants in the signing set $S$."},{id:2,type:"multiple-choice",question:"In what order does each signer compute values during FROST signing?",options:["Challenge, binding value, signature share","Signature share, then verification","Binding value $\\rho_i$, commitment $R_i$, group commitment $R$, challenge $c$, signature share $z_i$","Random number, then hash"],correctIndex:2,difficulty:"medium",explanation:"Each signer computes: (1) binding $\\rho_i = H_1(i, m, B)$, (2) own commitment $R_i = D_i + [\\rho_i]E_i$, (3) group commitment $R = \\sum R_j$, (4) challenge $c = H_2(R, Y, m)$, (5) share $z_i$."},{id:3,type:"multiple-choice",question:"What is the verification equation the coordinator uses to check each signature share $z_i$?",options:["$[z_i]G = Y_i$","$[z_i]G = R$","$z_i = s_i$","$[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$"],correctIndex:3,difficulty:"hard",explanation:"The coordinator verifies $[z_i]G \\stackrel{?}{=} R_i + [\\lambda_i \\cdot c]Y_i$. This works because $z_i = k_i + \\lambda_i \\cdot s_i \\cdot c$ and $R_i = [k_i]G$, $Y_i = [s_i]G$."},{id:4,type:"multiple-choice",question:"After all valid shares $z_i$ are collected, how is the final signature response $z$ computed?",options:["$z = \\sum_{i \\in S} z_i$","$z = z_1 \\cdot z_2 \\cdot ... \\cdot z_t$","$z = \\max(z_1, z_2, ..., z_t)$","$z = z_1 / z_2$"],correctIndex:0,difficulty:"easy",explanation:"The final response is simply the sum of all signature shares: $z = \\sum_{i \\in S} z_i$. This aggregation produces the valid Schnorr response."},{id:5,type:"multiple-choice",question:"What is the final output of the FROST signing protocol?",options:["Just the response $z$","The signature pair $\\sigma = (R, z)$","All individual shares $z_1, z_2, ...$","The secret key $s$"],correctIndex:1,difficulty:"easy",explanation:"The output is a standard Schnorr signature $\\sigma = (R, z)$ where $R$ is the group commitment and $z$ is the aggregated response. This verifies against the group public key $Y$."}],W=[{id:1,type:"multiple-choice",question:"What is the standard Schnorr verification equation that FROST signatures satisfy?",options:["$[z]G = R - [c]Y$","$[z]G = R \\cdot [c]Y$","$[z]G = R + [c]Y$","$z = R + c \\cdot Y$"],correctIndex:2,difficulty:"easy",explanation:"FROST signatures satisfy the standard Schnorr verification: $[z]G = R + [c]Y$ where $c = H_2(R, Y, m)$. This is identical to single-party Schnorr verification."},{id:2,type:"multiple-choice",question:"Can a verifier distinguish between a FROST threshold signature and a single-party Schnorr signature?",options:["Yes, FROST signatures are larger","Yes, FROST signatures use different verification","Yes, FROST signatures include the threshold $t$","No, they are mathematically identical and indistinguishable"],correctIndex:3,difficulty:"medium",explanation:"FROST signatures are standard Schnorr signatures - same format (64 bytes), same verification algorithm. A verifier cannot determine if one signer or multiple signers produced it."},{id:3,type:"multiple-choice",question:"What information remains hidden from an observer when verifying a FROST signature?",options:["The threshold $t$, total participants $n$, and which participants signed","Only the message","Only the public key","Nothing - all information is public"],correctIndex:0,difficulty:"medium",explanation:"An observer sees only $(Y, R, z, m)$. They cannot determine the threshold $t$, total participants $n$, or which specific participants cooperated to produce the signature."},{id:4,type:"multiple-choice",question:"How does FROST signature verification cost compare to single-party Schnorr verification?",options:["FROST is more expensive (more scalar multiplications)","Identical cost - same operations: 1 hash, 2 scalar multiplications, 1 addition, 1 comparison","FROST is less expensive (fewer operations)","FROST requires exponentially more computation"],correctIndex:1,difficulty:"medium",explanation:"Verification cost is identical: compute $c = H_2(R, Y, m)$, compute $[z]G$ and $R + [c]Y$, compare. No additional operations needed for threshold signatures."},{id:5,type:"multiple-choice",question:"For Bitcoin transactions using FROST, what is the signature size compared to traditional k-of-n multisig?",options:["Traditional multisig is smaller","Both are the same size","FROST: 64 bytes; Traditional: ~34 + 72 bytes per signer (much larger)","FROST signatures are larger"],correctIndex:2,difficulty:"hard",explanation:"FROST produces a 64-byte signature regardless of $t$ or $n$. Traditional Bitcoin multisig adds ~34 bytes (pubkey) + ~72 bytes (signature) per signer, growing linearly with the number of signers."}],A=[{id:1,type:"multiple-choice",question:"In a 2-of-3 FROST example with signing set $S = \\{1, 2\\}$, what are the Lagrange coefficients?",options:["$\\lambda_1 = 1, \\lambda_2 = 1$","$\\lambda_1 = 0.5, \\lambda_2 = 0.5$","$\\lambda_1 = 3, \\lambda_2 = -3$","$\\lambda_1 = 2, \\lambda_2 = -1$"],correctIndex:3,difficulty:"medium",explanation:"For $S = \\{1, 2\\}$: $\\lambda_1 = \\frac{0-2}{1-2} = \\frac{-2}{-1} = 2$ and $\\lambda_2 = \\frac{0-1}{2-1} = \\frac{-1}{1} = -1$."},{id:2,type:"multiple-choice",question:"Given $d_1 = 100$, $e_1 = 50$, $\\rho_1 = 7$, what is the effective nonce $k_1$?",options:["$k_1 = 450$","$k_1 = 350$","$k_1 = 150$","$k_1 = 700$"],correctIndex:0,difficulty:"easy",explanation:"$k_1 = d_1 + e_1 \\cdot \\rho_1 = 100 + 50 \\cdot 7 = 100 + 350 = 450$."},{id:3,type:"multiple-choice",question:"In the example with $s_1 = 42$, $s_2 = 67$ and Lagrange coefficients $\\lambda_1 = 2$, $\\lambda_2 = -1$, what is the reconstructed secret $s$?",options:["$s = 109$","$s = 17$","$s = -25$","$s = 84$"],correctIndex:1,difficulty:"medium",explanation:"$s = \\lambda_1 \\cdot s_1 + \\lambda_2 \\cdot s_2 = 2 \\cdot 42 + (-1) \\cdot 67 = 84 - 67 = 17$."},{id:4,type:"multiple-choice",question:"With $k = 1475$, $s = 17$, and $c = 13$, what should the aggregated response $z$ equal?",options:["$z = 221$","$z = 1475$","$z = 1696$","$z = 1254$"],correctIndex:2,difficulty:"medium",explanation:"$z = k + s \\cdot c = 1475 + 17 \\cdot 13 = 1475 + 221 = 1696$."},{id:5,type:"multiple-choice",question:"After computing signature shares, what critical step must each signer perform?",options:["Share their secret key with others","Store the nonces for backup","Broadcast their secret share $s_i$","Securely delete their nonces $(d_i, e_i)$ - they must never be reused"],correctIndex:3,difficulty:"easy",explanation:"After computing $z_i$, each signer must securely delete $(d_i, e_i)$. Reusing nonces would enable key extraction attacks. This is a critical security requirement."}],G=[{id:1,type:"multiple-choice",question:"What does EUF-CMA stand for in the context of digital signature security?",options:["Existential Unforgeability under Chosen Message Attack","Extended Unified Framework for Cryptographic Message Authentication","Efficient Universal Forgery under Computational Message Analysis","Encrypted User Functions with Chosen Message Access"],correctIndex:0,difficulty:"medium",explanation:"EUF-CMA stands for Existential Unforgeability under Chosen Message Attack. This is the standard security model for digital signatures where an adversary cannot forge a signature on any new message even after seeing signatures on messages of their choice."},{id:2,type:"multiple-choice",question:"In the FROST security model, what is the maximum number of corrupted participants the adversary can control in a $(t, n)$ threshold scheme?",options:["Up to $n - 1$ participants","Up to $t - 1$ participants","Up to $t$ participants","Up to $n - t$ participants"],correctIndex:1,difficulty:"medium",explanation:"The adversary can corrupt up to $t - 1$ participants. With $t$ or more corrupted parties, they could reconstruct the secret key and trivially forge signatures. The security guarantee only holds when strictly fewer than $t$ parties are compromised."},{id:3,type:"multiple-choice",question:"Which oracle does the adversary NOT have access to in the FROST security model?",options:["Signing oracle (to request signatures on chosen messages)","Random oracle (modeling hash functions)","Key extraction oracle (to directly obtain the group secret key)","Corruption oracle (to obtain shares of corrupted parties)"],correctIndex:2,difficulty:"hard",explanation:"The adversary has access to signing, random, and corruption oracles, but never has direct access to the group secret key $s$. The entire point of threshold signatures is that no single entity ever holds the complete secret key."},{id:4,type:"multiple-choice",question:"What is the primary security assumption underlying FROST's unforgeability?",options:["RSA assumption","Collision resistance of SHA-256","Learning With Errors (LWE) assumption","Discrete Logarithm Problem (DLP) hardness"],correctIndex:3,difficulty:"easy",explanation:"FROST's security relies on the hardness of the Discrete Logarithm Problem in the underlying elliptic curve group. If an adversary could compute discrete logs, they could extract the secret key from the public key $Y = [s]G$."},{id:5,type:"multiple-choice",question:"In the Random Oracle Model (ROM) used for FROST security proofs, what assumption is made about hash functions?",options:["Hash functions behave as truly random functions","Hash outputs are deterministic given the same input","Hash collisions are computationally easy to find","Hash outputs can be inverted with polynomial effort"],correctIndex:0,difficulty:"medium",explanation:"The Random Oracle Model assumes hash functions behave as ideal random functions: for each new input, the output is uniformly random and independent of all other outputs, but consistent (same input always gives same output). This is a theoretical idealization used in security proofs."}],B=[{id:1,type:"multiple-choice",question:"What is the Drijvers attack that FROST specifically prevents?",options:["An attack exploiting weak random number generation","A parallel session attack using Wagner's algorithm to forge signatures","A timing side-channel attack on scalar multiplication","A man-in-the-middle attack on the communication channel"],correctIndex:1,difficulty:"medium",explanation:"The Drijvers attack exploits parallel signing sessions using Wagner's generalized birthday algorithm. An adversary running many concurrent sessions can manipulate nonce commitments to create forgeries. FROST's binding mechanism prevents this by making each participant's contribution depend on all commitments."},{id:2,type:"multiple-choice",question:"How does FROST prevent key extraction attacks where corrupted parties try to learn the secret key?",options:["By encrypting all communication between parties","By requiring physical security for all key storage","By using Shamir secret sharing where $t-1$ shares reveal nothing about $s$","By rotating keys after every signature"],correctIndex:2,difficulty:"medium",explanation:"FROST uses Shamir's $(t, n)$ secret sharing, which has information-theoretic security: any $t-1$ or fewer shares reveal absolutely nothing about the secret $s$. Even with unbounded computational power, corrupted parties cannot extract the key from their shares alone."},{id:3,type:"multiple-choice",question:"What is the ROS (Random inhomogeneities in a Overdetermined Solvable system) attack?",options:["An attack on the random number generator","A denial-of-service attack on the coordinator","An attack exploiting network latency variations","An algebraic attack that solves systems of linear equations to forge signatures"],correctIndex:3,difficulty:"hard",explanation:"The ROS attack exploits schemes where an adversary can collect enough linear equations relating secret values. By solving this overdetermined system, they can forge signatures. FROST's binding coefficients $\\rho_i$ make the system non-linear and unsolvable."},{id:4,type:"multiple-choice",question:"Why can't a malicious participant forge a signature share for another honest participant?",options:["Because signature shares can be verified against public verification keys $Y_i$","Because all communication is encrypted end-to-end","Because the coordinator checks IP addresses of all participants","Because shares expire after a fixed time period"],correctIndex:0,difficulty:"medium",explanation:"Each participant $i$ has a public verification key $Y_i = [s_i]G$. Any signature share $z_i$ can be verified using the equation $[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$. A forged share would fail this verification check."},{id:5,type:"multiple-choice",question:"How does FROST handle a participant who submits an invalid signature share?",options:["The protocol automatically corrects the invalid share","The coordinator identifies and excludes the misbehaving party, aborting the session","Other participants vote on whether to accept the share","The invalid share is averaged with valid shares"],correctIndex:1,difficulty:"easy",explanation:'FROST uses an "abort on misbehavior" model. When share verification fails, the coordinator identifies the misbehaving party and aborts the signing session. The identified party can be excluded from future sessions, providing accountability.'}],L=[{id:1,type:"multiple-choice",question:"What type of proof technique does FROST use to establish its security?",options:["Direct proof showing no adversary can forge","Information-theoretic proof with no computational assumptions","Reduction to the hardness of the Discrete Logarithm Problem","Experimental verification through extensive testing"],correctIndex:2,difficulty:"medium",explanation:"FROST uses a reduction proof: if an adversary $\\mathcal{A}$ can forge FROST signatures, we construct an algorithm $\\mathcal{B}$ that uses $\\mathcal{A}$ to solve the Discrete Logarithm Problem. Since DLP is hard, no efficient forger can exist."},{id:2,type:"multiple-choice",question:'In the security reduction, what role does the "simulator" play?',options:["It generates random test cases for the adversary","It encrypts communication between parties","It measures the running time of the adversary","It emulates honest parties and oracles for the adversary while using adversary's forgery to solve DLP"],correctIndex:3,difficulty:"hard",explanation:"The simulator $\\mathcal{B}$ receives a DLP challenge $Y = [x]G$ (find $x$). It embeds this challenge into a simulated FROST instance, answers all adversary queries consistently, and if the adversary produces a forgery, extracts the discrete log $x$ from it."},{id:3,type:"multiple-choice",question:'What does "tight security reduction" mean?',options:["The adversary's success probability is preserved (nearly) exactly in the reduction","The reduction uses minimal memory","The proof applies to all possible parameter choices","The reduction completes in constant time"],correctIndex:0,difficulty:"hard",explanation:"A tight reduction means $\\varepsilon_{\\text{FROST}} \\approx \\varepsilon_{\\text{DLP}}$ with minimal loss. If the reduction is loose, even a weak forger might not help solve DLP efficiently. Tight reductions provide stronger concrete security guarantees."},{id:4,type:"multiple-choice",question:"Why is the Random Oracle Model (ROM) necessary for FROST's security proof?",options:["Real hash functions are too slow for threshold signatures","It allows the simulator to program hash outputs to embed the DLP challenge","It makes the protocol more efficient","It eliminates the need for secure communication channels"],correctIndex:1,difficulty:"medium",explanation:`In the ROM, the simulator controls the random oracle (hash function). This allows it to "program" specific outputs when needed to embed the DLP challenge consistently. Without this control, the simulator couldn't set up the reduction properly.`},{id:5,type:"multiple-choice",question:"What is the main proof obligation for establishing FROST's EUF-CMA security?",options:["Showing the protocol completes in polynomial time","Showing all participants receive the same signature","Showing any PPT adversary has negligible probability of outputting a valid forgery","Showing the coordinator cannot learn the secret key"],correctIndex:2,difficulty:"medium",explanation:"EUF-CMA security requires proving that any probabilistic polynomial-time (PPT) adversary $\\mathcal{A}$ has at most negligible probability of producing a valid signature $(R^*, z^*)$ on any message $m^*$ not previously signed, even after adaptive queries."}],C=[{id:1,type:"multiple-choice",question:"What is the Forking Lemma used for in Schnorr-based signature security proofs?",options:["To prove signatures are computed correctly","To optimize the signature verification algorithm","To verify that nonces are generated randomly","To extract the discrete logarithm from an adversary who can forge signatures"],correctIndex:3,difficulty:"medium",explanation:`The Forking Lemma shows that if an adversary can produce one forgery with non-negligible probability, by "rewinding" and giving different random oracle responses, we can obtain two forgeries with the same $R$ but different challenges $c$ and $c'$. From these, we extract the discrete log.`},{id:2,type:"multiple-choice",question:"Given two valid forgeries $(R, z, c)$ and $(R, z', c')$ with the same commitment $R$ but $c \\neq c'$, how is the secret key extracted?",options:["$s = (z - z') / (c - c')$","$s = z \\cdot z'$","$s = z + z'$","$s = (z - z') \\cdot (c - c')$"],correctIndex:0,difficulty:"hard",explanation:"From $z = k + s \\cdot c$ and $z' = k + s \\cdot c'$, subtracting gives $z - z' = s(c - c')$. Thus $s = (z - z')/(c - c')$. This is the key extraction at the heart of the security proof."},{id:3,type:"multiple-choice",question:'Why is "rewinding" the adversary necessary in the Forking Lemma?',options:["To check if the adversary is running in polynomial time","To obtain a second forgery with a different challenge value","To verify the adversary's randomness source","To reduce memory usage during the proof"],correctIndex:1,difficulty:"medium",explanation:`Rewinding runs the adversary again with the same random tape but different random oracle responses after the "fork point." This produces a second forgery with the same commitment $R$ (same nonce $k$) but a different challenge $c'$, enabling key extraction.`},{id:4,type:"multiple-choice",question:"What probability loss factor does the basic Forking Lemma introduce?",options:["No loss - success probability is preserved exactly","A factor of $2^{-128}$ regardless of parameters","A factor of roughly $1/q_H$ where $q_H$ is the number of hash queries","A factor proportional to the signature size"],correctIndex:2,difficulty:"hard",explanation:"The Forking Lemma introduces a success probability loss of roughly $\\varepsilon^2 / q_H$ where $\\varepsilon$ is the forgery probability and $q_H$ is the number of random oracle queries. This affects concrete security bounds."},{id:5,type:"multiple-choice",question:"What makes the forking technique work specifically for Schnorr-type signatures?",options:["The use of RSA moduli","The fixed signature length","The use of symmetric encryption","The linear relationship $z = k + s \\cdot c$ in the response"],correctIndex:3,difficulty:"medium",explanation:"The forking technique exploits Schnorr's linear response structure $z = k + s \\cdot c$. With two equations sharing the same $k$ but different $c$ values, we have two equations in two unknowns ($k$ and $s$) which can be solved algebraically."}],D=[{id:1,type:"multiple-choice",question:"What form does the concrete security bound for FROST take?",options:["$\\varepsilon_{\\text{FROST}} \\leq \\varepsilon_{\\text{DLP}}^2 / (2n_H + n_S)$","$\\varepsilon_{\\text{FROST}} \\leq \\varepsilon_{\\text{DLP}} + $ negligible terms","$\\varepsilon_{\\text{FROST}} = \\varepsilon_{\\text{DLP}}$","$\\varepsilon_{\\text{FROST}} \\geq 2\\varepsilon_{\\text{DLP}}$"],correctIndex:0,difficulty:"hard",explanation:"The concrete security bound has the form $\\varepsilon_{\\text{FROST}} \\leq \\varepsilon_{\\text{DLP}}^2 / (2n_H + n_S)$ where $n_H$ is the number of hash queries and $n_S$ is the number of signing queries. This reflects the loss from the Forking Lemma."},{id:2,type:"multiple-choice",question:"What does $n_H$ represent in the security bound $\\varepsilon^2 / (2n_H + n_S)$?",options:["The number of honest participants","The number of random oracle (hash) queries the adversary makes","The size of the hash output in bits","The number of threshold shares"],correctIndex:1,difficulty:"medium",explanation:'$n_H$ represents the number of queries the adversary makes to the random oracle (hash function). The Forking Lemma requires guessing which query will be the "fork point," introducing a factor of $1/n_H$ in the success probability.'},{id:3,type:"multiple-choice",question:"Why does increasing the number of signing queries $n_S$ weaken the concrete security bound?",options:["Each signing query reveals partial information about the secret","Signing queries consume the nonce pool","More queries give the adversary more chances to guess the fork point","More signatures make the public key easier to factor"],correctIndex:2,difficulty:"medium",explanation:"More signing queries give the adversary additional oracle query opportunities, increasing the denominator $2n_H + n_S$. The forking point could occur at any query, so more queries mean lower probability of successful extraction."},{id:4,type:"multiple-choice",question:"For 128-bit security with a bound of $\\varepsilon^2 / (2n_H + n_S)$, approximately how large should the group order be?",options:["128 bits","1024 bits","512 bits","256 bits"],correctIndex:3,difficulty:"medium",explanation:"Due to the $\\varepsilon^2$ factor (squaring from the Forking Lemma), achieving 128-bit security requires starting with 256-bit security in the underlying DLP. This is why secp256k1 (256-bit curve) is used for Bitcoin."},{id:5,type:"multiple-choice",question:'What is "concrete security" as opposed to "asymptotic security"?',options:["Security expressed as explicit bounds for specific parameter sizes","Security proven without any assumptions","Security that only applies to concrete (non-abstract) implementations","Security guaranteed by physical hardware"],correctIndex:0,difficulty:"easy",explanation:'Concrete security gives explicit numerical bounds like "an adversary making $2^{80}$ queries has success probability at most $2^{-128}$." This is more practical than asymptotic statements like "negligible in the security parameter."'}],P=[{id:1,type:"multiple-choice",question:"What is the main advantage of FROST over the Stinson-Strobl threshold Schnorr scheme?",options:["FROST uses smaller keys","FROST requires only one round of communication during signing (vs. three)","FROST supports larger threshold values","FROST uses different elliptic curves"],correctIndex:1,difficulty:"medium",explanation:"FROST achieves single-round signing by using a preprocessing phase for nonce commitments. Stinson-Strobl requires three rounds during signing. This makes FROST significantly more practical for real-world deployments."},{id:2,type:"multiple-choice",question:"How does FROST compare to the Gennaro et al. threshold DSA scheme?",options:["FROST is less secure but faster","FROST requires more participants","FROST produces standard Schnorr signatures, while Gennaro produces DSA signatures","FROST uses RSA instead of elliptic curves"],correctIndex:2,difficulty:"medium",explanation:"FROST produces standard Schnorr signatures compatible with Bitcoin's BIP340, while Gennaro et al. targets threshold DSA (ECDSA). Since Bitcoin adopted Schnorr via Taproot, FROST is the natural choice for Bitcoin applications."},{id:3,type:"multiple-choice",question:"What security property does FROST sacrifice compared to robust threshold schemes?",options:["Unforgeability","Privacy of the secret key","Compatibility with standard verification","Guaranteed output (robustness) - FROST may abort if parties misbehave"],correctIndex:3,difficulty:"medium",explanation:"FROST is not robust: if a malicious party submits an invalid share, the protocol aborts. Robust schemes can complete despite $t-1$ Byzantine faults. FROST trades robustness for efficiency (fewer rounds) and identifies misbehavers."},{id:4,type:"multiple-choice",question:"How does FROST's DKG (Distributed Key Generation) compare to Pedersen DKG?",options:["FROST adds proofs of knowledge to prevent rogue key attacks","FROST uses the same Pedersen DKG without modification","FROST eliminates the need for DKG entirely","FROST uses a trusted dealer instead of DKG"],correctIndex:0,difficulty:"hard",explanation:"FROST enhances Pedersen DKG with proofs of knowledge (Schnorr proofs) for each participant's polynomial. This prevents rogue key attacks where a malicious party could bias the resulting public key."},{id:5,type:"multiple-choice",question:"What makes FROST more suitable for Bitcoin than MuSig alone?",options:["FROST requires fewer on-chain bytes","FROST allows a threshold $(t, n)$ of signers rather than requiring all $n$ signers","FROST is faster to verify","FROST uses post-quantum cryptography"],correctIndex:1,difficulty:"easy",explanation:"MuSig requires all $n$ participants to sign (it's an $n$-of-$n$ scheme). FROST allows any $t$-of-$n$ threshold, providing fault tolerance if some signers are unavailable. For custody solutions, this flexibility is essential."}],E=[{id:1,type:"multiple-choice",question:'Why is "abort on misbehavior" an acceptable security model for FROST?',options:["Because aborts never happen in practice","Because aborted signatures are still valid","Because misbehaving parties can be identified and excluded from future sessions","Because the protocol automatically retries until success"],correctIndex:2,difficulty:"easy",explanation:"When share verification fails, FROST identifies the misbehaving party. This party can be excluded from future signing sessions or have their reputation damaged. The ability to attribute misbehavior provides accountability."},{id:2,type:"multiple-choice",question:"What is the verification equation used to detect invalid signature shares?",options:["$[z_i]G = R_i$","$z_i = \\lambda_i \\cdot c$","$[z_i]G = [c]Y_i$","$[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$"],correctIndex:3,difficulty:"medium",explanation:"Each share $z_i$ is verified using $[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$ where $R_i$ is participant $i$'s nonce commitment, $\\lambda_i$ is their Lagrange coefficient, $c$ is the challenge, and $Y_i$ is their public key share."},{id:3,type:"multiple-choice",question:"In a $(3, 5)$ FROST setup, what happens if one of the three signing participants submits an invalid share?",options:["The protocol aborts, the misbehaver is identified, and signing restarts with a different set","The signature is computed with only two valid shares","The other two participants correct the invalid share","The signature is invalid but still accepted"],correctIndex:0,difficulty:"medium",explanation:"With an invalid share, aggregation would produce an invalid signature. The coordinator detects this via share verification, identifies the misbehaver, aborts, and can restart with a different set of 3 participants from the 5 available."},{id:4,type:"multiple-choice",question:"What is the computational cost of verifying a single signature share?",options:["One hash computation","Two elliptic curve point multiplications and one addition","One modular exponentiation","One polynomial evaluation"],correctIndex:1,difficulty:"medium",explanation:"Verifying $[z_i]G = R_i + [\\lambda_i \\cdot c]Y_i$ requires computing $[z_i]G$ (one scalar multiplication), $[\\lambda_i \\cdot c]Y_i$ (one scalar multiplication), and adding to $R_i$ (one point addition)."},{id:5,type:"multiple-choice",question:"Why might a rational (economically-motivated) adversary choose not to submit invalid shares?",options:["Invalid shares are automatically corrected","Invalid shares require more computation to generate","Misbehavior is detectable, attributable, and leads to exclusion from profitable signing sessions","The protocol financially penalizes invalid shares"],correctIndex:2,difficulty:"easy",explanation:"Since misbehavior is detectable and attributable, a rational adversary gains nothing from submitting invalid shares except being excluded from future participation. The denial-of-service is temporary and the attacker loses their position."}],H=[{id:1,type:"multiple-choice",question:"What is signature aggregation in the context of FROST and MuSig?",options:["Combining multiple different signatures into one file","Compressing signature data for storage","Aggregating signatures from different time periods","Combining multiple signers' contributions into a single standard Schnorr signature"],correctIndex:3,difficulty:"easy",explanation:"Signature aggregation combines contributions from multiple signers into a single Schnorr signature $(R, z)$ that verifies against an aggregated public key. The final signature is indistinguishable from a single-signer Schnorr signature."},{id:2,type:"multiple-choice",question:"How is the aggregated public key $Y$ computed in a FROST group?",options:["$Y = \\sum_{i \\in S} \\lambda_i Y_i$ for signing set $S$","$Y = Y_1 + Y_2 + \\cdots + Y_n$","$Y = Y_1 \\cdot Y_2 \\cdots Y_n$","$Y = H(Y_1 \\| Y_2 \\| \\cdots \\| Y_n)$"],correctIndex:0,difficulty:"medium",explanation:"The group public key is $Y = \\sum_{i \\in S} \\lambda_i Y_i$ where $\\lambda_i$ are Lagrange coefficients and $S$ is any set of $t$ participants. Due to polynomial interpolation, this equals $[s]G$ regardless of which $t$ participants are chosen."},{id:3,type:"multiple-choice",question:"What advantage does FROST+MuSig provide over standard Bitcoin multisig?",options:["Faster transaction confirmation","A single 64-byte signature instead of multiple signatures, saving block space","Higher security guarantees","No need for internet connectivity"],correctIndex:1,difficulty:"easy",explanation:"Standard $m$-of-$n$ multisig requires $m$ separate signatures on-chain. FROST produces a single 64-byte Schnorr signature regardless of threshold, dramatically reducing transaction size and fees."},{id:4,type:"multiple-choice",question:'In MuSig-style key aggregation, why is the "key aggregation coefficient" $a_i = H(L, X_i)$ necessary?',options:["To make signatures shorter","To improve verification speed","To prevent rogue key attacks where a malicious party can control the aggregate key","To enable key recovery"],correctIndex:2,difficulty:"hard",explanation:"Without key aggregation coefficients, an attacker could choose $X_n = X_n' - \\sum_{i<n} X_i$ to make the aggregate key equal to $X_n'$ which they control alone. The coefficients $a_i = H(L, X_i)$ prevent this by making the aggregation non-linear."},{id:5,type:"multiple-choice",question:"How does the final aggregated signature $z$ relate to individual signature shares $z_i$?",options:["$z = z_1 \\cdot z_2 \\cdots z_t$","$z = H(z_1 \\| z_2 \\| \\cdots \\| z_t)$","$z = \\max(z_1, z_2, \\ldots, z_t)$","$z = \\sum_{i \\in S} z_i$"],correctIndex:3,difficulty:"medium",explanation:"The final signature response is the sum $z = \\sum_{i \\in S} z_i$ of all participant shares. This works because the Lagrange coefficients are already embedded in each $z_i$, and the sum reconstructs the correct aggregate response."}],j=[{id:1,type:"multiple-choice",question:'What is "rerandomization" in the context of FROST signatures?',options:["Transforming the public key and shares so signatures are unlinkable across sessions","Generating new random nonces for each signature","Adding random padding to signatures","Randomizing the order of participants"],correctIndex:0,difficulty:"medium",explanation:"Rerandomization adds a public random value to shift the group public key from $Y$ to $Y' = Y + [r]G$. Signatures under $Y'$ cannot be linked back to the original key $Y$, enhancing privacy."},{id:2,type:"multiple-choice",question:"If the original group key is $Y = [s]G$ and rerandomization factor is $r$, what is the effective secret key for the rerandomized key $Y'$?",options:["$s' = s \\cdot r$","$s' = s + r$","$s' = s - r$","$s' = s / r$"],correctIndex:1,difficulty:"medium",explanation:"With $Y' = Y + [r]G = [s]G + [r]G = [s + r]G$, the effective secret is $s' = s + r$. Each participant adds $r \\cdot \\lambda_i$ to their share to sign under the new key."},{id:3,type:"multiple-choice",question:"Why is rerandomization useful for Bitcoin privacy?",options:["It makes transactions faster","It reduces transaction fees","It makes multiple signatures from the same group unlinkable on the blockchain","It enables offline signing"],correctIndex:2,difficulty:"easy",explanation:"Each rerandomized key $Y'$ appears as a completely new public key on-chain. Observers cannot link multiple transactions to the same FROST group, significantly enhancing financial privacy."},{id:4,type:"multiple-choice",question:"What property must the rerandomization factor $r$ satisfy?",options:["It must be a prime number","It must equal the sum of all share values","It must be kept secret from all participants","It must be known to all participants but unpredictable to outsiders"],correctIndex:3,difficulty:"medium",explanation:"The factor $r$ must be known to signing participants (so they can adjust their shares) but should be unpredictable to chain analysts. It can be derived from a shared random beacon or agreed upon in the signing session."},{id:5,type:"multiple-choice",question:"How does rerandomization affect the verification of FROST signatures?",options:["Verification is unchanged - standard Schnorr verification works with the rerandomized public key","Verification becomes more complex, requiring knowledge of $r$","Verification requires multiple rounds","Verification can only be done by participants"],correctIndex:0,difficulty:"easy",explanation:"Signatures under the rerandomized key $Y'$ are standard Schnorr signatures. Anyone can verify using $[z]G = R + [c]Y'$ without knowing the rerandomization factor $r$ or that rerandomization was used."}],Y=[{id:1,type:"multiple-choice",question:"What is hierarchical threshold signing (nested FROST)?",options:["Using FROST with increasing threshold values over time",'FROST where each "participant" is itself a threshold group',"A priority ordering of participants for signing","FROST with multiple rounds of communication"],correctIndex:1,difficulty:"medium",explanation:'In nested FROST, each logical participant in the outer FROST group is itself an inner FROST threshold group. For example, a 2-of-3 outer threshold where each of the 3 "participants" is a 3-of-5 inner group.'},{id:2,type:"multiple-choice",question:"What organizational structure does hierarchical FROST naturally model?",options:["Flat peer-to-peer networks","Blockchain consensus mechanisms","Corporate hierarchies with departments that have their own signing authority","Single-user wallet applications"],correctIndex:2,difficulty:"easy",explanation:"Hierarchical FROST models organizations where departments (inner groups) have internal approval processes, and company-wide decisions require approval from multiple departments (outer threshold)."},{id:3,type:"multiple-choice",question:"In a 2-of-3 outer FROST where each participant is a 2-of-3 inner FROST, what is the minimum number of individual signers needed?",options:["2 signers","3 signers","6 signers","4 signers"],correctIndex:3,difficulty:"medium",explanation:"To activate 2 outer participants, each inner group needs 2 signers. So minimum is $2 \\times 2 = 4$ individual signers. These 4 signers must come from 2 different inner groups."},{id:4,type:"multiple-choice",question:"How is the inner group's contribution to the outer signature computed?",options:["The inner group runs FROST to produce a signature share for the outer protocol","The inner group produces a full signature that the outer group verifies","Each inner participant sends their share directly to the outer coordinator","The inner group votes on whether to approve the outer signature"],correctIndex:0,difficulty:"hard",explanation:"Each inner FROST group runs its own threshold protocol to produce what appears as a single signature share to the outer FROST protocol. The inner group's aggregated share $z_{\\text{inner}} = \\sum_{j} z_j$ serves as one participant's contribution to the outer scheme."},{id:5,type:"multiple-choice",question:"What is a key benefit of hierarchical FROST over flat threshold schemes?",options:["Smaller signature size","Flexible organizational policies with different thresholds at different levels","Faster verification","Reduced computation for participants"],correctIndex:1,difficulty:"medium",explanation:"Hierarchical FROST allows different thresholds at each level. A company might require 2-of-3 departments, but each department can set its own policy (e.g., engineering: 3-of-5, finance: 2-of-3). This flexibility matches real organizational needs."}],Q=[{id:1,type:"multiple-choice",question:"What is proactive secret sharing?",options:["Sharing secrets before they are needed","Sharing secrets with future participants","Periodically refreshing shares while keeping the same secret and public key","Encrypting shares with time-locked encryption"],correctIndex:2,difficulty:"medium",explanation:"Proactive secret sharing periodically refreshes all shares so that old shares become useless. The secret $s$ and public key $Y$ remain unchanged, but an attacker who compromised old shares cannot combine them with new shares."},{id:2,type:"multiple-choice",question:"How does proactive share refresh work mathematically?",options:["Generate a new secret and distribute new shares","Hash the old shares to create new ones","Multiply all shares by a random factor","Each participant adds shares of zero to their existing share: $s_i' = s_i + \\delta_i$ where $\\sum \\delta_i = 0$"],correctIndex:3,difficulty:"hard",explanation:"Participants jointly generate a random polynomial with zero constant term and add the resulting shares to their existing shares. Since the new polynomial sums to zero, the secret $s$ is unchanged, but individual shares $s_i' = s_i + \\delta_i$ are completely different."},{id:3,type:"multiple-choice",question:"What attack does proactive secret sharing defend against?",options:["Mobile adversaries who compromise different parties over time","Quantum computing attacks","Denial of service attacks","Man-in-the-middle attacks"],correctIndex:0,difficulty:"medium",explanation:"A mobile adversary might compromise participant 1 in epoch 1, participant 2 in epoch 2, etc. Without refresh, they eventually collect $t$ shares. With proactive refresh, shares from different epochs are incompatible and cannot be combined."},{id:4,type:"multiple-choice",question:"What must be true about share refreshes for security?",options:["Refreshes must happen at unpredictable times","Refreshes must complete before an adversary can compromise $t$ parties in one epoch","Refreshes must change the public key each time","Refreshes must use different threshold values"],correctIndex:1,difficulty:"medium",explanation:"The refresh period (epoch) must be short enough that an adversary cannot compromise $t$ parties within a single epoch. If they could, they could reconstruct the secret before the refresh invalidates their gathered shares."},{id:5,type:"multiple-choice",question:"After a proactive refresh, what can an adversary do with shares collected from the previous epoch?",options:["Combine them with new shares to reconstruct the secret","Verify signatures from the old epoch","Nothing useful - old shares are incompatible with new shares","Derive the new shares from the old ones"],correctIndex:2,difficulty:"easy",explanation:"Old and new shares lie on different polynomials (differing by the refresh polynomial). They cannot be combined via Lagrange interpolation. An adversary's collected old shares become worthless after refresh."}],M=[{id:1,type:"multiple-choice",question:"What is a dynamic threshold change in FROST?",options:["Changing the threshold during a signing session","Randomly selecting the threshold for each signature","Automatically adjusting threshold based on transaction value","Changing from $(t_1, n_1)$ to $(t_2, n_2)$ threshold without changing the public key"],correctIndex:3,difficulty:"medium",explanation:"Dynamic threshold changes allow the group to modify both the threshold $t$ and total participants $n$ (e.g., from 2-of-3 to 3-of-5) while keeping the same group public key $Y = [s]G$ and underlying secret $s$."},{id:2,type:"multiple-choice",question:"Why would an organization want to change their FROST threshold?",options:["To add new key holders or increase security requirements as the organization grows","To make signatures smaller","To speed up signature verification","To reduce computational costs"],correctIndex:0,difficulty:"easy",explanation:"As organizations evolve, they may need to add new signers (new employees, new devices) or increase the threshold for higher-value transactions. Dynamic thresholds avoid generating entirely new keys and updating all systems."},{id:3,type:"multiple-choice",question:"How is a threshold increase from $t$ to $t' > t$ accomplished?",options:["Generate completely new shares for all participants","Have $t$ existing holders jointly re-share the secret using a degree $t'-1$ polynomial","Multiply all existing shares by $(t'/t)$","Hash existing shares with the new threshold value"],correctIndex:1,difficulty:"hard",explanation:"To increase threshold from $t$ to $t'$, current shareholders run a re-sharing protocol. They use their combined knowledge (via Lagrange interpolation) to create new shares on a degree $t'-1$ polynomial, requiring $t'$ shares to reconstruct."},{id:4,type:"multiple-choice",question:"What challenge arises when adding new participants to a FROST group?",options:["The public key must change","Existing participants must delete their shares","New participants need shares without any single party knowing the complete secret","The signature format changes"],correctIndex:2,difficulty:"medium",explanation:"New participants need valid shares of the existing secret $s$, but no single current participant knows $s$. The existing $t$ shareholders must collaboratively generate new shares without reconstructing the secret."},{id:5,type:"multiple-choice",question:"What is the minimum number of existing participants needed to perform a threshold change?",options:["1 participant","$t + 1$ participants","$n$ participants (all current participants)","$t$ participants (the current threshold)"],correctIndex:3,difficulty:"medium",explanation:"Exactly $t$ participants are needed - enough to reconstruct the secret's polynomial. They can then jointly compute new shares for any new polynomial degree. Fewer than $t$ cannot reconstruct; more than $t$ is unnecessary."}],N=[{id:1,type:"multiple-choice",question:"What is Taproot (BIP340/BIP341) in Bitcoin?",options:["An upgrade enabling Schnorr signatures and a key/script spending structure","A new cryptocurrency built on Bitcoin","A layer-2 scaling solution","A privacy coin mixer"],correctIndex:0,difficulty:"easy",explanation:"Taproot (activated November 2021) introduced BIP340 Schnorr signatures and BIP341's key-path/script-path spending structure. The key path allows spending with just a signature, while the script path reveals complex conditions only if needed."},{id:2,type:"multiple-choice",question:"How does FROST integrate with Taproot's key path?",options:["FROST signatures are incompatible with Taproot","The FROST group public key becomes the Taproot internal key for key-path spending","FROST requires revealing the script path","Taproot must be modified to support FROST"],correctIndex:1,difficulty:"medium",explanation:"The FROST group's aggregated public key $Y$ serves as the Taproot internal key. When all threshold participants cooperate, they produce a standard BIP340 Schnorr signature for key-path spending - indistinguishable from a single-signer spend."},{id:3,type:"multiple-choice",question:"What privacy benefit does FROST+Taproot provide?",options:["Transaction amounts are hidden","Sender addresses are anonymized","Threshold signatures look identical to single-signer transactions on-chain","Transaction history is deleted after confirmation"],correctIndex:2,difficulty:"medium",explanation:"A FROST threshold signature is a standard 64-byte Schnorr signature. On-chain observers cannot distinguish a 3-of-5 FROST spend from a single person spending with one key. This hides the multi-party nature of custody."},{id:4,type:"multiple-choice",question:'What is the "tweak" in Taproot key derivation, and how does it affect FROST?',options:["A small adjustment to improve performance","An error correction code","A random value added for privacy","The public key is tweaked by $t = H(P \\| m)$ where $m$ is the Merkle root of scripts"],correctIndex:3,difficulty:"hard",explanation:"The Taproot output key is $Q = P + [t]G$ where $t = \\text{hash}(P \\| m)$ commits to scripts. FROST participants must account for this tweak when signing: the effective secret becomes $s + t$, requiring adjustment in the signing protocol."},{id:5,type:"multiple-choice",question:"What happens if FROST participants cannot cooperate (e.g., key loss)?",options:["The Taproot script path can provide fallback spending conditions","Funds are permanently lost","Bitcoin miners can recover the funds","The threshold automatically decreases"],correctIndex:0,difficulty:"medium",explanation:"Taproot's script path provides fallback conditions. For example, after a timelock, a backup key or different threshold might spend. This combines FROST's efficiency in the happy path with script-based recovery in exceptional cases."}],U=[{id:1,type:"multiple-choice",question:"What is the Lightning Network?",options:["A faster blockchain that replaces Bitcoin","A layer-2 payment channel network enabling instant, low-fee Bitcoin transactions","A mining pool for Bitcoin","A cryptocurrency exchange"],correctIndex:1,difficulty:"easy",explanation:"The Lightning Network is a layer-2 protocol built on Bitcoin. It uses payment channels to enable instant, nearly-free transactions that settle on-chain only when channels open or close."},{id:2,type:"multiple-choice",question:"How can FROST improve Lightning Network channel security?",options:["By making channel transactions faster","By reducing Lightning routing fees","By allowing channel funds to be controlled by a threshold group instead of a single key","By eliminating the need for watchtowers"],correctIndex:2,difficulty:"medium",explanation:"A Lightning node's hot wallet key is a single point of failure. Using FROST, the channel key can be a 2-of-3 threshold, requiring compromise of multiple devices/locations to steal funds, dramatically improving security."},{id:3,type:"multiple-choice",question:"What challenge does FROST's signing latency present for Lightning?",options:["Lightning channels cannot use Schnorr signatures","Lightning requires ECDSA, not Schnorr","FROST signatures are too large for Lightning","HTLC forwarding requires fast signing, but FROST needs multi-party coordination"],correctIndex:3,difficulty:"hard",explanation:"Lightning routing requires forwarding HTLCs within seconds. FROST signing requires coordination among threshold parties, adding latency. Solutions include keeping signing parties online/colocated or using faster communication protocols."},{id:4,type:"multiple-choice",question:"What is a potential use case for FROST in Lightning routing nodes?",options:["Distributed custody of large routing node balances across multiple operators","Reducing on-chain fees","Increasing channel capacity limits","Eliminating the need for channel announcements"],correctIndex:0,difficulty:"medium",explanation:"Large routing nodes hold significant funds. FROST enables multiple parties (e.g., business partners) to jointly control a routing node, requiring threshold agreement for channel operations and reducing single-operator risk."},{id:5,type:"multiple-choice",question:"How does FROST interact with Lightning's commitment transaction signing?",options:["FROST cannot sign commitment transactions","Each commitment transaction update requires threshold participants to jointly sign","Only channel opening requires FROST; updates use single signatures","FROST automatically signs all commitment updates"],correctIndex:1,difficulty:"medium",explanation:"Every Lightning channel state update requires signing new commitment transactions. With FROST-protected channels, threshold participants must coordinate to sign each update, trading some speed for significantly enhanced security."}],V=[{id:1,type:"multiple-choice",question:'What is a "scriptless script" in Bitcoin?',options:["A transaction without any script at all","A script that is too small to see","A cryptographic protocol that achieves smart contract functionality using only signatures","A compressed version of Bitcoin Script"],correctIndex:2,difficulty:"medium",explanation:"Scriptless scripts use cryptographic techniques (especially adaptor signatures) to encode conditions in signatures rather than on-chain scripts. The blockchain sees only a regular signature, hiding the underlying logic."},{id:2,type:"multiple-choice",question:"What is an adaptor signature?",options:["A signature that adapts to different message formats","A compressed signature format","A signature that works on multiple blockchains","An incomplete signature that becomes valid when a secret value is revealed"],correctIndex:3,difficulty:"medium",explanation:"An adaptor signature $\\tilde{\\sigma}$ is offset by a secret $t$: $\\tilde{z} = z - t$. It's invalid as-is, but when $t$ is revealed, anyone can compute the valid signature $z = \\tilde{z} + t$. Revealing the signature reveals $t$."},{id:3,type:"multiple-choice",question:"How do adaptor signatures enable atomic swaps?",options:["By linking two transactions so completing one reveals the secret needed for the other","By requiring both parties to sign simultaneously","By using a trusted third party","By broadcasting both transactions in the same block"],correctIndex:0,difficulty:"hard",explanation:"Alice gives Bob an adaptor signature on her payment, offset by secret $t$. Bob gives Alice an adaptor on his payment, offset by the same $t$. When Alice claims Bob's payment (revealing $t$), Bob learns $t$ and can claim Alice's payment. Atomic!"},{id:4,type:"multiple-choice",question:"How does FROST produce adaptor signatures?",options:["FROST cannot produce adaptor signatures","Participants add the adaptor point $T = [t]G$ to their nonce commitment: $R' = R + T$","The coordinator adds the adaptor after aggregating","Each participant creates their own adaptor"],correctIndex:1,difficulty:"hard",explanation:"To create a FROST adaptor signature for secret $t$ with point $T = [t]G$, participants compute the signature with nonce commitment $R' = R + T$. The resulting signature is offset by $t$: revealing the valid signature reveals $t$."},{id:5,type:"multiple-choice",question:"What privacy advantage do scriptless scripts provide over on-chain conditionals?",options:["Scriptless scripts are faster to verify","Scriptless scripts use less memory","Contract conditions are invisible on-chain - only standard signatures appear","They enable higher transaction throughput"],correctIndex:2,difficulty:"easy",explanation:"With scriptless scripts, complex conditions (atomic swaps, payment routing, etc.) are enforced cryptographically. The blockchain only sees ordinary Schnorr signatures, revealing nothing about the underlying protocol or conditions."}],K=[{id:1,type:"multiple-choice",question:'What is "cold storage" in Bitcoin custody?',options:["Storing Bitcoin in cold climates for efficiency","Storing encrypted backups in cloud storage","Using liquid cooling for mining hardware","Keeping signing keys offline, disconnected from the internet"],correctIndex:3,difficulty:"easy",explanation:"Cold storage means keeping private keys on devices that are never connected to the internet (air-gapped). This prevents remote attacks but requires physical access to sign transactions."},{id:2,type:"multiple-choice",question:"In a 3-of-5 FROST cold storage setup, what is a typical key distribution strategy?",options:["Keys distributed across different geographic locations and device types","All 5 keys on one hardware device","All keys stored in the same bank vault","Keys memorized by 5 different people"],correctIndex:0,difficulty:"medium",explanation:"Best practice distributes keys across: different physical locations (home, office, bank vault), different device types (hardware wallets, air-gapped computers), and different custodians. This maximizes resilience against various failure modes."},{id:3,type:"multiple-choice",question:"How does FROST signing work with air-gapped cold storage devices?",options:["It cannot work - FROST requires internet connectivity","Signing data is transferred via QR codes, USB drives, or SD cards between devices","Cold devices must briefly connect to the internet to sign","Only the coordinator needs to be online"],correctIndex:1,difficulty:"medium",explanation:"Air-gapped FROST signing transfers data physically: the coordinator prepares signing requests, transfers via QR/USB/SD to cold devices, each device computes its share offline, and shares are collected back for aggregation. No internet needed."},{id:4,type:"multiple-choice",question:"What is the signing workflow for a cold storage FROST transaction?",options:["Single-click automatic signing","All devices sign simultaneously online","1) Coordinator prepares request, 2) Transfer to cold devices, 3) Each signs offline, 4) Collect shares, 5) Aggregate and broadcast","The coordinator signs on behalf of all devices"],correctIndex:2,difficulty:"medium",explanation:"Cold FROST signing involves: coordinator creating the signing request with all commitments, physically transferring to each cold device, each device computing its share independently, collecting shares back, aggregating into final signature, and broadcasting."},{id:5,type:"multiple-choice",question:"What is a key advantage of 3-of-5 FROST over 3-of-5 Bitcoin multisig for cold storage?",options:["FROST is more secure cryptographically","FROST requires fewer hardware devices","FROST signing is faster","FROST produces a single signature, saving fees and hiding the multisig structure"],correctIndex:3,difficulty:"easy",explanation:"Traditional 3-of-5 multisig requires 3 signatures and reveals the 3-of-5 structure on-chain. FROST produces one 64-byte signature indistinguishable from single-key spending, saving ~60% in fees and providing complete privacy about the custody setup."}],Z=[{id:1,type:"multiple-choice",question:"What is finite field arithmetic in the context of FROST?",options:["Arithmetic modulo a prime $p$, where all operations stay within $\\{0, 1, \\ldots, p-1\\}$","Arithmetic with very small numbers","Arithmetic with floating-point numbers","Arithmetic limited to a finite number of operations"],correctIndex:0,difficulty:"easy",explanation:"FROST performs all scalar arithmetic in the finite field $\\mathbb{F}_p$ where $p$ is the curve order. Addition, subtraction, and multiplication are done modulo $p$, and division uses modular inverses."},{id:2,type:"multiple-choice",question:"How is division $a/b$ computed in a finite field $\\mathbb{F}_p$?",options:["Standard floating-point division rounded to nearest integer","Multiplication by the modular inverse: $a \\cdot b^{-1} \\mod p$","Repeated subtraction until zero","Division is not possible in finite fields"],correctIndex:1,difficulty:"medium",explanation:"In $\\mathbb{F}_p$, division by $b$ means multiplying by $b^{-1}$ where $b \\cdot b^{-1} \\equiv 1 \\pmod{p}$. The inverse is computed using the extended Euclidean algorithm or Fermat's little theorem: $b^{-1} = b^{p-2} \\mod p$."},{id:3,type:"multiple-choice",question:"Why is constant-time implementation critical for FROST field arithmetic?",options:["To ensure consistent transaction confirmation times","To meet regulatory requirements","To prevent timing side-channel attacks that leak secret information","To reduce power consumption"],correctIndex:2,difficulty:"medium",explanation:"If computation time depends on secret values (like private key bits), attackers can measure timing variations to extract secrets. Constant-time code ensures operations take the same time regardless of input values, preventing timing attacks."},{id:4,type:"multiple-choice",question:"What is the order of the secp256k1 curve used in Bitcoin?",options:["$2^{128}$","$p = 2^{256} - 2^{32} - 977$ (the field prime)","$2^{256}$","$n = $ FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 (hex)"],correctIndex:3,difficulty:"hard",explanation:"secp256k1 has order $n \\approx 2^{256}$ (slightly less). This is the number of points on the curve and the modulus for scalar arithmetic. The field prime $p$ is different and governs coordinate arithmetic."},{id:5,type:"multiple-choice",question:"What technique is commonly used for efficient modular multiplication of large integers?",options:["Montgomery multiplication, which avoids expensive division","Standard grade-school multiplication","Repeated addition","Lookup tables for all possible products"],correctIndex:0,difficulty:"hard",explanation:'Montgomery multiplication transforms numbers into "Montgomery form" where modular reduction uses only shifts and additions instead of division. This significantly speeds up sequences of multiplications, crucial for scalar multiplication.'}],X=[{id:1,type:"multiple-choice",question:"In elliptic curve cryptography, what is the result of adding a point $P$ to itself (point doubling)?",options:["The identity element $\\mathcal{O}$","A new point $2P$ on the curve","The inverse point $-P$","An undefined operation"],correctIndex:1,difficulty:"medium",explanation:"Point doubling ($P + P = 2P$) produces a new point on the curve by drawing a tangent line at $P$ and finding where it intersects the curve."},{id:2,type:"multiple-choice",question:"What special case must be handled when adding two elliptic curve points $P$ and $Q$?",options:["When the sum exceeds the field order","When both points have positive coordinates","When $P$ and $Q$ have the same $x$-coordinate but different $y$-coordinates","When the points are both generators"],correctIndex:2,difficulty:"hard",explanation:"When $P$ and $Q$ share the same $x$-coordinate but have different $y$-coordinates, they are inverses ($Q = -P$), and $P + Q = \\mathcal{O}$ (the identity element)."},{id:3,type:"multiple-choice",question:"For the secp256k1 curve used in Bitcoin, what is the coordinate field?",options:["Real numbers $\\mathbb{R}$","Rational numbers $\\mathbb{Q}$","Complex numbers $\\mathbb{C}$","Integers modulo a 256-bit prime $p$"],correctIndex:3,difficulty:"easy",explanation:"secp256k1 uses a prime field $\\mathbb{F}_p$ where $p = 2^{256} - 2^{32} - 977$, meaning all coordinates are integers modulo this large prime."},{id:4,type:"multiple-choice",question:"Why is modular inversion computationally expensive in elliptic curve arithmetic?",options:["It uses the extended Euclidean algorithm with $O(\\log p)$ iterations","It requires solving a discrete logarithm","It cannot be computed for prime fields","It always requires floating point operations"],correctIndex:0,difficulty:"hard",explanation:"Modular inversion (finding $a^{-1} \\mod p$) uses the extended Euclidean algorithm, which is expensive compared to multiplication. This is why projective coordinates are often used to avoid inversions."},{id:5,type:"multiple-choice",question:"What technique reduces the number of modular inversions in elliptic curve multi-scalar multiplication?",options:["Increasing the field size","Using projective or Jacobian coordinates","Using floating point approximations","Reducing the number of points"],correctIndex:1,difficulty:"medium",explanation:"Projective coordinates $(X:Y:Z)$ represent a point as $(X/Z, Y/Z)$ or similar, allowing multiple operations before a single final inversion to convert back to affine coordinates."}],J=[{id:1,type:"multiple-choice",question:"What does CSPRNG stand for in cryptographic implementations?",options:["Cryptographic Secure Prime Number Generator","Certified Standard Protocol for Random Number Generation","Cryptographically Secure Pseudo-Random Number Generator","Computational System for Polynomial Random Number Generation"],correctIndex:2,difficulty:"easy",explanation:"CSPRNG stands for Cryptographically Secure Pseudo-Random Number Generator, which produces random values that are computationally indistinguishable from true randomness."},{id:2,type:"multiple-choice",question:"Why must FROST nonces be generated using a CSPRNG rather than a standard PRNG?",options:["Standard PRNGs are faster but less accurate","Standard PRNGs cannot generate numbers in the correct range","CSPRNGs produce larger numbers","Predictable nonces allow attackers to recover the secret key"],correctIndex:3,difficulty:"medium",explanation:"If an attacker can predict the nonces used in FROST, they can compute the secret key. CSPRNGs ensure nonces are unpredictable even to an adversary who knows previous outputs."},{id:3,type:"multiple-choice",question:"In FROST, what mathematical property must random nonces $d_i$ and $e_i$ satisfy?",options:["They must be non-zero elements of $\\mathbb{Z}_q$","They must be prime numbers","They must sum to zero","They must be powers of 2"],correctIndex:0,difficulty:"medium",explanation:"Nonces must be uniformly random non-zero elements of the scalar field $\\mathbb{Z}_q$ to ensure the security properties of the signature scheme."},{id:4,type:"multiple-choice",question:"What is a critical security concern when generating randomness in a virtual machine or container?",options:["VMs cannot generate random numbers","Entropy sources may be limited or predictable after VM snapshots","Containers always share random numbers","Virtual machines use floating point randomness"],correctIndex:1,difficulty:"hard",explanation:"VM snapshots can capture the RNG state, leading to nonce reuse if the VM is restored. Containers may also have limited entropy sources, requiring careful attention to randomness quality."},{id:5,type:"multiple-choice",question:"Which system call provides cryptographic randomness on Linux systems?",options:["$\\texttt{rand()}$","$\\texttt{malloc()}$","$\\texttt{getrandom()}$ or reading from $\\texttt{/dev/urandom}$","$\\texttt{time()}$"],correctIndex:2,difficulty:"easy",explanation:"Linux provides $\\texttt{getrandom()}$ syscall and $\\texttt{/dev/urandom}$ for cryptographic randomness, backed by the kernel entropy pool."}],ee=[{id:1,type:"multiple-choice",question:"What is the Lagrange coefficient $\\lambda_i$ used for in FROST signing?",options:["To encrypt the message","To verify the public key","To generate new random nonces","To interpolate secret shares back to the full secret at a specific point"],correctIndex:3,difficulty:"medium",explanation:"Lagrange coefficients allow reconstruction of a polynomial (and hence the secret) from $t$ shares by interpolation: $\\lambda_i = \\prod_{j \\neq i} \\frac{x_j}{x_j - x_i}$."},{id:2,type:"multiple-choice",question:"Given signers with indices $\\{1, 3, 4\\}$ and threshold $t = 2$, what is $\\lambda_1$ evaluated at $x = 0$?",options:["$\\frac{3 \\cdot 4}{(3-1)(4-1)} = \\frac{12}{6} = 2$","$\\frac{3 \\cdot 4}{(3-1)(4-1)} = 2$","$\\frac{(-3)(-4)}{(-3-(-1))(-4-(-1))} = 2$","$\\frac{3 \\cdot 4}{(1-3)(1-4)} = \\frac{12}{6} = 2$"],correctIndex:0,difficulty:"hard",explanation:"$\\lambda_1 = \\frac{(0-3)(0-4)}{(1-3)(1-4)} = \\frac{(-3)(-4)}{(-2)(-3)} = \\frac{12}{6} = 2$"},{id:3,type:"multiple-choice",question:"Why must Lagrange coefficient computation be done in modular arithmetic for FROST?",options:["To make computation faster","Because the scalar field $\\mathbb{Z}_q$ requires all operations modulo $q$","To avoid negative numbers","Because floating point arithmetic is imprecise"],correctIndex:1,difficulty:"medium",explanation:"All scalar operations in FROST occur in $\\mathbb{Z}_q$. Division becomes multiplication by the modular inverse, ensuring algebraic consistency."},{id:4,type:"multiple-choice",question:"What happens if two signers accidentally use the same index in FROST?",options:["The signature is twice as secure","The protocol automatically reassigns indices","Lagrange interpolation fails due to division by zero","Nothing, indices do not matter"],correctIndex:2,difficulty:"medium",explanation:"If $x_i = x_j$ for $i \\neq j$, the Lagrange formula contains $(x_j - x_i) = 0$ in a denominator, causing division by zero."},{id:5,type:"multiple-choice",question:"For efficiency, when should Lagrange coefficients be precomputed?",options:["Never, they must always be computed fresh","After the signature is complete","Only during key generation","When the signing group is known in advance and fixed"],correctIndex:3,difficulty:"easy",explanation:"When the same subset of signers repeatedly signs, their Lagrange coefficients remain constant and can be cached to avoid redundant computation."}],ie=[{id:1,type:"multiple-choice",question:"In FROST, what is the hash function used for in the binding factor computation?",options:["Binding each signer's commitment to the message and all commitments","Encrypting the message","Generating random nonces","Compressing the public key"],correctIndex:0,difficulty:"medium",explanation:"The hash function creates a binding factor $\\rho_i = H(i, m, B)$ that ties each signer's contribution to the specific message and commitment set, preventing manipulation."},{id:2,type:"multiple-choice",question:"Why does FROST require a hash function that is modeled as a random oracle?",options:["To produce shorter outputs","To ensure unpredictable outputs that an adversary cannot manipulate","To make hashing faster","To compress large messages"],correctIndex:1,difficulty:"hard",explanation:"The random oracle model assumes hash outputs are uniformly random and independent. This prevents adversaries from finding inputs that produce related or predictable outputs."},{id:3,type:"multiple-choice",question:"What hash function is commonly used in Bitcoin-compatible FROST implementations?",options:["MD5","SHA-1","SHA-256 (often with tagged hashing as in BIP-340)","CRC32"],correctIndex:2,difficulty:"easy",explanation:"Bitcoin uses SHA-256, and BIP-340 Schnorr signatures use tagged hashing (domain separation) with SHA-256 for different protocol components."},{id:4,type:"multiple-choice",question:'What is "domain separation" in the context of hash functions for FROST?',options:["Separating hash computation across multiple CPUs","Separating the message into domains","Hashing in different time zones","Using different hash prefixes/tags for different protocol purposes"],correctIndex:3,difficulty:"medium",explanation:'Domain separation uses distinct prefixes or tags (e.g., "FROST-nonce", "FROST-challenge") so that hash outputs for different purposes cannot collide or be reused.'},{id:5,type:"multiple-choice",question:"What security concern arises if the same hash output is used for both nonce binding and challenge computation?",options:["An attacker might exploit relationships between the values","The hash becomes slower","The signature becomes larger","Nothing, hash reuse is safe"],correctIndex:0,difficulty:"hard",explanation:"Without domain separation, an attacker might craft inputs that produce related outputs in different contexts, potentially enabling signature forgery or key extraction."}],te=[{id:1,type:"multiple-choice",question:"What equation is used to verify a FROST signature share $z_i$ from participant $i$?",options:["$z_i = d_i + e_i \\cdot \\rho_i$","$z_i \\cdot G = R_i + c \\cdot \\lambda_i \\cdot Y_i$","$z_i \\cdot Y_i = R_i$","$z_i = H(m) \\cdot x_i$"],correctIndex:1,difficulty:"hard",explanation:"Each signature share is verified by checking $z_i \\cdot G = R_i + c \\cdot \\lambda_i \\cdot Y_i$, where $R_i$ is the commitment, $c$ is the challenge, and $Y_i$ is the public share."},{id:2,type:"multiple-choice",question:"Why is signature share verification important in FROST?",options:["To speed up the signing process","To encrypt the signature","To identify malicious signers who submit invalid shares","To generate the public key"],correctIndex:2,difficulty:"medium",explanation:"Verification catches malicious or malfunctioning signers before aggregation. Without it, a single bad share would invalidate the entire signature with no way to identify the culprit."},{id:3,type:"multiple-choice",question:"What happens if a signature share fails verification?",options:["The protocol automatically fixes it","All shares are discarded","The share is used anyway","The signer should be identified and excluded, and signing restarted"],correctIndex:3,difficulty:"medium",explanation:"A failed verification indicates the signer provided an incorrect share (malicious or buggy). The coordinator should exclude that signer and restart with a valid subset."},{id:4,type:"multiple-choice",question:"In the verification equation $z_i \\cdot G = R_i + c \\cdot \\lambda_i \\cdot Y_i$, what does $\\lambda_i$ represent?",options:["The Lagrange coefficient for signer $i$","The signer's private key","A random nonce","The message hash"],correctIndex:0,difficulty:"easy",explanation:"$\\lambda_i$ is the Lagrange coefficient that weights signer $i$'s contribution based on which signers are participating in this signing session."},{id:5,type:"multiple-choice",question:"What is the computational cost of verifying all signature shares compared to skipping verification?",options:["No additional cost","One scalar multiplication per share, but catches invalid shares early","Doubles the total signing time","Requires solving discrete logarithms"],correctIndex:1,difficulty:"medium",explanation:"Verification requires ~2 point multiplications per share. This is worthwhile because catching bad shares before aggregation saves having to debug failed final signatures."}],ne=[{id:1,type:"multiple-choice",question:"Why must nonces be securely deleted immediately after use in FROST?",options:["To free up memory","To make signing faster","To prevent nonce reuse which would expose the secret key","Nonces can be safely stored for later use"],correctIndex:2,difficulty:"medium",explanation:"Reusing a nonce across two signatures allows an attacker to solve for the secret key. Immediate deletion ensures a nonce is never accidentally reused."},{id:2,type:"multiple-choice",question:"What state must a FROST participant maintain between the commitment and signing rounds?",options:["No state is needed","The final signature","All other participants' private keys","The nonces $(d_i, e_i)$ corresponding to their published commitments"],correctIndex:3,difficulty:"medium",explanation:"Participants must store their secret nonces between rounds to compute their signature share. These nonces must match the commitments they broadcast."},{id:3,type:"multiple-choice",question:"What is a nonce commitment in FROST and why is it published before signing?",options:["The curve points $(D_i, E_i) = (d_i \\cdot G, e_i \\cdot G)$, to bind signers to their nonces","The encrypted nonce, to hide it from other signers","A hash of the message","The signer's public key share"],correctIndex:0,difficulty:"hard",explanation:"Publishing $D_i = d_i \\cdot G$ and $E_i = e_i \\cdot G$ commits signers to their nonces before seeing others' values, preventing adaptive attacks."},{id:4,type:"multiple-choice",question:"What security technique helps ensure nonces are deleted from memory?",options:["Using global variables","Secure memory wiping (zeroing) before deallocation","Writing nonces to disk","Using longer nonces"],correctIndex:1,difficulty:"medium",explanation:"Cryptographic libraries provide secure memory functions that explicitly overwrite sensitive data with zeros before freeing memory, preventing recovery from RAM."},{id:5,type:"multiple-choice",question:"If a signing session is aborted, what must happen to the unused nonces?",options:["They can be saved for the next session","They are automatically reused","They must be securely deleted and fresh nonces generated for retry","Nothing special is required"],correctIndex:2,difficulty:"hard",explanation:'Once commitments are broadcast, those nonces are "burned" and must never be reused, even if signing fails. Fresh nonces must be generated for any retry.'}],oe=[{id:1,type:"multiple-choice",question:"How many communication rounds does the FROST signing protocol require?",options:["One round","The number varies with the threshold","Three rounds","Two rounds (commitment broadcast, then signing)"],correctIndex:3,difficulty:"easy",explanation:"FROST uses two rounds: (1) each signer broadcasts nonce commitments, (2) each signer computes and shares their signature share after seeing all commitments."},{id:2,type:"multiple-choice",question:"What role does a coordinator play in FROST, and what can they NOT do?",options:["Coordinators aggregate messages but cannot forge signatures alone","Coordinators sign on behalf of absent participants","Coordinators hold the master secret key","Coordinators are not needed in FROST"],correctIndex:0,difficulty:"medium",explanation:"The coordinator collects commitments and shares, then aggregates the signature. They have no secret material and cannot sign without $t$ honest participants."},{id:3,type:"multiple-choice",question:"Why might FROST use authenticated channels between participants?",options:["To make communication faster","To prevent man-in-the-middle attacks that could substitute commitments","Authentication is not needed","To encrypt the final signature"],correctIndex:1,difficulty:"medium",explanation:"Authenticated channels ensure commitments genuinely come from claimed participants, preventing attackers from substituting malicious values."},{id:4,type:"multiple-choice",question:"In a peer-to-peer FROST setup without a coordinator, how do participants agree on the signing set?",options:["The first participant decides","It does not matter who participates","All participants must use a consensus protocol or predefined rules","Participants are randomly selected"],correctIndex:2,difficulty:"hard",explanation:"Without a coordinator, participants need consensus on who is signing to ensure everyone computes the same Lagrange coefficients and binding factors."},{id:5,type:"multiple-choice",question:"What happens if a participant goes offline between the commitment and signing rounds?",options:["Their commitment is automatically used","The protocol continues without them","Another participant can sign on their behalf","The signing session fails and must restart with a new signing set"],correctIndex:3,difficulty:"medium",explanation:"If a committed participant fails to provide their share, the session must abort (nonces are burned) and restart with participants who are available."}],ae=[{id:1,type:"multiple-choice",question:"What technique allows FROST to verify multiple signature shares more efficiently?",options:["Batch verification using random linear combinations","Sequential verification","Skipping verification entirely","Using smaller keys"],correctIndex:0,difficulty:"hard",explanation:"Batch verification combines multiple verification equations with random weights, checking them in one multi-scalar multiplication, which is faster than individual checks."},{id:2,type:"multiple-choice",question:"Why is the aggregation step in FROST computationally inexpensive?",options:["It requires solving discrete logarithms","It only involves adding scalars and points, not multiplications","It skips verification","It uses quantum computers"],correctIndex:1,difficulty:"medium",explanation:"Aggregating shares ($z = \\sum z_i$) and points ($R = \\sum R_i$) uses scalar and point addition, which is much faster than the scalar multiplications in signing."},{id:3,type:"multiple-choice",question:"What preprocessing technique can reduce FROST signing latency?",options:["Reducing the number of participants","Using smaller threshold values","Pre-generating and storing nonce commitments for future sessions","Using weaker hash functions"],correctIndex:2,difficulty:"medium",explanation:"Participants can pre-generate nonce pairs and distribute commitments in advance. When a signing request arrives, the first round is already complete."},{id:4,type:"multiple-choice",question:"What is the main computational bottleneck in FROST signing?",options:["Hashing the message","Memory allocation","Network communication","Scalar multiplications on the elliptic curve"],correctIndex:3,difficulty:"easy",explanation:"Elliptic curve scalar multiplication (computing $k \\cdot G$ or $k \\cdot P$) dominates FROST computation time, requiring hundreds of point operations."},{id:5,type:"multiple-choice",question:"How does multi-scalar multiplication (MSM) optimize FROST operations?",options:["By computing $\\sum a_i \\cdot P_i$ faster than individual multiplications","By using multiple processors","By reducing the key size","By eliminating the need for verification"],correctIndex:0,difficulty:"hard",explanation:"MSM algorithms like Pippenger's compute $\\sum a_i \\cdot P_i$ in sub-linear time relative to the number of terms, significantly speeding up verification and aggregation."}],se=[{id:1,type:"multiple-choice",question:"What distinguishes FROST2 from the original FROST protocol?",options:["FROST2 uses a different elliptic curve","FROST2 reduces the number of communication rounds in certain settings","FROST2 requires more participants","FROST2 eliminates the need for threshold signatures"],correctIndex:1,difficulty:"hard",explanation:"FROST2 and similar variants optimize the protocol for specific deployment scenarios, often reducing round complexity or communication overhead."},{id:2,type:"multiple-choice",question:"What is ROAST, and how does it relate to FROST?",options:["A hash function for FROST","A replacement for Schnorr signatures","A wrapper protocol that handles asynchrony and participant failures in FROST","A quantum-resistant version of FROST"],correctIndex:2,difficulty:"medium",explanation:"ROAST (Robust Asynchronous Schnorr Threshold) is a wrapper around FROST that provides robustness against Byzantine participants and network asynchrony."},{id:3,type:"multiple-choice",question:"Why might different FROST variants be needed for different applications?",options:["Different curves require different protocols","Applications cannot use threshold signatures","Only one FROST variant exists","Trade-offs between rounds, robustness, and security assumptions vary by use case"],correctIndex:3,difficulty:"medium",explanation:"Applications have different requirements: some prioritize minimal rounds (latency), others need robustness against failures, and some have specific trust assumptions."},{id:4,type:"multiple-choice",question:'What is "robustness" in the context of threshold signature schemes?',options:["The ability to complete signing even if some participants misbehave","Resistance to quantum computers","Using stronger hash functions","Having a larger key size"],correctIndex:0,difficulty:"easy",explanation:"A robust protocol can identify and exclude misbehaving participants, completing the signing with the remaining honest parties (as long as threshold is met)."},{id:5,type:"multiple-choice",question:"What is the key advantage of single-round FROST variants?",options:["They use less memory","Reduced latency by eliminating the commitment round","They work with any threshold","They do not require nonces"],correctIndex:1,difficulty:"hard",explanation:"Single-round variants (with pre-generated commitments or alternative designs) reduce signing latency, which is critical for high-frequency signing applications."}],re=[{id:1,type:"multiple-choice",question:"Why is FROST potentially vulnerable to quantum computers?",options:["Quantum computers can break hash functions","Quantum computers can guess nonces","Shor's algorithm can solve the discrete logarithm problem underlying elliptic curves","FROST uses quantum-vulnerable encryption"],correctIndex:2,difficulty:"medium",explanation:"Shor's algorithm can efficiently compute discrete logarithms, breaking the security of elliptic curve cryptography including FROST's Schnorr signatures."},{id:2,type:"multiple-choice",question:"What type of cryptography is being developed to resist quantum attacks?",options:["Longer elliptic curve keys","Double encryption","Faster classical computers","Post-quantum cryptography based on lattices, codes, or hashes"],correctIndex:3,difficulty:"easy",explanation:"Post-quantum cryptography uses mathematical problems believed to be hard for both classical and quantum computers, such as lattice-based or hash-based schemes."},{id:3,type:"multiple-choice",question:"What is a major challenge in creating post-quantum threshold signatures?",options:["Threshold versions require new protocols as the algebraic structure differs from elliptic curves","Post-quantum schemes do not support signatures","Quantum computers already exist","Hash functions are quantum-vulnerable"],correctIndex:0,difficulty:"hard",explanation:"Post-quantum schemes (like lattice-based) have different mathematical structures than elliptic curves, requiring new threshold protocol designs rather than direct FROST adaptation."},{id:4,type:"multiple-choice",question:"What timeline do cryptographers estimate for quantum computers threatening current cryptography?",options:["They already do","Estimates range from 10-30 years, but preparation should start now","Never","Within 1 year"],correctIndex:1,difficulty:"medium",explanation:"While cryptographically-relevant quantum computers are years away, the threat is taken seriously. Migration takes time, so research and preparation are ongoing."},{id:5,type:"multiple-choice",question:'What is "crypto-agility" in the context of FROST deployments?',options:["Fast signing speed","Using multiple keys simultaneously","The ability to migrate to new cryptographic primitives when needed","Agile software development for crypto"],correctIndex:2,difficulty:"medium",explanation:"Crypto-agility means designing systems that can transition to new algorithms (like post-quantum schemes) without complete redesign when threats materialize."}],ce=[{id:1,type:"multiple-choice",question:'What does "Verifiable FROST" add to the basic FROST protocol?',options:["Faster signature generation","Quantum resistance","Smaller signature sizes","Proofs that each participant performed their computation correctly"],correctIndex:3,difficulty:"medium",explanation:"Verifiable FROST provides cryptographic proofs that participants correctly followed the protocol, enabling detection of cheating beyond just invalid shares."},{id:2,type:"multiple-choice",question:"What cryptographic tool is commonly used to make secret sharing verifiable?",options:["Feldman's Verifiable Secret Sharing (VSS)","Homomorphic encryption","Digital certificates","Symmetric encryption"],correctIndex:0,difficulty:"medium",explanation:"Feldman's VSS publishes commitments to polynomial coefficients ($a_i \\cdot G$), allowing participants to verify their shares lie on the correct polynomial."},{id:3,type:"multiple-choice",question:"In Feldman VSS, what can participants verify about their share $s_i$?",options:["That it equals the secret","That $s_i \\cdot G = \\sum_{k=0}^{t-1} i^k \\cdot C_k$ where $C_k$ are published commitments","That other participants have the same share","That the share is a prime number"],correctIndex:1,difficulty:"hard",explanation:"Feldman commitments $C_k = a_k \\cdot G$ let participants verify their share: $s_i \\cdot G = \\sum_{k=0}^{t-1} i^k \\cdot C_k = f(i) \\cdot G$."},{id:4,type:"multiple-choice",question:"What is the trade-off of adding verifiability to FROST?",options:["Reduced security","Larger key sizes only","Additional computation and communication for proofs","No trade-offs exist"],correctIndex:2,difficulty:"easy",explanation:"Verifiability requires generating and checking proofs, adding computation time and communication bandwidth, but provides stronger guarantees against cheating."},{id:5,type:"multiple-choice",question:"When is Verifiable FROST particularly important?",options:["When all participants are fully trusted","When using weak hash functions","Only for very large thresholds","When participants may be malicious and accountability is required"],correctIndex:3,difficulty:"medium",explanation:"Verifiable FROST is essential in adversarial settings where participants might cheat and the system needs to identify and prove who misbehaved."}],le=[{id:1,type:"multiple-choice",question:"What is Multi-Party Computation (MPC)?",options:["Protocols allowing parties to jointly compute functions while keeping inputs private","Computing on multiple computers simultaneously","A type of encryption","Parallel processing for cryptography"],correctIndex:0,difficulty:"easy",explanation:"MPC allows multiple parties to compute a function $f(x_1, ..., x_n)$ on their private inputs, learning only the output while keeping inputs secret."},{id:2,type:"multiple-choice",question:"How does FROST relate to general MPC?",options:["FROST replaces all MPC protocols","FROST is a specialized MPC protocol optimized for Schnorr signing","MPC cannot be used for signatures","They are unrelated technologies"],correctIndex:1,difficulty:"medium",explanation:"FROST is an MPC protocol specifically designed for threshold Schnorr signatures, optimized for this use case compared to generic MPC frameworks."},{id:3,type:"multiple-choice",question:"What advantage does FROST have over general-purpose MPC for signing?",options:["FROST works with any function","General MPC is always faster","FROST is more efficient due to algebraic structure of Schnorr signatures","FROST requires no communication"],correctIndex:2,difficulty:"medium",explanation:"FROST exploits the linear structure of Schnorr signatures, requiring only 2 rounds versus the many rounds needed by generic MPC protocols."},{id:4,type:"multiple-choice",question:"What MPC technique could extend FROST to compute arbitrary functions on secret-shared data?",options:["Symmetric encryption","Public key encryption","Hash functions","Garbled circuits or secret-sharing-based MPC"],correctIndex:3,difficulty:"hard",explanation:"Garbled circuits and secret-sharing-based protocols (like SPDZ) can compute arbitrary functions, potentially integrating with FROST for more complex threshold operations."},{id:5,type:"multiple-choice",question:'What is a "threshold wallet" that might combine FROST with other MPC techniques?',options:["A wallet where $t$-of-$n$ parties must collaborate for any operation","A wallet with a maximum balance","A hardware wallet","A wallet using quantum cryptography"],correctIndex:0,difficulty:"easy",explanation:"Threshold wallets distribute control among multiple parties, using FROST for signing and potentially other MPC for key management, policy enforcement, etc."}],he=[{id:1,type:"multiple-choice",question:"How could FROST signatures be verified in a smart contract?",options:["Smart contracts cannot verify signatures","The aggregated signature is a standard Schnorr signature, verifiable on-chain","Each participant must submit their share on-chain","FROST requires off-chain verification only"],correctIndex:1,difficulty:"medium",explanation:"FROST produces a standard Schnorr signature that can be verified by any Schnorr verifier, including smart contracts, without revealing the threshold structure."},{id:2,type:"multiple-choice",question:"What advantage does FROST provide for multi-signature smart contract wallets?",options:["Larger transaction sizes","Faster block times","A single signature regardless of threshold, reducing gas costs","No verification needed"],correctIndex:2,difficulty:"medium",explanation:"Traditional multi-sig requires $t$ separate signatures on-chain. FROST produces one signature, significantly reducing transaction size and gas costs."},{id:3,type:"multiple-choice",question:"What is a DAO, and how might it use FROST?",options:["A type of cryptocurrency","A smart contract language","A consensus algorithm","A Decentralized Autonomous Organization that could use threshold signing for treasury control"],correctIndex:3,difficulty:"easy",explanation:"DAOs are blockchain-based organizations. FROST enables threshold control of DAO treasuries, requiring agreement from multiple parties for transactions."},{id:4,type:"multiple-choice",question:"What challenge exists for FROST integration with Ethereum smart contracts?",options:["Ethereum uses ECDSA natively; Schnorr verification requires additional precompiles or libraries","Ethereum does not support digital signatures","Smart contracts cannot access signatures","Ethereum blocks are too small"],correctIndex:0,difficulty:"hard",explanation:"Ethereum's native signature scheme is ECDSA. Schnorr/FROST verification requires either EIPs for precompiles or more expensive library-based verification."},{id:5,type:"multiple-choice",question:'What is "account abstraction," and how does it relate to FROST?',options:["Hiding account balances","Allowing smart contracts to define custom signature validation, enabling FROST wallets","Abstract data types in Solidity","Removing accounts from blockchains"],correctIndex:1,difficulty:"hard",explanation:"Account abstraction (ERC-4337) allows smart contract wallets to define custom signature schemes, making FROST-based threshold wallets native to the protocol."}],de=[{id:1,type:"multiple-choice",question:"What is threshold decryption?",options:["Decryption using a very long key","Decryption that takes many steps","Decryption requiring $t$-of-$n$ parties to collaborate","A type of symmetric encryption"],correctIndex:2,difficulty:"easy",explanation:"Threshold decryption distributes a decryption key among $n$ parties, requiring at least $t$ to collaborate to decrypt, similar to FROST for signing."},{id:2,type:"multiple-choice",question:"How does threshold decryption complement FROST in a complete system?",options:["They cannot be used together","They serve the same purpose","Threshold decryption replaces FROST","FROST provides threshold signing; threshold decryption provides threshold access to encrypted data"],correctIndex:3,difficulty:"medium",explanation:"Together, they enable comprehensive threshold cryptography: FROST for authentication/authorization (signing), threshold decryption for confidentiality (accessing secrets)."},{id:3,type:"multiple-choice",question:"What encryption scheme is commonly used for threshold decryption?",options:["ElGamal or threshold variants of RSA/ECIES","AES","DES","One-time pad"],correctIndex:0,difficulty:"medium",explanation:"ElGamal encryption has algebraic properties that enable efficient threshold decryption. ECIES variants and threshold RSA are also used."},{id:4,type:"multiple-choice",question:"In threshold ElGamal, what do participants provide for decryption?",options:["Their private key directly","Partial decryptions (their share applied to the ciphertext)","Random numbers","Hash values"],correctIndex:1,difficulty:"hard",explanation:"Each participant computes a partial decryption using their key share. These are combined (using Lagrange interpolation) to produce the full decryption."},{id:5,type:"multiple-choice",question:"What is a use case combining FROST signing and threshold decryption?",options:["Sending email","Web browsing","A threshold custody system where backup keys are encrypted and require threshold access","File compression"],correctIndex:2,difficulty:"medium",explanation:"Custody systems might use FROST for daily signing operations and threshold decryption to access backup keys or recovery data, both requiring multi-party agreement."}],ue=[{id:1,type:"multiple-choice",question:"What is recursive FROST?",options:["FROST that calls itself indefinitely","FROST with recursive data structures","A faster version of FROST","FROST where threshold groups can themselves be participants in larger threshold groups"],correctIndex:3,difficulty:"hard",explanation:"Recursive FROST creates hierarchical threshold structures: a $t$-of-$n$ group might include members that are themselves threshold groups, enabling complex organizational structures."},{id:2,type:"multiple-choice",question:"What organizational structure might benefit from recursive FROST?",options:["A corporation where departments are threshold groups, and the corporation is a threshold of departments","A single user with one key","A simple 2-of-3 wallet","Automated trading bots"],correctIndex:0,difficulty:"medium",explanation:"Large organizations can mirror their structure: each department is a threshold group, and major decisions require threshold agreement across departments."},{id:3,type:"multiple-choice",question:"What challenge does recursive FROST introduce compared to flat FROST?",options:["Smaller signatures","Increased coordination complexity and latency across nested groups","Reduced security","Fewer participants can be involved"],correctIndex:1,difficulty:"medium",explanation:"Recursive structures require coordination within and between groups, potentially multiplying communication rounds and requiring more sophisticated protocols."},{id:4,type:"multiple-choice",question:"From the verifier's perspective, how does a recursive FROST signature appear?",options:["As multiple separate signatures","As a larger, more complex signature","As a single standard Schnorr signature, indistinguishable from non-recursive FROST","The verifier must know the recursion depth"],correctIndex:2,difficulty:"medium",explanation:"The final aggregated signature is still a standard Schnorr signature. The recursive structure is internal to the signing process and invisible to verifiers."},{id:5,type:"multiple-choice",question:"What is a potential security consideration unique to recursive FROST?",options:["Quantum vulnerability","Nonce management is simpler","Hash function weaknesses","Compromise of an inner group's threshold affects the outer group's security"],correctIndex:3,difficulty:"hard",explanation:`If an inner threshold group is compromised (attacker controls $t$ members), they control that group's "vote" in the outer structure, potentially reaching the outer threshold.`}],pe=[{id:1,type:"multiple-choice",question:"What Bitcoin upgrade enabled Schnorr signatures, making FROST directly applicable?",options:["Taproot (BIP-340, BIP-341)","SegWit","Lightning Network","Bitcoin Cash fork"],correctIndex:0,difficulty:"easy",explanation:"Taproot, activated in November 2021, introduced BIP-340 Schnorr signatures to Bitcoin, enabling direct use of FROST for threshold Bitcoin custody."},{id:2,type:"multiple-choice",question:"How does FROST enhance Bitcoin privacy compared to traditional multisig?",options:["By encrypting transactions","FROST signatures look identical to single-key signatures on-chain","By using larger keys","By requiring more confirmations"],correctIndex:1,difficulty:"medium",explanation:"FROST produces a single Schnorr signature indistinguishable from a regular signature, hiding the threshold structure and improving privacy over exposed $m$-of-$n$ scripts."},{id:3,type:"multiple-choice",question:"What is MuSig2, and how does it relate to FROST?",options:["A different cryptocurrency","A mining algorithm","A multi-signature scheme for Bitcoin that shares design principles with FROST","A wallet software"],correctIndex:2,difficulty:"medium",explanation:"MuSig2 is a 2-round multi-signature protocol for Bitcoin. FROST generalizes to threshold signatures but shares the same cryptographic foundations."},{id:4,type:"multiple-choice",question:"What role might FROST play in Bitcoin Layer 2 solutions like Lightning?",options:["Replacing the Lightning protocol","Mining new bitcoins","Increasing block size","Enabling threshold-secured Lightning channels and watchtowers"],correctIndex:3,difficulty:"hard",explanation:"FROST could secure Lightning channels with threshold signatures, distribute watchtower operation, and enable more sophisticated channel factories."},{id:5,type:"multiple-choice",question:"What improvement does FROST bring to Bitcoin institutional custody?",options:["Flexible $t$-of-$n$ custody without on-chain complexity or fee overhead","Faster block confirmations","Higher Bitcoin prices","Reduced energy consumption"],correctIndex:0,difficulty:"easy",explanation:"Institutions can implement flexible threshold policies (e.g., 3-of-5 executives) with a single signature on-chain, reducing fees and hiding the custody structure."}],me=[{id:1,type:"multiple-choice",question:"What organization is working on FROST standardization?",options:["IEEE","IETF (Internet Engineering Task Force)","ISO","W3C"],correctIndex:1,difficulty:"easy",explanation:"The IETF CFRG (Crypto Forum Research Group) is developing standards for FROST to ensure interoperability across implementations."},{id:2,type:"multiple-choice",question:"Why is standardization important for FROST adoption?",options:["To make FROST slower","To limit who can use FROST","To ensure different implementations can interoperate securely","Standards are not important"],correctIndex:2,difficulty:"easy",explanation:"Standards define exact algorithms, serialization formats, and protocol messages, allowing different software to work together and enabling security audits."},{id:3,type:"multiple-choice",question:"What does the IETF FROST draft specify?",options:["Only the mathematical formulas","Hardware requirements","Just the hash functions","Key generation, signing protocol, ciphersuites, and wire formats"],correctIndex:3,difficulty:"medium",explanation:"The FROST draft specifies complete protocols including DKG, signing rounds, supported ciphersuites (curves + hashes), and message serialization."},{id:4,type:"multiple-choice",question:'What is a "ciphersuite" in the context of FROST standards?',options:["A specific combination of elliptic curve, hash function, and parameter choices","A hardware security module","A type of encryption","A software library"],correctIndex:0,difficulty:"medium",explanation:"A ciphersuite defines the exact cryptographic primitives (e.g., secp256k1 + SHA-256) ensuring all participants use compatible parameters."},{id:5,type:"multiple-choice",question:"What challenge exists in standardizing FROST for multiple application domains?",options:["FROST cannot be standardized","Different applications (Bitcoin, general TLS, etc.) may need different ciphersuites or protocol variants","Standards bodies disagree on mathematics","Standardization is too fast"],correctIndex:1,difficulty:"hard",explanation:"Bitcoin requires secp256k1/BIP-340 compatibility, while other applications use different curves. Standards must accommodate multiple ciphersuites and use cases."}],ge=[{id:1,type:"multiple-choice",question:"What is an open research question regarding FROST key refresh?",options:["Key refresh is fully solved","Making keys longer","Efficient proactive security: refreshing shares without changing the public key","Removing the need for keys"],correctIndex:2,difficulty:"medium",explanation:"Proactive security refreshes shares periodically so that an attacker must compromise $t$ parties simultaneously, not just over time. Efficient protocols remain an active research area."},{id:2,type:"multiple-choice",question:'What is the challenge of "dynamic groups" in threshold signatures?',options:["Groups cannot change","Dynamic groups are not useful","Making groups larger","Adding or removing participants while maintaining security properties"],correctIndex:3,difficulty:"hard",explanation:"Changing the participant set ($n$) or threshold ($t$) requires protocols to redistribute shares securely, ideally without revealing the secret or requiring trusted parties."},{id:3,type:"multiple-choice",question:'What makes FROST resistant to "adaptive" adversaries an open problem?',options:["Proving security when adversary can corrupt parties based on protocol messages","Adaptive adversaries do not exist","The protocol is already proven secure","Adaptive security is not important"],correctIndex:0,difficulty:"hard",explanation:"Adaptive security considers adversaries who choose whom to corrupt based on observed protocol execution. Proving FROST secure in this model is more challenging."},{id:4,type:"multiple-choice",question:"What research direction aims to reduce FROST communication complexity?",options:["Using slower networks","Aggregatable signatures and more efficient broadcast protocols","Removing participants","Using longer messages"],correctIndex:1,difficulty:"medium",explanation:"Research explores reducing the $O(n^2)$ communication in some settings through more efficient aggregation, gossip protocols, or structured communication patterns."},{id:5,type:"multiple-choice",question:"Why is formal verification of FROST implementations an important research area?",options:["To make FROST slower","Formal verification is outdated","To mathematically prove implementations match security specifications","To reduce code size"],correctIndex:2,difficulty:"medium",explanation:"Formal verification uses mathematical proofs to ensure implementations correctly follow specifications, catching subtle bugs that testing might miss in security-critical code."}],fe=[{id:1,type:"multiple-choice",question:"What fundamental mathematical insight enables FROST's threshold property?",options:["Prime factorization is hard","Elliptic curves have no solutions","Hash functions are one-way","Polynomial interpolation: $t$ points determine a degree $t-1$ polynomial"],correctIndex:3,difficulty:"medium",explanation:"Shamir's secret sharing uses polynomial interpolation: any $t$ points on a degree $t-1$ polynomial determine it uniquely, but $t-1$ points reveal nothing."},{id:2,type:"multiple-choice",question:"What societal problem does FROST address?",options:["The concentration of trust and single points of failure","Slow computers","Expensive electricity","Complex mathematics"],correctIndex:0,difficulty:"easy",explanation:"FROST distributes trust across multiple parties, eliminating single points of failure where one person or system can act unilaterally or be compromised."},{id:3,type:"multiple-choice",question:'How does FROST embody the principle of "trust minimization"?',options:["By requiring trust in a central authority","By reducing trust assumptions: no single party can sign or recover the key","By using trusted hardware","By trusting mathematics is wrong"],correctIndex:1,difficulty:"medium",explanation:"FROST minimizes trust by distributing the secret. Security relies on the assumption that fewer than $t$ parties are compromised, not on trusting any single entity."},{id:4,type:"multiple-choice",question:"What does FROST demonstrate about the relationship between mathematics and security?",options:["Mathematics is unnecessary for security","Security requires physical measures only","Mathematical structures (polynomials, groups) directly enable security guarantees","Mathematics makes systems less secure"],correctIndex:2,difficulty:"easy",explanation:"FROST shows how abstract mathematics (polynomial interpolation, elliptic curve groups) translates directly into practical security guarantees for real-world systems."},{id:5,type:"multiple-choice",question:"What is the enduring lesson from FROST for building trustworthy systems?",options:["Trust a single authority completely","Security is impossible","Avoid using mathematics","Distribute trust, verify cryptographically, and design for adversarial environments"],correctIndex:3,difficulty:"medium",explanation:"FROST teaches that security comes from distributing trust (threshold), cryptographic verification (Schnorr proofs), and assuming adversaries exist (Byzantine tolerance)."}],$e={0:i,1:t,2:n,3:o,4:a,5:s,6:r,7:c,8:l,9:h,10:d,11:u,12:p,13:m,14:g,15:f,16:$,17:y,18:b,19:v,20:_,21:x,22:w,23:T,24:k,25:S,26:q,27:R,28:I,29:F,30:O,31:z,32:W,33:A,34:G,35:B,36:L,37:C,38:D,39:P,40:E,41:H,42:j,43:Y,44:Q,45:M,46:N,47:U,48:V,49:K,50:Z,51:X,52:J,53:ee,54:ie,55:te,56:ne,57:oe,58:ae,59:se,60:re,61:ce,62:le,63:he,64:de,65:ue,66:pe,67:me,68:ge,69:fe};function ye(e){return $e[e]??null}export{ye as g};
