import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as c}from"./LessonLayout-sKo1Ukyt.js";import{D as r,E as n,C as l,T as t}from"./Callout-D6GJ8KQY.js";import{M as i,I as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-LWQys88K.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-ySXQbKre.js";function g(){return e.jsxs(c,{sectionId:37,children:[e.jsx("h2",{children:"Why Forking Works"}),e.jsx("p",{children:"The forking lemma is a powerful tool in cryptographic proofs. Let's understand why running a forger twice with different random oracle outputs allows us to extract secrets."}),e.jsx("h3",{children:"The Core Insight"}),e.jsx(r,{title:"Random Oracle Control",children:e.jsx("p",{children:'In the random oracle model, the simulator controls hash function outputs. This gives us a crucial capability: we can "rewind" the forger and give it a different answer to the same hash query.'})}),e.jsxs(n,{title:"The Setup",children:[e.jsx("p",{children:"Suppose the forger produces a valid signature:"}),e.jsx(i,{children:"\\sigma = (R, z) \\text{ for message } m"}),e.jsx("p",{className:"mt-3",children:"The forger queried:"}),e.jsx(i,{children:"c = H_2(R, Y, m)"}),e.jsx("p",{className:"mt-3",children:"And computed a valid response:"}),e.jsx(i,{children:"z = k + s \\cdot c"})]}),e.jsx("h3",{children:"The Forking Technique"}),e.jsx(r,{title:"First Execution",children:e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:["Run forger ",e.jsx(s,{children:"\\mathcal{F}"})," with random tape"," ",e.jsx(s,{children:"\\rho"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"\\mathcal{F}"})," makes hash queries"," ",e.jsx(s,{children:"q_1, q_2, \\ldots, q_n"})]}),e.jsxs("li",{children:["At query ",e.jsx(s,{children:"q_i = (R, Y, m)"}),", return"," ",e.jsx(s,{children:"c"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"\\mathcal{F}"})," outputs forgery"," ",e.jsx(s,{children:"(R, z, m)"})]})]})}),e.jsx(r,{title:"Second Execution (Fork)",children:e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:["Run forger ",e.jsx(s,{children:"\\mathcal{F}"})," with"," ",e.jsx("strong",{children:"same"})," random tape ",e.jsx(s,{children:"\\rho"})]}),e.jsxs("li",{children:["Answer queries ",e.jsx(s,{children:"q_1, \\ldots, q_{i-1}"})," identically"]}),e.jsxs("li",{children:["At query ",e.jsx(s,{children:"q_i = (R, Y, m)"}),", return"," ",e.jsx("strong",{children:"different"})," ",e.jsx(s,{children:"c' \\neq c"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"\\mathcal{F}"})," outputs forgery"," ",e.jsx(s,{children:"(R, z', m)"})]})]})}),e.jsxs(l,{type:"info",children:[e.jsx("strong",{children:"Key Observation:"})," Because we used the same random tape"," ",e.jsx(s,{children:"\\rho"})," and answered earlier queries identically, the forger follows the same execution path until the fork point. This means"," ",e.jsx(s,{children:"R"})," is the same in both executions!"]}),e.jsx("h3",{children:"The Extraction"}),e.jsxs(t,{title:"Secret Extraction",children:[e.jsxs("p",{children:["With two valid signatures for the same ",e.jsx(s,{children:"R"}),":"]}),e.jsx(i,{children:"z = k + s \\cdot c"}),e.jsx(i,{children:"z' = k + s \\cdot c'"}),e.jsxs("p",{className:"mt-3",children:["Subtract to eliminate ",e.jsx(s,{children:"k"}),":"]}),e.jsx(i,{children:"z - z' = s \\cdot (c - c')"}),e.jsxs("p",{className:"mt-3",children:["Since ",e.jsx(s,{children:"c \\neq c'"}),", we can divide:"]}),e.jsx(i,{children:"s = \\frac{z - z'}{c - c'} \\pmod{q}"})]}),e.jsxs(n,{title:"Concrete Numbers",children:[e.jsx("p",{children:"Suppose:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["First execution: ",e.jsx(s,{children:"c = 7, z = 150"})]}),e.jsxs("li",{children:["Second execution: ",e.jsx(s,{children:"c' = 11, z' = 178"})]})]}),e.jsx("p",{className:"mt-3",children:"Then:"}),e.jsx(i,{children:"s = \\frac{178 - 150}{11 - 7} = \\frac{28}{4} = 7"}),e.jsxs("p",{className:"mt-3",children:["We've extracted the secret ",e.jsx(s,{children:"s = 7"}),"!"]})]}),e.jsx("h3",{children:"The Forking Lemma"}),e.jsxs(t,{title:"General Forking Lemma (Bellare-Neven)",children:[e.jsxs("p",{children:["If forger ",e.jsx(s,{children:"\\mathcal{F}"})," succeeds with probability"," ",e.jsx(s,{children:"\\varepsilon"})," after making at most"," ",e.jsx(s,{children:"q"})," random oracle queries, then the probability of obtaining two useful forgeries via forking is at least:"]}),e.jsx(i,{children:"\\text{frk} \\geq \\varepsilon \\left( \\frac{\\varepsilon}{q} - \\frac{1}{|H|} \\right)"}),e.jsxs("p",{className:"mt-3",children:["where ",e.jsx(s,{children:"|H|"})," is the size of the hash output space."]}),e.jsxs("p",{className:"mt-3",children:["For large ",e.jsx(s,{children:"|H|"})," (like ",e.jsx(s,{children:"2^{256}"}),"), this simplifies to approximately:"]}),e.jsx(i,{children:"\\text{frk} \\geq \\frac{\\varepsilon^2}{q}"})]}),e.jsx("h3",{children:"Why Same Randomness Matters"}),e.jsxs(r,{title:"Deterministic Execution",children:[e.jsxs("p",{children:["Using the same random tape ",e.jsx(s,{children:"\\rho"})," ensures:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsx("li",{children:"Same internal randomness for the forger"}),e.jsxs("li",{children:["Same commitment ",e.jsx(s,{children:"R"})," chosen"]}),e.jsxs("li",{children:["Same message ",e.jsx(s,{children:"m"})," targeted"]}),e.jsx("li",{children:"Same query sequence until the fork"})]}),e.jsxs("p",{className:"mt-3",children:["Without identical randomness, we might get different ",e.jsx(s,{children:"R"})," ","values, making extraction impossible."]})]}),e.jsx("h3",{children:"Application to FROST"}),e.jsxs(n,{title:"FROST Context",children:[e.jsx("p",{children:"In FROST's security proof:"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:["The group public key ",e.jsx(s,{children:"Y"})," contains the embedded DL challenge"]}),e.jsxs("li",{children:['When forger creates a forgery, it implicitly "knows"'," ",e.jsx(s,{children:"s"})]}),e.jsxs("li",{children:["Forking extracts ",e.jsx(s,{children:"s"})," explicitly"]}),e.jsxs("li",{children:["From ",e.jsx(s,{children:"s"}),", we can solve the original DL challenge"]})]})]}),e.jsxs(l,{type:"success",children:[e.jsx("strong",{children:"The Power of Rewinding:"})," The forking lemma transforms a cryptographic attack into a mathematical extraction tool. If anyone can forge signatures, we can use their attack to solve discrete logarithms - which we believe is impossible. Therefore, forgery must also be impossible."]}),e.jsx("h3",{children:"Limitations"}),e.jsxs(r,{title:"When Forking Fails",children:[e.jsx("p",{children:"The forking technique has limitations:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Probability loss:"})," Success probability degrades to"," ",e.jsx(s,{children:"\\varepsilon^2/q"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Query bound:"})," Need to know when the critical query occurs"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Requires rewinding:"})," Not applicable to some security models"]})]})]}),e.jsx("p",{children:"Despite these limitations, the forking lemma provides a rigorous foundation for proving FROST's security, connecting its hardness directly to the discrete logarithm problem."})]})}export{g as default};
