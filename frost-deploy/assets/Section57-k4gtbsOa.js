import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as t}from"./LessonLayout-WO30R0_w.js";import{D as s,C as r,E as i}from"./Callout-D6GJ8KQY.js";import"./vendor-react-Drj8qL0h.js";import"./vendor-math-p018AHG0.js";import"./index-CKqQQJMA.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DiUM9hDs.js";function p(){return e.jsxs(t,{sectionId:57,children:[e.jsx("h2",{children:"Communication Protocol Design"}),e.jsx("p",{children:"FROST requires a well-designed communication protocol for participants to exchange messages securely. The protocol must handle authentication, replay protection, and proper message serialization."}),e.jsx("h3",{children:"Message Types"}),e.jsxs(s,{title:"FROST Protocol Messages",children:[e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`DKG_ROUND1:    { i, commitments, proof }
DKG_ROUND2:    { i, { j: share_j } for each j }
PREPROCESS:    { i, [(D_ij, E_ij)] for each j }
SIGN_REQUEST:  { m, B }
SIGN_RESPONSE: { i, z_i }
SIGNATURE:     { R, z }`}),e.jsx("p",{className:"mt-4",children:"Each message type serves a specific purpose in the protocol and requires different handling."})]}),e.jsx("h3",{children:"Serialization Formats"}),e.jsx("p",{children:"Several serialization formats are appropriate for FROST:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 my-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Protocol Buffers:"})," Efficient binary format with strong typing"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"CBOR:"})," Compact Binary Object Representation, standardized and self-describing"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"JSON:"})," Human-readable, useful for debugging but less efficient"]})]}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Interoperability:"})," The IETF RFC 9591 specifies exact serialization formats for interoperable implementations. Custom implementations should follow the standard to enable cross-implementation compatibility."]}),e.jsx("h3",{children:"Message Authentication"}),e.jsx("p",{children:"Each message must be authenticated to prevent tampering and verify the sender:"}),e.jsx(i,{title:"Authenticated Message Format",children:e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`msg = { payload }
signature = Sign(sk_i, payload)
send(msg || signature)

# Receiver:
verify(pk_i, msg.payload, signature)
if !valid:
    reject message`})}),e.jsx(s,{title:"Authentication Requirements",children:e.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[e.jsx("li",{children:"All participants must know each other's public keys before the protocol starts"}),e.jsx("li",{children:"Messages include the sender's identity for routing and verification"}),e.jsx("li",{children:"Authentication may use the FROST key shares themselves or separate identity keys"})]})}),e.jsx("h3",{children:"Replay Protection"}),e.jsx("p",{children:"Replay attacks occur when an attacker captures a valid message and resends it later. Protection requires including context that makes each message unique:"}),e.jsxs(i,{title:"Replay-Protected Messages",children:[e.jsx("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto",children:`msg = {
    seq_num: monotonically_increasing_counter,
    session_id: unique_per_signing_session,
    payload: actual_message_content
}`}),e.jsx("p",{className:"mt-3",children:"The receiver tracks the highest sequence number seen from each sender and rejects any message with a lower or equal sequence number."})]}),e.jsx("h3",{children:"Channel Security"}),e.jsxs(r,{type:"warning",children:[e.jsx("strong",{children:"Confidentiality Requirements:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-1 mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"DKG_ROUND2:"})," Contains secret shares, MUST be encrypted point-to-point"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"SIGN_RESPONSE:"})," Contains signature shares, should be encrypted to prevent aggregation by unauthorized parties"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Public messages:"})," DKG_ROUND1, PREPROCESS, and final SIGNATURE can be broadcast"]})]})]}),e.jsx("h3",{children:"Communication Topology"}),e.jsxs(s,{title:"Network Models",children:[e.jsx("p",{children:"FROST can operate under different network assumptions:"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Star topology:"})," All messages go through coordinator (simpler, single point of failure)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Mesh topology:"})," Participants communicate directly (more robust, more complex)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Broadcast channel:"})," Public messages visible to all (simplest for public data)"]})]})]}),e.jsx("h3",{children:"Error Handling"}),e.jsx(i,{title:"Protocol Error Responses",children:e.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Invalid signature:"})," Reject message, log sender for potential exclusion"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Missing message:"})," Request retransmission with timeout"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Out-of-order message:"})," Buffer or reject depending on message type"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Duplicate message:"})," Ignore (idempotent processing)"]})]})})]})}export{p as default};
