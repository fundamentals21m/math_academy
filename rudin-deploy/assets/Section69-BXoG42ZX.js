import{j as i}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as a,C as n,T as t,E as r}from"./Callout-BUax-pNp.js";import{I as e,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-BwbehMKc.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-DMmzC0sd.js";function f(){return i.jsxs(h,{sectionId:69,children:[i.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"Primitive Mappings"}),i.jsx("p",{className:"mb-4",children:"This section introduces the concept of primitive mappings, which are building blocks for understanding the change of variables formula in multiple integrals. A primitive mapping changes only one coordinate at a time while preserving the others, making the analysis of more general transformations tractable."}),i.jsxs(a,{title:"10.5 - Primitive Mapping",children:[i.jsxs("p",{className:"mb-3",children:["A ",i.jsx(e,{children:"\\mathscr{C}^1"})," mapping ",i.jsx(e,{children:"\\mathbf{G}: E \\to \\mathbb{R}^n"}),"(where ",i.jsx(e,{children:"E \\subset \\mathbb{R}^n"})," is open) is called ",i.jsx("em",{children:"primitive"})," if there exists an index ",i.jsx(e,{children:"m"})," (",i.jsx(e,{children:"1 \\leq m \\leq n"}),") such that"]}),i.jsx(s,{children:"\\mathbf{G}(\\mathbf{x}) = (x_1, \\ldots, x_{m-1}, g_m(\\mathbf{x}), x_{m+1}, \\ldots, x_n)"}),i.jsxs("p",{className:"mt-3",children:["where ",i.jsx(e,{children:"g_m: E \\to \\mathbb{R}"})," is a ",i.jsx(e,{children:"\\mathscr{C}^1"})," function. In other words, ",i.jsx(e,{children:"\\mathbf{G}"})," changes only the ",i.jsx(e,{children:"m"}),"-th coordinate."]})]}),i.jsxs(n,{type:"info",children:[i.jsxs("p",{className:"mb-3",children:["The Jacobian of a primitive mapping ",i.jsx(e,{children:"\\mathbf{G}"})," is particularly simple. If ",i.jsx(e,{children:"\\mathbf{G}"})," changes only the ",i.jsx(e,{children:"m"}),"-th coordinate:"]}),i.jsx(s,{children:"\\det(\\mathbf{G}'(\\mathbf{x})) = D_m g_m(\\mathbf{x}) = \\frac{\\partial g_m}{\\partial x_m}(\\mathbf{x})"}),i.jsxs("p",{children:["because the Jacobian matrix is the identity except in the ",i.jsx(e,{children:"m"}),"-th row."]})]}),i.jsxs(t,{title:"10.6 - Factorization into Primitive Mappings",proof:i.jsxs(i.Fragment,{children:[i.jsxs("p",{className:"mb-3",children:[i.jsx("strong",{children:"Step 1:"})," By the inverse function theorem, ",i.jsx(e,{children:"\\mathbf{G}"}),"is a local diffeomorphism near ",i.jsx(e,{children:"\\mathbf{0}"}),"."]}),i.jsxs("p",{className:"mb-3",children:[i.jsx("strong",{children:"Step 2:"}),' We construct the primitive mappings inductively. The idea is to "correct" one coordinate at a time.']}),i.jsxs("p",{className:"mb-3",children:[i.jsx("strong",{children:"For n = 2:"})," Suppose ",i.jsx(e,{children:"\\mathbf{G}(x, y) = (g_1(x, y), g_2(x, y))"}),"with ",i.jsx(e,{children:"\\mathbf{G}(0, 0) = (0, 0)"})," and ",i.jsx(e,{children:"\\mathbf{G}'(0, 0) = I"}),"."]}),i.jsxs("p",{className:"mb-3",children:["Since ",i.jsx(e,{children:"D_1 g_1(0, 0) = 1 \\neq 0"}),", the implicit function theorem says we can solve ",i.jsx(e,{children:"g_1(x, y) = u"})," for ",i.jsx(e,{children:"x = \\alpha(u, y)"})," near the origin."]}),i.jsxs("p",{className:"mb-3",children:["Define ",i.jsx(e,{children:"\\mathbf{G}_1(x, y) = (g_1(x, y), y)"}),". This is primitive, and",i.jsx(e,{children:"\\mathbf{G}_1^{-1}(u, v) = (\\alpha(u, v), v)"}),"."]}),i.jsxs("p",{className:"mb-3",children:["Define ",i.jsx(e,{children:"\\mathbf{G}_2 = \\mathbf{G} \\circ \\mathbf{G}_1^{-1}"}),". Then",i.jsx(e,{children:"\\mathbf{G}_2(u, v) = (u, g_2(\\alpha(u, v), v))"}),", which is primitive (changes only the second coordinate)."]}),i.jsxs("p",{children:["Thus ",i.jsx(e,{children:"\\mathbf{G} = \\mathbf{G}_2 \\circ \\mathbf{G}_1"}),". The general case proceeds by induction on ",i.jsx(e,{children:"n"}),"."]})]}),children:[i.jsxs("p",{className:"mb-3",children:["Suppose ",i.jsx(e,{children:"\\mathbf{G}: E \\to \\mathbb{R}^n"})," is a ",i.jsx(e,{children:"\\mathscr{C}^1"})," mapping with ",i.jsx(e,{children:"\\mathbf{G}(\\mathbf{0}) = \\mathbf{0}"})," and ",i.jsx(e,{children:"\\mathbf{G}'(\\mathbf{0}) = I"}),"(the identity matrix)."]}),i.jsxs("p",{className:"mb-3",children:["Then in a neighborhood of ",i.jsx(e,{children:"\\mathbf{0}"}),", there exist primitive mappings",i.jsx(e,{children:"\\mathbf{G}_1, \\ldots, \\mathbf{G}_n"})," such that"]}),i.jsx(s,{children:"\\mathbf{G} = \\mathbf{G}_n \\circ \\mathbf{G}_{n-1} \\circ \\cdots \\circ \\mathbf{G}_1"})]}),i.jsxs(r,{title:"10.7 - Factoring a 2D Mapping",children:[i.jsxs("p",{className:"mb-3",children:["Consider the polar-to-Cartesian map (after shifting to make the derivative identity at origin): Let ",i.jsx(e,{children:"\\mathbf{G}(u, v) = ((1+u)\\cos(v) - 1, (1+u)\\sin(v))"})," near ",i.jsx(e,{children:"(0, 0)"}),"."]}),i.jsxs("p",{className:"mb-3",children:["At ",i.jsx(e,{children:"(0, 0)"}),": ",i.jsx(e,{children:"\\mathbf{G}(0, 0) = (0, 0)"})," and"]}),i.jsx(s,{children:"\\mathbf{G}'(0, 0) = \\begin{pmatrix} \\cos(0) & -(1+0)\\sin(0) \\\\ \\sin(0) & (1+0)\\cos(0) \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}"}),i.jsxs("p",{className:"mb-3",children:["By the theorem, ",i.jsx(e,{children:"\\mathbf{G}"})," factors into two primitive mappings near the origin."]}),i.jsxs("p",{className:"mb-3",children:[i.jsx(e,{children:"\\mathbf{G}_1(u, v) = ((1+u)\\cos(v) - 1, v)"})," changes only the first coordinate."]}),i.jsxs("p",{children:[i.jsx(e,{children:"\\mathbf{G}_2"})," is determined by ",i.jsx(e,{children:"\\mathbf{G} = \\mathbf{G}_2 \\circ \\mathbf{G}_1"}),"."]})]}),i.jsxs(a,{title:"10.8 - Flips",children:[i.jsxs("p",{className:"mb-3",children:["A ",i.jsx("em",{children:"flip"})," is a linear mapping that interchanges two coordinates:"]}),i.jsx(s,{children:"B(x_1, \\ldots, x_i, \\ldots, x_j, \\ldots, x_n) = (x_1, \\ldots, x_j, \\ldots, x_i, \\ldots, x_n)"}),i.jsxs("p",{className:"mt-3",children:["A flip has determinant ",i.jsx(e,{children:"-1"})," (it's an odd permutation). Flips are useful for reordering coordinates to put a nonzero partial derivative in the right position."]})]}),i.jsxs(t,{title:"10.9 - General Factorization",proof:i.jsxs(i.Fragment,{children:[i.jsxs("p",{className:"mb-3",children:[i.jsx("strong",{children:"Step 1:"})," If ",i.jsx(e,{children:"\\mathbf{G}'(\\mathbf{a})"})," is invertible, use the inverse function theorem to get local invertibility."]}),i.jsxs("p",{className:"mb-3",children:[i.jsx("strong",{children:"Step 2:"})," Compose with linear maps (including flips) to normalize:"]}),i.jsx(s,{children:"\\tilde{\\mathbf{G}} = \\mathbf{G}'(\\mathbf{a})^{-1} \\circ \\mathbf{G} \\circ (\\mathbf{x} \\mapsto \\mathbf{x} - \\mathbf{a}) + \\mathbf{a}"}),i.jsxs("p",{className:"mb-3",children:["This gives ",i.jsx(e,{children:"\\tilde{\\mathbf{G}}(\\mathbf{a}) = \\mathbf{a}"})," and",i.jsx(e,{children:"\\tilde{\\mathbf{G}}'(\\mathbf{a}) = I"}),"."]}),i.jsxs("p",{children:[i.jsx("strong",{children:"Step 3:"})," Apply Theorem 10.6 to factor ",i.jsx(e,{children:"\\tilde{\\mathbf{G}}"}),"into primitive mappings, then express ",i.jsx(e,{children:"\\mathbf{G}"})," accordingly."]})]}),children:[i.jsxs("p",{className:"mb-3",children:["Suppose ",i.jsx(e,{children:"\\mathbf{G}: E \\to \\mathbb{R}^n"})," is ",i.jsx(e,{children:"\\mathscr{C}^1"})," and",i.jsx(e,{children:"\\det(\\mathbf{G}'(\\mathbf{a})) \\neq 0"})," at some point ",i.jsx(e,{children:"\\mathbf{a} \\in E"}),"."]}),i.jsxs("p",{className:"mb-3",children:["Then in a neighborhood of ",i.jsx(e,{children:"\\mathbf{a}"}),", ",i.jsx(e,{children:"\\mathbf{G}"})," can be written as a composition"]}),i.jsx(s,{children:"\\mathbf{G} = \\mathbf{G}_N \\circ \\cdots \\circ \\mathbf{G}_1"}),i.jsxs("p",{children:["where each ",i.jsx(e,{children:"\\mathbf{G}_j"})," is either a primitive mapping or a flip."]})]}),i.jsxs(n,{type:"info",title:"Why Primitive Mappings Matter",children:[i.jsxs("p",{className:"mb-3",children:["The factorization into primitive mappings is the key to proving the change of variables formula. For a primitive mapping that changes only the ",i.jsx(e,{children:"m"}),"-th coordinate:"]}),i.jsx(s,{children:"\\int_{\\mathbf{G}(E)} f = \\int_E (f \\circ \\mathbf{G}) |D_m g_m|"}),i.jsx("p",{className:"mb-3",children:"This is essentially a one-variable substitution. By composing such mappings, we obtain the full change of variables formula with the Jacobian determinant."})]}),i.jsxs(r,{title:"10.10 - Change of Variables Preview",children:[i.jsxs("p",{className:"mb-3",children:["Consider transforming from Cartesian ",i.jsx(e,{children:"(x, y)"})," to polar ",i.jsx(e,{children:"(r, \\theta)"}),"coordinates: ",i.jsx(e,{children:"x = r\\cos\\theta"}),", ",i.jsx(e,{children:"y = r\\sin\\theta"}),"."]}),i.jsx("p",{className:"mb-3",children:"The Jacobian is:"}),i.jsx(s,{children:"\\frac{\\partial(x, y)}{\\partial(r, \\theta)} = \\det \\begin{pmatrix} \\cos\\theta & -r\\sin\\theta \\\\ \\sin\\theta & r\\cos\\theta \\end{pmatrix} = r"}),i.jsx("p",{className:"mb-3",children:"The change of variables formula gives:"}),i.jsx(s,{children:"\\int \\int_R f(x, y) \\, dx \\, dy = \\int \\int_S f(r\\cos\\theta, r\\sin\\theta) \\cdot r \\, dr \\, d\\theta"}),i.jsxs("p",{children:["The factor ",i.jsx(e,{children:"r"})," is the absolute value of the Jacobian determinant. This arises from composing the primitive mappings in the factorization."]})]}),i.jsxs(t,{title:"10.11 - Change of Variables for Primitive Mappings",proof:i.jsxs(i.Fragment,{children:[i.jsxs("p",{className:"mb-3",children:["Since ",i.jsx(e,{children:"\\mathbf{G}"})," changes only the ",i.jsx(e,{children:"m"}),"-th coordinate, we can apply Fubini's theorem and reduce to the one-variable substitution formula."]}),i.jsxs("p",{className:"mb-3",children:["For fixed ",i.jsx(e,{children:"(x_1, \\ldots, x_{m-1}, x_{m+1}, \\ldots, x_n)"}),", the mapping",i.jsx(e,{children:"x_m \\mapsto g_m(x_1, \\ldots, x_n)"})," is a one-variable change of coordinates."]}),i.jsx("p",{className:"mb-3",children:"By the one-variable substitution rule:"}),i.jsx(s,{children:"\\int f(\\ldots, g_m(\\mathbf{x}), \\ldots) |D_m g_m(\\mathbf{x})| \\, dx_m = \\int f(\\ldots, y_m, \\ldots) \\, dy_m"}),i.jsx("p",{children:"Integrating over the remaining variables using Fubini gives the result."})]}),children:[i.jsxs("p",{className:"mb-3",children:["Let ",i.jsx(e,{children:"\\mathbf{G}"})," be a primitive mapping changing only the ",i.jsx(e,{children:"m"}),"-th coordinate, with ",i.jsx(e,{children:"D_m g_m \\neq 0"}),". For an integrable function ",i.jsx(e,{children:"f"}),":"]}),i.jsx(s,{children:"\\int_{\\mathbf{G}(E)} f(\\mathbf{y}) \\, d\\mathbf{y} = \\int_E f(\\mathbf{G}(\\mathbf{x})) |D_m g_m(\\mathbf{x})| \\, d\\mathbf{x}"})]}),i.jsx("h3",{className:"text-xl font-semibold mt-8 mb-4",children:"Key Takeaways"}),i.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[i.jsxs("li",{children:["A primitive mapping changes only one coordinate: ",i.jsx(e,{children:"\\mathbf{G}(\\mathbf{x}) = (x_1, \\ldots, g_m(\\mathbf{x}), \\ldots, x_n)"})]}),i.jsxs("li",{children:["Its Jacobian is simply ",i.jsx(e,{children:"D_m g_m"}),", the partial derivative with respect to that coordinate"]}),i.jsx("li",{children:"Any smooth diffeomorphism factors locally into primitive mappings (and flips)"}),i.jsx("li",{children:"This factorization reduces multivariable substitution to repeated one-variable substitutions"}),i.jsx("li",{children:"The change of variables formula builds from the primitive case to the general case"}),i.jsx("li",{children:"Flips account for sign changes in the Jacobian determinant"})]})]})}export{f as default};
