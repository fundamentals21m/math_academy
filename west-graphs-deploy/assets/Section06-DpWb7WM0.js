import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as n,D as r,E as i,T as s}from"./ContentBlocks-BAFtEaU8.js";import{I as t,M as a}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function j(){return e.jsxs(n,{sectionId:6,children:[e.jsxs("p",{children:["There are ",e.jsx(t,{math:"2^{\\binom{n}{2}}"})," simple graphs with vertex set"," ",e.jsx(t,{math:"[n] = \\{1, \\ldots, n\\}"}),", since each pair may or may not form an edge. How many of these are trees? In this section, we solve this counting problem, count spanning trees in arbitrary graphs, and discuss several applications."]}),e.jsx("h2",{children:"Enumeration of Trees"}),e.jsxs("p",{children:["With one or two vertices, only one tree can be formed. With three vertices there is still only one isomorphism class, but the adjacency matrix is determined by which vertex is the center. Thus there are ",e.jsx("strong",{children:"three"})," trees with vertex set ",e.jsx(t,{math:"[3]"}),". With vertex set ",e.jsx(t,{math:"[4]"}),", there are 4 stars and 12 paths, yielding ",e.jsx("strong",{children:"16"})," trees. With vertex set ",e.jsx(t,{math:"[5]"}),", a careful study yields ",e.jsx("strong",{children:"125"})," trees."]}),e.jsxs("p",{children:["Now we may see a pattern: ",e.jsx(t,{math:"3 = 3^1"}),","," ",e.jsx(t,{math:"16 = 4^2"}),", ",e.jsx(t,{math:"125 = 5^3"}),". With vertex set"," ",e.jsx(t,{math:"[n]"}),", there are ",e.jsx(t,{math:"n^{n-2}"})," trees. This is"," ",e.jsx("strong",{children:"Cayley's Formula"}),"."]}),e.jsx("h3",{children:"The Prüfer Code"}),e.jsxs("p",{children:["We present a bijective proof: establishing a one-to-one correspondence between the set of trees with vertex set ",e.jsx(t,{math:"[n]"})," and a set of known size. Given a set ",e.jsx(t,{math:"S"})," of ",e.jsx(t,{math:"n"})," numbers, there are exactly ",e.jsx(t,{math:"n^{n-2}"})," ways to form a list of length"," ",e.jsx(t,{math:"n-2"})," with entries in ",e.jsx(t,{math:"S"}),"."]}),e.jsxs(r,{title:"Prüfer Code Algorithm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," A tree ",e.jsx(t,{math:"T"})," with vertex set"," ",e.jsx(t,{math:"S \\subseteq \\mathbb{N}"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Iteration:"})," At the ",e.jsx(t,{math:"i"}),"th step, delete the least remaining leaf, and let ",e.jsx(t,{math:"a_i"})," be the neighbor of this leaf."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Output:"})," The list"," ",e.jsx(t,{math:"f(T) = (a_1, \\ldots, a_{n-2})"}),"."]})]}),e.jsxs(i,{title:"Computing the Prüfer Code",children:[e.jsxs("p",{children:["Consider a tree on vertices ",e.jsx(t,{math:"\\{1, 2, 3, 4, 5, 6, 7, 8\\}"})," ","with structure: ",e.jsx(t,{math:"2-7-1-8"})," as a path, with"," ",e.jsx(t,{math:"6"})," attached to ",e.jsx(t,{math:"7"}),","," ",e.jsx(t,{math:"4"})," attached to ",e.jsx(t,{math:"1"}),", and"," ",e.jsx(t,{math:"3, 5"})," attached to ",e.jsx(t,{math:"4"}),"."]}),e.jsxs("p",{children:["The least leaf is 2; we delete it and record 7. After deleting 3 and 5 and recording 4 each time, the least leaf in the remaining 5-vertex tree is 4. The full code is ",e.jsx(t,{math:"(7, 4, 4, 1, 7, 1)"}),", and the vertices remaining at the end are 1 and 8."]})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Recovering the tree from the code:"})," If we know the vertex set"," ",e.jsx(t,{math:"S"}),", we can retrieve the tree from the code"," ",e.jsx(t,{math:"a"}),". At each step, the least element of"," ",e.jsx(t,{math:"S"})," not appearing in the remaining code is the next leaf to add. We connect it to the next entry in the code."]}),e.jsxs(s,{title:"Cayley's Formula (Theorem 2.2.3)",children:[e.jsxs("p",{children:["For a set ",e.jsx(t,{math:"S \\subseteq \\mathbb{N}"})," of size"," ",e.jsx(t,{math:"n"}),", there are ",e.jsx(t,{math:"n^{n-2}"})," trees with vertex set ",e.jsx(t,{math:"S"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof (Prüfer [1918])"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["This holds for ",e.jsx(t,{math:"n = 1"}),", so assume"," ",e.jsx(t,{math:"n \\geq 2"}),". We prove that the Prüfer algorithm defines a bijection from the set of trees with vertex set ",e.jsx(t,{math:"S"})," ","to the set ",e.jsx(t,{math:"S^{n-2}"})," of lists of length"," ",e.jsx(t,{math:"n-2"})," from ",e.jsx(t,{math:"S"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Key observation:"})," Computing ",e.jsx(t,{math:"f(T)"})," ","reduces each vertex to degree 1 and then possibly deletes it. Thus every non-leaf vertex in ",e.jsx(t,{math:"T"})," appears in"," ",e.jsx(t,{math:"f(T)"}),". No leaf appears, because recording a leaf as a neighbor would require reducing the tree to one vertex. Hence the leaves of"," ",e.jsx(t,{math:"T"})," are the elements of ",e.jsx(t,{math:"S"})," not in"," ",e.jsx(t,{math:"f(T)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Given ",e.jsx(t,{math:"a \\in S^{n-2}"}),", every tree with Prüfer code"," ",e.jsx(t,{math:"a"})," has the same least leaf ",e.jsx(t,{math:"x"})," and has edge ",e.jsx(t,{math:"xa_1"}),". By induction on"," ",e.jsx(t,{math:"n"}),", there is exactly one tree with the remaining vertices and remaining code. Adding ",e.jsx(t,{math:"xa_1"})," yields exactly one tree with code ",e.jsx(t,{math:"a"}),"."]})]})]})]}),e.jsxs(s,{title:"Corollary 2.2.4 (Trees with Fixed Degrees)",children:[e.jsxs("p",{children:["Given positive integers ",e.jsx(t,{math:"d_1, \\ldots, d_n"})," summing to"," ",e.jsx(t,{math:"2n - 2"}),", there are exactly:"]}),e.jsx(a,{math:"\\frac{(n-2)!}{\\prod_i (d_i - 1)!}"}),e.jsxs("p",{children:["trees with vertex set ",e.jsx(t,{math:"[n]"})," such that vertex"," ",e.jsx(t,{math:"i"})," has degree ",e.jsx(t,{math:"d_i"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["While constructing the Prüfer code of a tree ",e.jsx(t,{math:"T"}),", we record ",e.jsx(t,{math:"x"})," each time we delete a neighbor of"," ",e.jsx(t,{math:"x"}),", until we delete ",e.jsx(t,{math:"x"})," itself or leave ",e.jsx(t,{math:"x"})," among the last two vertices. Thus each vertex"," ",e.jsx(t,{math:"x"})," appears ",e.jsx(t,{math:"d_T(x) - 1"})," times in the Prüfer code."]}),e.jsxs("p",{className:"mt-2",children:["Therefore, we count trees with these vertex degrees by counting lists of length ",e.jsx(t,{math:"n - 2"})," that for each ",e.jsx(t,{math:"i"})," ","have ",e.jsx(t,{math:"d_i - 1"})," copies of ",e.jsx(t,{math:"i"}),". This is the multinomial coefficient"," ",e.jsx(t,{math:"\\frac{(n-2)!}{\\prod_i (d_i - 1)!}"}),"."]})]})]})]}),e.jsxs(i,{title:"Trees with Fixed Degrees",children:[e.jsxs("p",{children:["Consider trees with vertices ",e.jsx(t,{math:"\\{1, 2, 3, 4, 5, 6, 7\\}"})," that have degrees ",e.jsx(t,{math:"(3, 1, 2, 1, 3, 1, 1)"}),", respectively."]}),e.jsxs("p",{children:["We compute"," ",e.jsx(t,{math:"\\frac{5!}{2! \\cdot 0! \\cdot 1! \\cdot 0! \\cdot 2! \\cdot 0! \\cdot 0!} = \\frac{120}{2 \\cdot 1 \\cdot 1 \\cdot 2} = 30"})," ","trees."]}),e.jsxs("p",{children:["Only vertices ",e.jsx(t,{math:"\\{1, 3, 5\\}"})," are non-leaves. Deleting the leaves yields a subtree on ",e.jsx(t,{math:"\\{1, 3, 5\\}"}),". There are three such subtrees, determined by which vertex is in the middle. To complete each tree, we add the appropriate number of leaf neighbors for each non-leaf."]})]}),e.jsx("h2",{children:"Spanning Trees in Graphs"}),e.jsxs("p",{children:["Cayley's Formula counts spanning trees of ",e.jsx(t,{math:"K_n"}),". We now consider the more general problem of computing the number of spanning trees in any graph ",e.jsx(t,{math:"G"}),"."]}),e.jsxs(r,{title:"Edge Contraction",children:[e.jsxs("p",{children:["In a graph ",e.jsx(t,{math:"G"}),", ",e.jsx("strong",{children:"contraction"})," of edge"," ",e.jsx(t,{math:"e"})," with endpoints ",e.jsx(t,{math:"u, v"})," is the replacement of ",e.jsx(t,{math:"u"})," and ",e.jsx(t,{math:"v"})," with a single vertex whose incident edges are the edges other than"," ",e.jsx(t,{math:"e"})," that were incident to ",e.jsx(t,{math:"u"})," or"," ",e.jsx(t,{math:"v"}),". The resulting graph ",e.jsx(t,{math:"G \\cdot e"})," ","has one less edge than ",e.jsx(t,{math:"G"}),"."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"In a drawing, contraction shrinks the edge to a single point. Contracting can produce multiple edges or loops."})]}),e.jsxs(s,{title:"Proposition 2.2.8 (Deletion-Contraction Recurrence)",children:[e.jsxs("p",{children:["Let ",e.jsx(t,{math:"\\tau(G)"})," denote the number of spanning trees of a graph ",e.jsx(t,{math:"G"}),". If ",e.jsx(t,{math:"e \\in E(G)"})," is not a loop, then:"]}),e.jsx(a,{math:"\\tau(G) = \\tau(G - e) + \\tau(G \\cdot e)"}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["The spanning trees of ",e.jsx(t,{math:"G"})," that omit"," ",e.jsx(t,{math:"e"})," are precisely the spanning trees of"," ",e.jsx(t,{math:"G - e"}),"."]}),e.jsxs("p",{className:"mt-2",children:["To show that ",e.jsx(t,{math:"G"})," has"," ",e.jsx(t,{math:"\\tau(G \\cdot e)"})," spanning trees containing"," ",e.jsx(t,{math:"e"}),", we show that contraction of"," ",e.jsx(t,{math:"e"})," defines a bijection from spanning trees of"," ",e.jsx(t,{math:"G"})," containing ",e.jsx(t,{math:"e"})," to spanning trees of ",e.jsx(t,{math:"G \\cdot e"}),"."]}),e.jsxs("p",{className:"mt-2",children:["When we contract ",e.jsx(t,{math:"e"})," in a spanning tree containing"," ",e.jsx(t,{math:"e"}),", we obtain a spanning tree of"," ",e.jsx(t,{math:"G \\cdot e"})," (spanning, connected, right number of edges). The other edges maintain their identity, so no two trees map to the same tree. Each spanning tree of ",e.jsx(t,{math:"G \\cdot e"})," arises by expanding the contracted vertex back into ",e.jsx(t,{math:"e"}),"."]})]})]})]}),e.jsxs(i,{title:"The Kite Graph",children:[e.jsx("p",{children:'The "kite" graph (a 4-cycle with one diagonal) has 8 spanning trees. Four are paths around the outside cycle, and four use the diagonal edge. Using deletion-contraction:'}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:[e.jsx(t,{math:"G - e"})," (diagonal removed) is"," ",e.jsx(t,{math:"C_4"}),", which has 4 spanning trees."]}),e.jsxs("li",{children:[e.jsx(t,{math:"G \\cdot e"})," (diagonal contracted) is a triangle with one doubled edge, which has 4 spanning trees."]}),e.jsxs("li",{children:["Total: ",e.jsx(t,{math:"4 + 4 = 8"}),"."]})]})]}),e.jsx("h3",{children:"The Matrix Tree Theorem"}),e.jsx("p",{children:"The deletion-contraction recurrence may require exponentially many terms. Kirchhoff discovered a much faster approach using determinants."}),e.jsxs(s,{title:"Matrix Tree Theorem (Theorem 2.2.12)",children:[e.jsxs("p",{children:["Given a loopless graph ",e.jsx(t,{math:"G"})," with vertex set"," ",e.jsx(t,{math:"v_1, \\ldots, v_n"}),", let ",e.jsx(t,{math:"a_{i,j}"})," be the number of edges with endpoints ",e.jsx(t,{math:"v_i"})," and"," ",e.jsx(t,{math:"v_j"}),". Define the ",e.jsx("strong",{children:"Laplacian matrix"})," ",e.jsx(t,{math:"Q"})," by:"]}),e.jsx(a,{math:"Q_{i,j} = \\begin{cases} d(v_i) & \\text{if } i = j \\\\ -a_{i,j} & \\text{if } i \\neq j \\end{cases}"}),e.jsxs("p",{children:["If ",e.jsx(t,{math:"Q^*"})," is a matrix obtained by deleting row"," ",e.jsx(t,{math:"s"})," and column ",e.jsx(t,{math:"t"})," of"," ",e.jsx(t,{math:"Q"}),", then:"]}),e.jsx(a,{math:"\\tau(G) = (-1)^{s+t} \\det Q^*"})]}),e.jsxs(i,{title:"Matrix Tree Computation",children:[e.jsx("p",{children:"For the kite graph with vertices labeled 1, 2, 3, 4:"}),e.jsx(a,{math:"Q = \\begin{pmatrix} 3 & -1 & -1 & -1 \\\\ -1 & 3 & -1 & -1 \\\\ -1 & -1 & 2 & 0 \\\\ -1 & -1 & 0 & 2 \\end{pmatrix}"}),e.jsx("p",{children:"Deleting row 1 and column 1 gives:"}),e.jsx(a,{math:"Q^* = \\begin{pmatrix} 3 & -1 & -1 \\\\ -1 & 2 & 0 \\\\ -1 & 0 & 2 \\end{pmatrix}"}),e.jsxs("p",{children:["Computing ",e.jsx(t,{math:"\\det Q^* = 3(4 - 0) - (-1)(-2 - 0) + (-1)(0 + 2) = 12 - 2 - 2 = 8"}),"."]})]}),e.jsx("h2",{children:"Graceful Labelings"}),e.jsxs("p",{children:["Can we decompose ",e.jsx(t,{math:"K_{2m+1}"})," into copies of a tree"," ",e.jsx(t,{math:"T"})," with ",e.jsx(t,{math:"m"})," edges? Graceful labelings provide a constructive approach."]}),e.jsxs(r,{title:"Graceful Labeling",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"graceful labeling"})," of a graph ",e.jsx(t,{math:"G"})," with"," ",e.jsx(t,{math:"m"})," edges is a function"," ",e.jsx(t,{math:"f: V(G) \\to \\{0, \\ldots, m\\}"})," such that:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2",children:[e.jsx("li",{children:"Distinct vertices receive distinct numbers."}),e.jsxs("li",{children:["The edge differences"," ",e.jsx(t,{math:"\\{|f(u) - f(v)|: uv \\in E(G)\\} = \\{1, \\ldots, m\\}"}),"."]})]}),e.jsxs("p",{className:"mt-2",children:["A graph is ",e.jsx("strong",{children:"graceful"})," if it has a graceful labeling."]})]}),e.jsxs(s,{title:"Ringel's Conjecture (Conjecture 2.2.13)",children:[e.jsxs("p",{children:["If ",e.jsx(t,{math:"T"})," is a fixed tree with ",e.jsx(t,{math:"m"})," edges, then ",e.jsx(t,{math:"K_{2m+1}"})," decomposes into"," ",e.jsx(t,{math:"2m + 1"})," copies of ",e.jsx(t,{math:"T"}),"."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["This famous conjecture was proved in 2019 by Montgomery, Pokrovskiy, and Sudakov for sufficiently large ",e.jsx(t,{math:"m"}),"."]})]}),e.jsxs(s,{title:"Theorem 2.2.16 (Rosa [1967])",children:[e.jsxs("p",{children:["If a tree ",e.jsx(t,{math:"T"})," with ",e.jsx(t,{math:"m"})," edges has a graceful labeling, then ",e.jsx(t,{math:"K_{2m+1}"})," has a decomposition into"," ",e.jsx(t,{math:"2m + 1"})," copies of ",e.jsx(t,{math:"T"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["View vertices of ",e.jsx(t,{math:"K_{2m+1}"})," as congruence classes modulo ",e.jsx(t,{math:"2m + 1"}),", arranged circularly. Group edges by the difference between endpoints (differences"," ",e.jsx(t,{math:"1, 2, \\ldots, m"}),")."]}),e.jsxs("p",{className:"mt-2",children:["From a graceful labeling, define copies"," ",e.jsx(t,{math:"T_0, \\ldots, T_{2m}"}),". The vertices of"," ",e.jsx(t,{math:"T_k"})," are"," ",e.jsx(t,{math:"k, k+1, \\ldots, k+m \\pmod{2m+1}"}),", with"," ",e.jsx(t,{math:"k+i"})," adjacent to ",e.jsx(t,{math:"k+j"})," iff"," ",e.jsx(t,{math:"i"})," is adjacent to ",e.jsx(t,{math:"j"})," in the labeling."]}),e.jsxs("p",{className:"mt-2",children:["Each difference class has exactly one edge in each"," ",e.jsx(t,{math:"T_k"}),", so the copies decompose"," ",e.jsx(t,{math:"K_{2m+1}"}),"."]})]})]})]}),e.jsxs(s,{title:"Graceful Tree Conjecture (Conjecture 2.2.15)",children:[e.jsx("p",{children:e.jsx("em",{children:"Every tree has a graceful labeling."})}),e.jsx("p",{className:"mt-2 text-dark-300",children:"This conjecture, due to Kotzig and Ringel (1964), remains open. It is known for many special classes of trees."})]}),e.jsx("h2",{children:"Caterpillars"}),e.jsxs(r,{title:"Caterpillar",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"caterpillar"})," is a tree in which a single path (the"," ",e.jsx("strong",{children:"spine"}),") is incident to (or contains) every edge."]}),e.jsx("p",{className:"mt-2",children:'Equivalently, deleting all leaves yields a path. The vertices not on the spine are called the "feet" and are all leaves.'})]}),e.jsxs(s,{title:"Theorem 2.2.19 (Caterpillar Characterization)",children:[e.jsxs("p",{children:["A tree is a caterpillar if and only if it does not contain the tree"," ",e.jsx(t,{math:"Y"})," (a vertex with three neighbors, each having another neighbor) as a subgraph."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Let ",e.jsx(t,{math:"G'"})," be the tree obtained by deleting all leaves. Since all surviving vertices are non-leaves in ",e.jsx(t,{math:"G"}),","," ",e.jsx(t,{math:"G'"})," has a vertex of degree at least 3 iff"," ",e.jsx(t,{math:"Y"})," appears in ",e.jsx(t,{math:"G"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Hence ",e.jsx(t,{math:"G"})," has no copy of ",e.jsx(t,{math:"Y"})," iff"," ",e.jsx(t,{math:"\\Delta(G') \\leq 2"})," iff"," ",e.jsx(t,{math:"G'"})," is a path iff ",e.jsx(t,{math:"G"})," is a caterpillar."]})]})]})]}),e.jsxs(i,{title:"Graceful Caterpillars",children:[e.jsx("p",{children:"Every caterpillar is graceful. Stars and paths are special cases of caterpillars (paths have no feet; stars have spine of length 0)."}),e.jsxs("p",{className:"mt-2",children:['A graceful labeling for caterpillars uses an "up/down" pattern: there exists a critical value ',e.jsx(t,{math:"a"})," such that every edge joins vertices with labels above and below ",e.jsx(t,{math:"a"}),"."]})]}),e.jsx("h2",{children:"Branchings (Optional)"}),e.jsxs(r,{title:"Branching (Out-tree)",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"branching"})," or ",e.jsx("strong",{children:"out-tree"})," is an orientation of a tree having:"]}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsx("li",{children:"A root of indegree 0"}),e.jsx("li",{children:"All other vertices of indegree 1"})]}),e.jsxs("p",{className:"mt-2",children:["An ",e.jsx("strong",{children:"in-tree"})," is an out-tree with edges reversed."]}),e.jsxs("p",{className:"mt-2",children:["A branching with root ",e.jsx(t,{math:"v"})," is a union of paths from"," ",e.jsx(t,{math:"v"}),". Each vertex is reached by exactly one path."]})]}),e.jsxs(s,{title:"Directed Matrix Tree Theorem (Theorem 2.2.21)",children:[e.jsxs("p",{children:["Given a loopless digraph ",e.jsx(t,{math:"G"}),", let"," ",e.jsx(t,{math:"Q^- = D^- - A'"})," and"," ",e.jsx(t,{math:"Q^+ = D^+ - A'"}),", where ",e.jsx(t,{math:"D^-"})," and"," ",e.jsx(t,{math:"D^+"})," are diagonal matrices of indegrees and outdegrees, and entry ",e.jsx(t,{math:"(i,j)"})," of ",e.jsx(t,{math:"A'"})," is the number of edges from ",e.jsx(t,{math:"v_j"})," to ",e.jsx(t,{math:"v_i"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The number of spanning out-trees (in-trees) rooted at"," ",e.jsx(t,{math:"v_i"})," is the value of each cofactor in the"," ",e.jsx(t,{math:"i"}),"th row of ",e.jsx(t,{math:"Q^-"})," (",e.jsx(t,{math:"i"}),"th column of ",e.jsx(t,{math:"Q^+"}),")."]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Cayley's Formula:"})," There are ",e.jsx(t,{math:"n^{n-2}"})," ","labeled trees on ",e.jsx(t,{math:"n"})," vertices, proved via the Prüfer code bijection."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Prüfer code:"})," A bijection between ",e.jsx(t,{math:"n"}),"-vertex labeled trees and sequences of length ",e.jsx(t,{math:"n-2"})," from"," ",e.jsx(t,{math:"[n]"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Degree counting:"})," Each vertex appears"," ",e.jsx(t,{math:"d(v) - 1"})," times in its tree's Prüfer code."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Deletion-contraction:"})," ",e.jsx(t,{math:"\\tau(G) = \\tau(G - e) + \\tau(G \\cdot e)"})," for non-loop"," ",e.jsx(t,{math:"e"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Matrix Tree Theorem:"})," Count spanning trees via the determinant of a cofactor of the Laplacian matrix."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Graceful labelings:"})," If a tree ",e.jsx(t,{math:"T"})," with"," ",e.jsx(t,{math:"m"})," edges is graceful, then ",e.jsx(t,{math:"K_{2m+1}"})," ","decomposes into copies of ",e.jsx(t,{math:"T"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Caterpillars:"})," Trees where deleting leaves yields a path; they are always graceful."]})]})]})}export{j as default};
