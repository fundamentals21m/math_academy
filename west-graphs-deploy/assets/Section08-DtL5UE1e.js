import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as s,E as n,T as a}from"./ContentBlocks-BAFtEaU8.js";import{I as t,M as i}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import{M as r}from"./HamiltonianFinder-Baj_YtFX.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function p(){return e.jsxs(h,{sectionId:8,children:[e.jsx("p",{children:"Within a set of people, some pairs are compatible as roommates; under what conditions can we pair them all up? Many applications of graphs involve such pairings. In the job assignment problem, we want to pair jobs with qualified applicants. Bipartite graphs have a natural vertex partition, and we want to know whether the two sets can be paired using edges."}),e.jsx("h2",{children:"Interactive Matching Explorer"}),e.jsx("p",{children:"Explore bipartite matchings interactively. Click edges to build a matching, find maximum matchings, and verify Hall's condition for perfect matchings."}),e.jsx(r,{className:"my-8"}),e.jsx("h2",{children:"Matchings"}),e.jsxs(s,{title:"Matching",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"matching"})," in a graph ",e.jsx(t,{math:"G"})," is a set of non-loop edges with no shared endpoints. The vertices incident to the edges of a matching ",e.jsx(t,{math:"M"})," are ",e.jsx("strong",{children:"saturated"})," by"," ",e.jsx(t,{math:"M"}),"; the others are ",e.jsx("strong",{children:"unsaturated"})," (we say"," ",e.jsx(t,{math:"M"}),"-saturated and ",e.jsx(t,{math:"M"}),"-unsaturated)."]}),e.jsxs("p",{className:"mt-2",children:["A ",e.jsx("strong",{children:"perfect matching"})," in a graph is a matching that saturates every vertex."]})]}),e.jsxs(n,{title:"Perfect Matchings in Complete Bipartite Graphs",children:[e.jsxs("p",{children:["Consider ",e.jsx(t,{math:"K_{n,n}"})," with partite sets"," ",e.jsx(t,{math:"X = \\{x_1, \\ldots, x_n\\}"})," and"," ",e.jsx(t,{math:"Y = \\{y_1, \\ldots, y_n\\}"}),". A perfect matching defines a bijection from ",e.jsx(t,{math:"X"})," to ",e.jsx(t,{math:"Y"}),". Successively finding mates for"," ",e.jsx(t,{math:"x_1, x_2, \\ldots"})," yields ",e.jsx(t,{math:"n!"})," perfect matchings."]}),e.jsxs("p",{className:"mt-2",children:["Each matching is represented by a permutation of ",e.jsx(t,{math:"[n]"}),", mapping ",e.jsx(t,{math:"i"})," to ",e.jsx(t,{math:"j"})," when"," ",e.jsx(t,{math:"x_i"})," is matched to ",e.jsx(t,{math:"y_j"}),"."]})]}),e.jsxs(n,{title:"Perfect Matchings in Complete Graphs",children:[e.jsxs("p",{children:["Since it has odd order, ",e.jsx(t,{math:"K_{2n+1}"})," has no perfect matching. The number ",e.jsx(t,{math:"f_n"})," of perfect matchings in"," ",e.jsx(t,{math:"K_{2n}"})," is the number of ways to pair up"," ",e.jsx(t,{math:"2n"})," distinct people."]}),e.jsxs("p",{className:"mt-2",children:["There are ",e.jsx(t,{math:"2n - 1"})," choices for the partner of"," ",e.jsx(t,{math:"v_{2n}"}),", and for each such choice there are"," ",e.jsx(t,{math:"f_{n-1}"})," ways to complete the matching. Hence:"]}),e.jsx(i,{math:"f_n = (2n-1) \\cdot f_{n-1} = (2n-1) \\cdot (2n-3) \\cdots (1) = (2n-1)!!"}),e.jsxs("p",{children:["Equivalently, ",e.jsx(t,{math:"f_n = \\frac{(2n)!}{2^n n!}"})," (each matching is generated by ",e.jsx(t,{math:"2^n n!"})," orderings)."]})]}),e.jsx("h2",{children:"Maximum Matchings"}),e.jsxs("p",{children:["A matching is a set of edges, so its ",e.jsx("strong",{children:"size"})," is the number of edges. We can seek a large matching by iteratively selecting edges whose endpoints are not used by the edges already selected. This yields a"," ",e.jsx("em",{children:"maximal"})," matching but maybe not a ",e.jsx("em",{children:"maximum"})," matching."]}),e.jsxs(s,{title:"Maximal vs. Maximum Matching",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"maximal matching"})," in a graph is a matching that cannot be enlarged by adding an edge."]}),e.jsxs("p",{className:"mt-2",children:["A ",e.jsx("strong",{children:"maximum matching"})," is a matching of maximum size among all matchings in the graph."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"Every maximum matching is maximal, but the converse need not hold."})]}),e.jsxs(n,{title:"Maximal ≠ Maximum",children:[e.jsxs("p",{children:["The smallest graph having a maximal matching that is not a maximum matching is"," ",e.jsx(t,{math:"P_4"}),". If we take the middle edge, we can add no other, but the two end edges form a larger matching."]}),e.jsx("p",{className:"mt-2",children:"This illustrates that greedy selection doesn't always find the optimum."})]}),e.jsx("h3",{children:"Augmenting Paths"}),e.jsxs(s,{title:"Alternating and Augmenting Paths",children:[e.jsxs("p",{children:["Given a matching ",e.jsx(t,{math:"M"}),", an"," ",e.jsxs("strong",{children:[e.jsx(t,{math:"M"}),"-alternating path"]})," ","is a path that alternates between edges in ",e.jsx(t,{math:"M"})," and edges not in ",e.jsx(t,{math:"M"}),"."]}),e.jsxs("p",{className:"mt-2",children:["An"," ",e.jsxs("strong",{children:[e.jsx(t,{math:"M"}),"-augmenting path"]})," ","is an ",e.jsx(t,{math:"M"}),"-alternating path whose endpoints are both unsaturated by ",e.jsx(t,{math:"M"}),"."]})]}),e.jsxs("p",{children:["Given an ",e.jsx(t,{math:"M"}),"-augmenting path ",e.jsx(t,{math:"P"}),", we can replace the edges of ",e.jsx(t,{math:"M"})," in ",e.jsx(t,{math:"P"})," with the other edges of ",e.jsx(t,{math:"P"})," to obtain a new matching"," ",e.jsx(t,{math:"M'"})," with one more edge. This operation is called"," ",e.jsx("strong",{children:"augmentation"}),"."]}),e.jsxs(s,{title:"Symmetric Difference",children:[e.jsxs("p",{children:["If ",e.jsx(t,{math:"G"})," and ",e.jsx(t,{math:"H"})," are graphs with vertex set ",e.jsx(t,{math:"V"}),", then the ",e.jsx("strong",{children:"symmetric difference"})," ",e.jsx(t,{math:"G \\triangle H"})," is the graph with vertex set"," ",e.jsx(t,{math:"V"})," whose edges are all those appearing in exactly one of"," ",e.jsx(t,{math:"G"})," and ",e.jsx(t,{math:"H"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For matchings: ",e.jsx(t,{math:"M \\triangle M' = (M - M') \\cup (M' - M)"}),"."]})]}),e.jsxs(a,{title:"Lemma 3.1.9",children:[e.jsx("p",{children:"Every component of the symmetric difference of two matchings is a path or an even cycle."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Let ",e.jsx(t,{math:"M"})," and ",e.jsx(t,{math:"M'"})," be matchings, and let ",e.jsx(t,{math:"F = M \\triangle M'"}),". Since"," ",e.jsx(t,{math:"M"})," and ",e.jsx(t,{math:"M'"})," are matchings, every vertex has at most one incident edge from each. Thus"," ",e.jsx(t,{math:"F"})," has at most two edges at each vertex."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(t,{math:"\\Delta(F) \\leq 2"}),", every component of"," ",e.jsx(t,{math:"F"})," is a path or a cycle. Furthermore, every path or cycle alternates between edges of ",e.jsx(t,{math:"M - M'"})," and edges of"," ",e.jsx(t,{math:"M' - M"}),". Thus each cycle has even length."]})]})]})]}),e.jsxs(a,{title:"Berge's Theorem (Theorem 3.1.10)",children:[e.jsxs("p",{children:["A matching ",e.jsx(t,{math:"M"})," in a graph ",e.jsx(t,{math:"G"})," is a maximum matching in ",e.jsx(t,{math:"G"})," if and only if"," ",e.jsx(t,{math:"G"})," has no ",e.jsx(t,{math:"M"}),"-augmenting path."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["We prove the contrapositive of each direction: ",e.jsx(t,{math:"G"})," has a matching larger than ",e.jsx(t,{math:"M"})," if and only if"," ",e.jsx(t,{math:"G"})," has an ",e.jsx(t,{math:"M"}),"-augmenting path."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐)"})," An ",e.jsx(t,{math:"M"}),"-augmenting path can be used to produce a matching larger than ",e.jsx(t,{math:"M"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇒)"})," Let ",e.jsx(t,{math:"M'"})," be a matching larger than"," ",e.jsx(t,{math:"M"}),". Let ",e.jsx(t,{math:"F = M \\triangle M'"}),". By Lemma 3.1.9, ",e.jsx(t,{math:"F"})," consists of paths and even cycles. The cycles have the same number of edges from ",e.jsx(t,{math:"M"})," and"," ",e.jsx(t,{math:"M'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(t,{math:"|M'| > |M|"}),", ",e.jsx(t,{math:"F"})," must have a component with more edges of ",e.jsx(t,{math:"M'"})," than of"," ",e.jsx(t,{math:"M"}),". Such a component can only be a path that starts and ends with an edge of ",e.jsx(t,{math:"M'"}),"; thus it is an"," ",e.jsx(t,{math:"M"}),"-augmenting path."]})]})]})]}),e.jsx("h2",{children:"Hall's Matching Condition"}),e.jsxs("p",{children:["When filling jobs with applicants, there may be many more applicants than jobs. We model this with an ",e.jsx(t,{math:"X, Y"}),"-bigraph and seek a matching that saturates ",e.jsx(t,{math:"X"}),"."]}),e.jsxs(s,{title:"Hall's Condition",children:[e.jsxs("p",{children:["For a bipartite graph with bipartition ",e.jsx(t,{math:"X, Y"}),", let"," ",e.jsx(t,{math:"N(S)"})," denote the set of vertices having a neighbor in"," ",e.jsx(t,{math:"S"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Hall's Condition:"})," For all"," ",e.jsx(t,{math:"S \\subseteq X"}),","," ",e.jsx(t,{math:"|N(S)| \\geq |S|"}),"."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["This is obviously necessary: if a matching saturates ",e.jsx(t,{math:"X"}),", then for every ",e.jsx(t,{math:"S \\subseteq X"}),", there must be at least"," ",e.jsx(t,{math:"|S|"})," vertices to match to ",e.jsx(t,{math:"S"}),"."]})]}),e.jsxs(a,{title:"Hall's Theorem (Theorem 3.1.11)",children:[e.jsxs("p",{children:["An ",e.jsx(t,{math:"X, Y"}),"-bigraph ",e.jsx(t,{math:"G"})," has a matching that saturates ",e.jsx(t,{math:"X"})," if and only if"," ",e.jsx(t,{math:"|N(S)| \\geq |S|"})," for all"," ",e.jsx(t,{math:"S \\subseteq X"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Necessity:"})," The ",e.jsx(t,{math:"|S|"})," vertices matched to ",e.jsx(t,{math:"S"})," must lie in ",e.jsx(t,{math:"N(S)"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Sufficiency:"})," We prove the contrapositive. If"," ",e.jsx(t,{math:"M"})," is a maximum matching that doesn't saturate"," ",e.jsx(t,{math:"X"}),", we find ",e.jsx(t,{math:"S \\subseteq X"})," with"," ",e.jsx(t,{math:"|N(S)| < |S|"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(t,{math:"u \\in X"})," be unsaturated. Among vertices reachable from ",e.jsx(t,{math:"u"})," by ",e.jsx(t,{math:"M"}),"-alternating paths, let ",e.jsx(t,{math:"S"})," be those in ",e.jsx(t,{math:"X"})," and"," ",e.jsx(t,{math:"T"})," be those in ",e.jsx(t,{math:"Y"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx(t,{math:"M"}),"-alternating paths from"," ",e.jsx(t,{math:"u"})," reach ",e.jsx(t,{math:"Y"})," along edges not in"," ",e.jsx(t,{math:"M"})," and return to ",e.jsx(t,{math:"X"})," along edges in ",e.jsx(t,{math:"M"}),". Hence ",e.jsx(t,{math:"M"})," matches"," ",e.jsx(t,{math:"T"})," with ",e.jsx(t,{math:"S - \\{u\\}"}),". Since there's no augmenting path, every vertex of ",e.jsx(t,{math:"T"})," is saturated, so ",e.jsx(t,{math:"T = N(S)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Thus"," ",e.jsx(t,{math:"|N(S)| = |T| = |S - \\{u\\}| = |S| - 1 < |S|"}),"."]})]})]})]}),e.jsx("h2",{children:"Vertex Covers"}),e.jsx("p",{children:"We now connect matchings to another graph parameter."}),e.jsxs(s,{title:"Vertex Cover",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"vertex cover"})," of a graph ",e.jsx(t,{math:"G"})," is a set"," ",e.jsx(t,{math:"Q \\subseteq V(G)"})," such that every edge of"," ",e.jsx(t,{math:"G"})," has at least one endpoint in ",e.jsx(t,{math:"Q"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"vertex cover number"})," ",e.jsx(t,{math:"\\beta(G)"})," is the minimum size of a vertex cover."]})]}),e.jsxs("p",{children:["Matchings and vertex covers are related: every vertex cover must contain at least one endpoint of each edge in a matching. Thus"," ",e.jsx(t,{math:"\\beta(G) \\geq |M|"})," for every matching"," ",e.jsx(t,{math:"M"}),"."]}),e.jsxs(a,{title:"König-Egerváry Theorem (Theorem 3.1.16)",children:[e.jsxs("p",{children:["If ",e.jsx(t,{math:"G"})," is a bipartite graph, then the maximum size of a matching in ",e.jsx(t,{math:"G"})," equals the minimum size of a vertex cover."]}),e.jsx(i,{math:"\\alpha'(G) = \\beta(G)"}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["Here ",e.jsx(t,{math:"\\alpha'(G)"})," denotes the maximum matching size (the"," ",e.jsx("strong",{children:"matching number"}),")."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsx("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:e.jsxs("p",{children:["We always have ",e.jsx(t,{math:"\\alpha'(G) \\leq \\beta(G)"}),". For bipartite graphs, equality is achieved by constructing a vertex cover from a maximum matching using alternating paths, similar to the proof of Hall's Theorem."]})})]})]}),e.jsxs(n,{title:"König-Egerváry in Practice",children:[e.jsxs("p",{children:["Consider ",e.jsx(t,{math:"K_{3,3}"}),". A maximum matching has size 3 (a perfect matching exists). A minimum vertex cover also has size 3 (we can take all vertices from one partite set)."]}),e.jsxs("p",{className:"mt-2",children:["For non-bipartite graphs, equality may fail. In a triangle"," ",e.jsx(t,{math:"K_3"}),", the maximum matching has size 1, but the minimum vertex cover has size 2."]})]}),e.jsx("h2",{children:"Independent Sets"}),e.jsxs(s,{title:"Independent Set",children:[e.jsxs("p",{children:["An ",e.jsx("strong",{children:"independent set"})," in a graph ",e.jsx(t,{math:"G"})," is a set of pairwise non-adjacent vertices."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"independence number"})," ",e.jsx(t,{math:"\\alpha(G)"})," is the maximum size of an independent set."]})]}),e.jsxs(a,{title:"Gallai's Theorem",children:[e.jsxs("p",{children:["For any graph ",e.jsx(t,{math:"G"})," without isolated vertices:"]}),e.jsx(i,{math:"\\alpha(G) + \\beta(G) = n(G)"}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["A set ",e.jsx(t,{math:"S"})," is independent if and only if its complement"," ",e.jsx(t,{math:"\\overline{S} = V(G) - S"})," is a vertex cover. Thus"," ",e.jsx(t,{math:"S"})," is a maximum independent set iff"," ",e.jsx(t,{math:"\\overline{S}"})," is a minimum vertex cover, and:"]}),e.jsx(i,{math:"\\alpha(G) = n(G) - \\beta(G)"})]})]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Matching:"})," A set of edges with no shared endpoints. Perfect matchings saturate all vertices."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Maximal vs. Maximum:"})," Maximal matchings can't be extended; maximum matchings have the most edges. They're not the same!"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Berge's Theorem:"})," A matching is maximum iff there is no augmenting path."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hall's Theorem:"})," An ",e.jsx(t,{math:"X, Y"}),"-bigraph has a matching saturating ",e.jsx(t,{math:"X"})," iff"," ",e.jsx(t,{math:"|N(S)| \\geq |S|"})," for all"," ",e.jsx(t,{math:"S \\subseteq X"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"König-Egerváry:"})," In bipartite graphs, maximum matching size = minimum vertex cover size."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Gallai's Theorem:"})," ",e.jsx(t,{math:"\\alpha(G) + \\beta(G) = n(G)"})," for graphs without isolated vertices."]})]})]})}export{p as default};
