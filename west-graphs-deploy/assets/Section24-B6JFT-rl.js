import{j as s}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as i,E as t,T as a}from"./ContentBlocks-BAFtEaU8.js";import{I as e,M as n}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function j(){return s.jsxs(h,{sectionId:24,children:[s.jsx("p",{children:"Matroids abstract the notion of linear independence from vector spaces and forests from graphs. They provide a unifying framework for many combinatorial optimization problems, explaining why greedy algorithms work for minimum spanning trees. The theory reveals deep connections between linear algebra, graph theory, and combinatorics."}),s.jsx("h2",{children:"Matroid Definition"}),s.jsxs(i,{title:"Matroid (Independence Axioms)",children:[s.jsxs("p",{children:["A ",s.jsx("strong",{children:"matroid"})," ",s.jsx(e,{math:"M = (E, \\mathcal{I})"})," consists of a finite set ",s.jsx(e,{math:"E"})," (the ",s.jsx("strong",{children:"ground set"}),") and a collection ",s.jsx(e,{math:"\\mathcal{I}"})," of subsets of"," ",s.jsx(e,{math:"E"})," (the ",s.jsx("strong",{children:"independent sets"}),") satisfying:"]}),s.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"(I1)"})," ",s.jsx(e,{math:"\\emptyset \\in \\mathcal{I}"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"(I2)"})," If ",s.jsx(e,{math:"I \\in \\mathcal{I}"})," and"," ",s.jsx(e,{math:"J \\subseteq I"}),", then"," ",s.jsx(e,{math:"J \\in \\mathcal{I}"})," (hereditary)"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"(I3)"})," If ",s.jsx(e,{math:"I, J \\in \\mathcal{I}"})," with"," ",s.jsx(e,{math:"|I| < |J|"}),", then"," ",s.jsx(e,{math:"\\exists e \\in J - I"})," with"," ",s.jsx(e,{math:"I \\cup \\{e\\} \\in \\mathcal{I}"})," (exchange property)"]})]})]}),s.jsxs(t,{title:"Graphic Matroid",children:[s.jsxs("p",{children:["For graph ",s.jsx(e,{math:"G"}),", let ",s.jsx(e,{math:"E = E(G)"})," and"," ",s.jsx(e,{math:"\\mathcal{I}"})," = sets of edges forming forests."]}),s.jsx("p",{className:"mt-2",children:s.jsx("strong",{children:"Verify axioms:"})}),s.jsxs("ul",{className:"list-disc list-inside",children:[s.jsx("li",{children:"(I1): Empty set is a forest. ✓"}),s.jsx("li",{children:"(I2): Subsets of forests are forests. ✓"}),s.jsxs("li",{children:["(I3): If forest ",s.jsx(e,{math:"J"})," has more edges than forest"," ",s.jsx(e,{math:"I"}),", some edge of ",s.jsx(e,{math:"J"})," can be added to ",s.jsx(e,{math:"I"})," without creating a cycle. ✓"]})]})]}),s.jsxs(t,{title:"Vector Matroid",children:[s.jsxs("p",{children:["For a matrix ",s.jsx(e,{math:"A"})," with columns"," ",s.jsx(e,{math:"v_1, \\ldots, v_n"}),", let"," ",s.jsx(e,{math:"E = \\{1, \\ldots, n\\}"})," and"," ",s.jsx(e,{math:"I \\in \\mathcal{I}"})," iff"," ",s.jsx(e,{math:"\\{v_i : i \\in I\\}"})," is linearly independent."]}),s.jsx("p",{className:"mt-2",children:"The exchange property (I3) follows from the Steinitz exchange lemma."})]}),s.jsx("h2",{children:"Basic Matroid Terminology"}),s.jsx(i,{title:"Dependent Sets, Circuits, Bases",children:s.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"Dependent:"})," A set not in ",s.jsx(e,{math:"\\mathcal{I}"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Circuit:"})," A minimal dependent set"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Base:"})," A maximal independent set"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Rank:"})," ",s.jsx(e,{math:"r(A)"})," = max size of independent subset of ",s.jsx(e,{math:"A"})]})]})}),s.jsxs(a,{title:"Base Properties",proof:s.jsxs(s.Fragment,{children:[s.jsxs("p",{children:[s.jsx("strong",{children:"Equal cardinality:"})," Suppose bases ",s.jsx(e,{math:"B_1"})," and"," ",s.jsx(e,{math:"B_2"})," have ",s.jsx(e,{math:"|B_1| < |B_2|"}),". By the exchange property (I3) applied to independent sets"," ",s.jsx(e,{math:"B_1"})," and ",s.jsx(e,{math:"B_2"}),", there exists"," ",s.jsx(e,{math:"e \\in B_2 - B_1"})," with ",s.jsx(e,{math:"B_1 \\cup \\{'{'}e{'}'}"})," ","independent. This contradicts maximality of ",s.jsx(e,{math:"B_1"}),"."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"Base exchange:"})," Let ",s.jsx(e,{math:"e \\in B_1 - B_2"}),". The set ",s.jsx(e,{math:"B_1 - e"})," is independent with"," ",s.jsx(e,{math:"|B_1 - e| = |B_1| - 1 < |B_2|"}),"."]}),s.jsxs("p",{className:"mt-2",children:["By (I3), there exists ",s.jsx(e,{math:"f \\in B_2 - (B_1 - e) = B_2 - B_1 + e"})," ","such that ",s.jsx(e,{math:"(B_1 - e) \\cup \\{'{'}f{'}'}"})," is independent. Since ",s.jsx(e,{math:"e \\notin B_2"}),", we have"," ",s.jsx(e,{math:"f \\in B_2 - B_1"}),"."]}),s.jsxs("p",{className:"mt-2",children:["The set ",s.jsx(e,{math:"B_1 - e + f"})," has size ",s.jsx(e,{math:"|B_1|"})," ","and is independent, hence a base."]})]}),children:[s.jsxs("p",{children:["All bases of a matroid have the same cardinality (the ",s.jsx("strong",{children:"rank"})," of the matroid)."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"Base exchange:"})," If ",s.jsx(e,{math:"B_1, B_2"})," are bases and ",s.jsx(e,{math:"e \\in B_1 - B_2"}),", then"," ",s.jsx(e,{math:"\\exists f \\in B_2 - B_1"})," such that"," ",s.jsx(e,{math:"B_1 - e + f"})," is a base."]})]}),s.jsxs(t,{title:"Graphic Matroid Terms",children:[s.jsxs("p",{children:["In graphic matroid ",s.jsx(e,{math:"M(G)"}),":"]}),s.jsxs("ul",{className:"list-disc list-inside",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"Circuits:"})," Cycles of ",s.jsx(e,{math:"G"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Bases:"})," Spanning forests (spanning trees if connected)"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Rank:"})," ",s.jsx(e,{math:"n - c"})," where"," ",s.jsx(e,{math:"c"})," = components"]})]})]}),s.jsx("h2",{children:"Matroid Duality"}),s.jsxs(i,{title:"Dual Matroid",children:[s.jsxs("p",{children:["The ",s.jsx("strong",{children:"dual"})," ",s.jsx(e,{math:"M^*"})," of matroid"," ",s.jsx(e,{math:"M = (E, \\mathcal{I})"})," has:"]}),s.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[s.jsxs("li",{children:["Ground set: ",s.jsx(e,{math:"E"})]}),s.jsxs("li",{children:["Bases: ",s.jsx(e,{math:"\\{E - B : B \\text{ is a base of } M\\}"})]})]}),s.jsxs("p",{className:"mt-2",children:["The dual of the dual is the original: ",s.jsx(e,{math:"(M^*)^* = M"}),"."]})]}),s.jsxs(t,{title:"Dual of Graphic Matroid",children:[s.jsxs("p",{children:["For a planar graph ",s.jsx(e,{math:"G"}),", the dual of"," ",s.jsx(e,{math:"M(G)"})," is ",s.jsx(e,{math:"M(G^*)"}),", where"," ",s.jsx(e,{math:"G^*"})," is the planar dual graph."]}),s.jsxs("p",{className:"mt-2",children:[s.jsxs("strong",{children:["Circuits of ",s.jsx(e,{math:"M^*"}),":"]})," Minimal edge cuts (bonds) of ",s.jsx(e,{math:"G"}),"."]})]}),s.jsx("h2",{children:"Greedy Algorithm"}),s.jsxs(a,{title:"Greedy Algorithm for Matroids",proof:s.jsxs(s.Fragment,{children:[s.jsxs("p",{children:["Let ",s.jsx(e,{math:"B^*"})," be the greedy solution and"," ",s.jsx(e,{math:"B"})," be any base. We show"," ",s.jsx(e,{math:"w(B^*) \\geq w(B)"}),"."]}),s.jsxs("p",{className:"mt-2",children:["Order ",s.jsx(e,{math:"B^* = \\{'{'}e_1, \\ldots, e_r{'}'}"})," by decreasing weight and ",s.jsx(e,{math:"B = \\{'{'}f_1, \\ldots, f_r{'}'}"})," similarly. We claim ",s.jsx(e,{math:"w(e_i) \\geq w(f_i)"})," for all"," ",s.jsx(e,{math:"i"}),"."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"By contradiction:"})," Suppose ",s.jsx(e,{math:"i"})," is the first index with ",s.jsx(e,{math:"w(e_i) < w(f_i)"}),". Consider ",s.jsx(e,{math:"I = \\{'{'}e_1, \\ldots, e_{'{'}i-1{'}'}{'}'}"})," and"," ",s.jsx(e,{math:"J = \\{'{'}f_1, \\ldots, f_i{'}'}"}),"."]}),s.jsxs("p",{className:"mt-2",children:["We have ",s.jsx(e,{math:"|I| < |J|"}),", so by (I3), some"," ",s.jsx(e,{math:"f_j \\in J - I"})," can be added to ",s.jsx(e,{math:"I"}),". Since ",s.jsx(e,{math:"w(f_j) \\geq w(f_i) > w(e_i)"}),", the greedy algorithm would have chosen ",s.jsx(e,{math:"f_j"})," before ",s.jsx(e,{math:"e_i"}),", contradiction."]}),s.jsxs("p",{className:"mt-2",children:["Thus ",s.jsx(e,{math:"w(B^*) = \\sum w(e_i) \\geq \\sum w(f_i) = w(B)"}),"."]})]}),children:[s.jsxs("p",{children:["Given a weighted matroid ",s.jsx(e,{math:"(E, \\mathcal{I}, w)"}),", the greedy algorithm finds a maximum-weight base:"]}),s.jsxs("ol",{className:"mt-2 list-decimal list-inside",children:[s.jsxs("li",{children:["Sort elements by weight: ",s.jsx(e,{math:"w(e_1) \\geq \\cdots \\geq w(e_n)"})]}),s.jsxs("li",{children:["Initialize ",s.jsx(e,{math:"I = \\emptyset"})]}),s.jsxs("li",{children:["For each ",s.jsx(e,{math:"e_i"}),": if"," ",s.jsx(e,{math:"I \\cup \\{e_i\\} \\in \\mathcal{I}"}),", set"," ",s.jsx(e,{math:"I = I \\cup \\{e_i\\}"})]})]}),s.jsxs("p",{className:"mt-2",children:["This gives an ",s.jsx("strong",{children:"optimal"})," solution."]})]}),s.jsx(a,{title:"Characterization by Greedy",proof:s.jsxs(s.Fragment,{children:[s.jsxs("p",{children:[s.jsx("strong",{children:"(Matroid → greedy works):"})," Proved above."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"(Greedy works → matroid):"})," Suppose"," ",s.jsx(e,{math:"(E, \\mathcal{I})"})," is hereditary but not a matroid. Then (I3) fails: there exist ",s.jsx(e,{math:"I, J \\in \\mathcal{I}"})," with"," ",s.jsx(e,{math:"|I| < |J|"})," but no element of ",s.jsx(e,{math:"J - I"})," ","can be added to ",s.jsx(e,{math:"I"}),"."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"Construct bad weights:"})," Define:"]}),s.jsxs("ul",{className:"list-disc list-inside mt-2",children:[s.jsxs("li",{children:[s.jsx(e,{math:"w(e) = 1 + \\epsilon"})," for ",s.jsx(e,{math:"e \\in I"})]}),s.jsxs("li",{children:[s.jsx(e,{math:"w(e) = 1"})," for ",s.jsx(e,{math:"e \\in J - I"})]}),s.jsxs("li",{children:[s.jsx(e,{math:"w(e) = 0"})," otherwise"]})]}),s.jsxs("p",{className:"mt-2",children:["For small ",s.jsx(e,{math:"\\epsilon > 0"}),", greedy selects all of"," ",s.jsx(e,{math:"I"})," first (higher weight), then cannot add elements of ",s.jsx(e,{math:"J - I"}),". The greedy solution has weight"," ",s.jsx(e,{math:"|I|(1 + \\epsilon)"}),", but"," ",s.jsx(e,{math:"J"})," achieves ",s.jsx(e,{math:"|J| > |I|(1 + \\epsilon)"})," ","for small enough ",s.jsx(e,{math:"\\epsilon"}),". Greedy fails."]})]}),children:s.jsxs("p",{children:["A hereditary system ",s.jsx(e,{math:"(E, \\mathcal{I})"})," is a matroid if and only if the greedy algorithm produces a maximum-weight base for every weight function."]})}),s.jsxs(t,{title:"Kruskal's Algorithm",children:[s.jsx("p",{children:"Kruskal's algorithm for minimum spanning tree is the greedy algorithm on the graphic matroid with weights = negative edge weights."}),s.jsx("p",{className:"mt-2",children:"It works because graphic matroids are matroids!"})]}),s.jsx("h2",{children:"Matroid Intersection"}),s.jsx(i,{title:"Matroid Intersection",children:s.jsxs("p",{children:["Given matroids ",s.jsx(e,{math:"M_1 = (E, \\mathcal{I}_1)"})," and"," ",s.jsx(e,{math:"M_2 = (E, \\mathcal{I}_2)"})," on the same ground set, the"," ",s.jsx("strong",{children:"matroid intersection"})," problem asks for the largest set in"," ",s.jsx(e,{math:"\\mathcal{I}_1 \\cap \\mathcal{I}_2"}),"."]})}),s.jsxs(a,{title:"Matroid Intersection Theorem",proof:s.jsxs(s.Fragment,{children:[s.jsxs("p",{children:[s.jsx("strong",{children:"Upper bound (weak duality):"})," For any"," ",s.jsx(e,{math:"A \\subseteq E"})," and any common independent set"," ",s.jsx(e,{math:"I \\in \\mathcal{I}_1 \\cap \\mathcal{I}_2"}),":"]}),s.jsx(n,{math:"|I| = |I \\cap A| + |I \\cap (E-A)| \\leq r_1(A) + r_2(E-A)"}),s.jsxs("p",{className:"mt-2",children:["since ",s.jsx(e,{math:"I \\cap A"})," is independent in"," ",s.jsx(e,{math:"M_1"})," and ",s.jsx(e,{math:"I \\cap (E-A)"})," is independent in ",s.jsx(e,{math:"M_2"}),"."]}),s.jsxs("p",{className:"mt-2",children:[s.jsx("strong",{children:"Equality (strong duality):"})," The proof uses an augmenting path algorithm. Given a common independent set ",s.jsx(e,{math:"I"}),", construct an auxiliary directed bipartite graph where:"]}),s.jsxs("ul",{className:"list-disc list-inside mt-2",children:[s.jsxs("li",{children:["One part is ",s.jsx(e,{math:"I"}),", other part is ",s.jsx(e,{math:"E - I"})]}),s.jsx("li",{children:"Arcs encode which elements can be exchanged while preserving independence"})]}),s.jsxs("p",{className:"mt-2",children:["An augmenting path from ",s.jsx(e,{math:"E - I"})," to ",s.jsx(e,{math:"E - I"})," ","(through ",s.jsx(e,{math:"I"}),") allows increasing ",s.jsx(e,{math:"|I|"}),". When no augmenting path exists, ",s.jsx(e,{math:"I"})," is maximum and the partition ",s.jsx(e,{math:"A"})," achieving equality can be constructed from the reachable set."]})]}),children:[s.jsx("p",{children:"The maximum size of a common independent set equals:"}),s.jsx(n,{math:"\\max |I| = \\min_{A \\subseteq E} (r_1(A) + r_2(E - A))"}),s.jsxs("p",{className:"mt-2",children:["where ",s.jsx(e,{math:"r_1, r_2"})," are the rank functions."]}),s.jsx("p",{className:"mt-2 text-dark-300",children:"This generalizes many min-max theorems (König, Menger, etc.)."})]}),s.jsxs(t,{title:"Bipartite Matching as Matroid Intersection",children:[s.jsxs("p",{children:["For bipartite graph ",s.jsx(e,{math:"G = (X \\cup Y, E)"}),", define:"]}),s.jsxs("ul",{className:"list-disc list-inside",children:[s.jsxs("li",{children:[s.jsx(e,{math:"M_1"}),": Partition matroid on ",s.jsx(e,{math:"E"})," where edges incident to same ",s.jsx(e,{math:"x \\in X"})," are dependent"]}),s.jsxs("li",{children:[s.jsx(e,{math:"M_2"}),": Same for ",s.jsx(e,{math:"Y"})]})]}),s.jsx("p",{className:"mt-2",children:"Common independent sets = matchings. Max intersection = max matching."})]}),s.jsx("h2",{children:"Key Takeaways"}),s.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"Matroid:"})," Hereditary system with exchange property; abstracts independence."]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Examples:"})," Graphic (forests), vector (linear independence), partition, uniform."]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Dual:"})," Bases complement to dual bases."]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Greedy:"})," Greedy algorithm is optimal on matroids; this characterizes them."]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Intersection:"})," Max common independent set has min-max formula; generalizes matching."]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Unification:"})," Matroids explain why greedy works for MST but not for other problems."]})]})]})}export{j as default};
