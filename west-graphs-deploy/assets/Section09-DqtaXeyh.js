import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as t,T as a,E as i}from"./ContentBlocks-BAFtEaU8.js";import{I as s,M as r}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function d(){return e.jsxs(h,{sectionId:9,children:[e.jsx("p",{children:"Now that we understand the structure of maximum matchings via Berge's Theorem, we can design algorithms to find them. In bipartite graphs, the augmenting path approach leads to efficient algorithms. We also consider weighted versions of matching problems and the stable matching problem, which has applications in job markets and organ donation."}),e.jsx("h2",{children:"The Augmenting Path Algorithm"}),e.jsxs("p",{children:["Berge's Theorem tells us that a matching ",e.jsx(s,{math:"M"})," is maximum if and only if there is no ",e.jsx(s,{math:"M"}),"-augmenting path. This suggests an algorithm: repeatedly find augmenting paths and use them to enlarge the matching until no augmenting path exists."]}),e.jsxs(t,{title:"Augmenting Path Algorithm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," An ",e.jsx(s,{math:"X, Y"}),"-bigraph"," ",e.jsx(s,{math:"G"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Idea:"})," Explore alternating paths from each unsaturated vertex in ",e.jsx(s,{math:"X"}),", seeking to reach an unsaturated vertex in"," ",e.jsx(s,{math:"Y"}),"."]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Start with any matching ",e.jsx(s,{math:"M"})," (possibly empty)."]}),e.jsxs("li",{children:["For each unsaturated vertex ",e.jsx(s,{math:"u \\in X"}),", use BFS/DFS to search for an ",e.jsx(s,{math:"M"}),"-augmenting path starting at"," ",e.jsx(s,{math:"u"}),"."]}),e.jsxs("li",{children:["From ",e.jsx(s,{math:"X"}),"-vertices, follow edges not in"," ",e.jsx(s,{math:"M"}),"."]}),e.jsxs("li",{children:["From ",e.jsx(s,{math:"Y"}),"-vertices, follow edges in"," ",e.jsx(s,{math:"M"}),"."]}),e.jsxs("li",{children:["If an unsaturated ",e.jsx(s,{math:"Y"}),"-vertex is reached, we've found an augmenting path. Augment ",e.jsx(s,{math:"M"})," and repeat."]}),e.jsxs("li",{children:["If no augmenting path exists, ",e.jsx(s,{math:"M"})," is maximum."]})]})]}),e.jsxs(a,{title:"Theorem 3.2.2 (Correctness and Running Time)",children:[e.jsxs("p",{children:["The augmenting path algorithm finds a maximum matching in an"," ",e.jsx(s,{math:"X, Y"}),"-bigraph ",e.jsx(s,{math:"G"}),". If"," ",e.jsx(s,{math:"n = |V(G)|"})," and ",e.jsx(s,{math:"m = |E(G)|"}),", the algorithm runs in ",e.jsx(s,{math:"O(mn)"})," time."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," Berge's Theorem guarantees that when no augmenting path exists, we have a maximum matching."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Time analysis:"})," Each augmentation increases"," ",e.jsx(s,{math:"|M|"})," by 1. Since"," ",e.jsx(s,{math:"|M| \\leq n/2"}),", we perform at most"," ",e.jsx(s,{math:"O(n)"})," augmentations. Each search for an augmenting path visits each edge at most once, taking ",e.jsx(s,{math:"O(m)"})," ","time. Total: ",e.jsx(s,{math:"O(mn)"}),"."]})]})]})]}),e.jsxs(i,{title:"Applying the Algorithm",children:[e.jsxs("p",{children:["Consider a bipartite graph with ",e.jsx(s,{math:"X = \\{x_1, x_2, x_3\\}"})," ","and ",e.jsx(s,{math:"Y = \\{y_1, y_2, y_3\\}"})," with edges"," ",e.jsx(s,{math:"x_1y_1, x_1y_2, x_2y_1, x_2y_2, x_3y_2, x_3y_3"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Round 1:"})," Start with ",e.jsx(s,{math:"M = \\emptyset"}),". From ",e.jsx(s,{math:"x_1"}),", go to ",e.jsx(s,{math:"y_1"})," (unsaturated). Augment: ",e.jsx(s,{math:"M = \\{x_1y_1\\}"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Round 2:"})," From ",e.jsx(s,{math:"x_2"}),", try"," ",e.jsx(s,{math:"y_1"})," (saturated), follow matching edge to"," ",e.jsx(s,{math:"x_1"}),", try ",e.jsx(s,{math:"y_2"})," (unsaturated). Augment: ",e.jsx(s,{math:"M = \\{x_1y_2, x_2y_1\\}"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Round 3:"})," From ",e.jsx(s,{math:"x_3"}),", try"," ",e.jsx(s,{math:"y_2"})," (saturated), to ",e.jsx(s,{math:"x_1"}),", can't extend further from ",e.jsx(s,{math:"x_1"}),". Try ",e.jsx(s,{math:"y_3"})," ","(unsaturated). Augment: ",e.jsx(s,{math:"M = \\{x_1y_2, x_2y_1, x_3y_3\\}"}),"."]}),e.jsx("p",{className:"mt-2",children:"Final matching is perfect with size 3."})]}),e.jsx("h3",{children:"The Hopcroft-Karp Algorithm"}),e.jsx("p",{children:"By finding many augmenting paths in each phase (all of shortest length), the Hopcroft-Karp algorithm improves the running time."}),e.jsxs(a,{title:"Hopcroft-Karp (1973)",children:[e.jsxs("p",{children:["A maximum matching in a bipartite graph with ",e.jsx(s,{math:"n"})," vertices and ",e.jsx(s,{math:"m"})," edges can be found in"," ",e.jsx(s,{math:"O(m\\sqrt{n})"})," time."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:"The algorithm works in phases. Each phase finds a maximal set of vertex-disjoint shortest augmenting paths and augments along all of them simultaneously."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Key insight:"})," After each phase, the length of the shortest augmenting path strictly increases. This is because augmenting along all shortest paths removes all such paths from the residual graph."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Phase count:"})," If the maximum matching has size"," ",e.jsx(s,{math:"k"}),", then after ",e.jsx(s,{math:"\\sqrt{k}"})," phases, the shortest augmenting path has length at least"," ",e.jsx(s,{math:"\\sqrt{k}"}),". The number of remaining augmenting paths is at most ",e.jsx(s,{math:"\\sqrt{k}"}),", so at most"," ",e.jsx(s,{math:"\\sqrt{k}"})," more phases are needed."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Total phases:"})," ",e.jsx(s,{math:"O(\\sqrt{k}) = O(\\sqrt{n})"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Per-phase time:"})," Finding all shortest augmenting paths via BFS and augmenting takes ",e.jsx(s,{math:"O(m)"})," time."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Total time:"})," ",e.jsx(s,{math:"O(m\\sqrt{n})"}),"."]})]})]})]}),e.jsx("h2",{children:"Weighted Bipartite Matching"}),e.jsx("p",{children:"In many applications, not all matchings are equally valuable. When edges have weights (costs or profits), we seek a maximum matching of maximum (or minimum) total weight."}),e.jsxs(t,{title:"Weighted Bipartite Matching",children:[e.jsxs("p",{children:["Given an ",e.jsx(s,{math:"X, Y"}),"-bigraph ",e.jsx(s,{math:"G"})," with edge weights ",e.jsx(s,{math:"w: E(G) \\to \\mathbb{R}"}),", the"," ",e.jsx("strong",{children:"weighted bipartite matching problem"})," seeks a maximum matching"," ",e.jsx(s,{math:"M"})," that maximizes (or minimizes)"," ",e.jsx(s,{math:"\\sum_{e \\in M} w(e)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["When ",e.jsx(s,{math:"|X| = |Y| = n"})," and we seek a perfect matching, this is the ",e.jsx("strong",{children:"assignment problem"}),"."]})]}),e.jsxs(i,{title:"Farm Assignment Problem",children:[e.jsxs("p",{children:["A farm must assign ",e.jsx(s,{math:"n"})," workers to ",e.jsx(s,{math:"n"})," ","jobs. Let ",e.jsx(s,{math:"a_{ij}"})," be the profit when worker"," ",e.jsx(s,{math:"i"})," does job ",e.jsx(s,{math:"j"}),". We model this as"," ",e.jsx(s,{math:"K_{n,n}"})," with edge ",e.jsx(s,{math:"x_i y_j"})," having weight ",e.jsx(s,{math:"a_{ij}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["We seek a perfect matching (assignment) maximizing total profit. The optimal assignment corresponds to a permutation ",e.jsx(s,{math:"\\sigma"})," ","maximizing ",e.jsx(s,{math:"\\sum_i a_{i,\\sigma(i)}"}),"."]})]}),e.jsx("h3",{children:"The Hungarian Algorithm"}),e.jsxs(t,{title:"Vertex Labeling",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"feasible labeling"})," for weighted"," ",e.jsx(s,{math:"X, Y"}),"-bigraph ",e.jsx(s,{math:"G"})," is a function"," ",e.jsx(s,{math:"\\ell: V(G) \\to \\mathbb{R}"})," such that"," ",e.jsx(s,{math:"\\ell(x) + \\ell(y) \\geq w(xy)"})," for all edges"," ",e.jsx(s,{math:"xy"}),"."]}),e.jsxs("p",{className:"mt-2",children:["An edge ",e.jsx(s,{math:"xy"})," is ",e.jsx("strong",{children:"tight"})," if"," ",e.jsx(s,{math:"\\ell(x) + \\ell(y) = w(xy)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"equality graph"})," ",e.jsx(s,{math:"G_\\ell"})," consists of all tight edges."]})]}),e.jsxs(a,{title:"Theorem 3.2.9",children:[e.jsxs("p",{children:["For a feasible labeling ",e.jsx(s,{math:"\\ell"})," on a weighted bipartite graph ",e.jsx(s,{math:"G"})," with ",e.jsx(s,{math:"|X| = |Y|"}),":"]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["For any matching ",e.jsx(s,{math:"M"}),":"," ",e.jsx(s,{math:"w(M) \\leq \\sum_{v \\in V(G)} \\ell(v)"}),"."]}),e.jsxs("li",{children:["Equality holds if and only if ",e.jsx(s,{math:"M"})," is a perfect matching in ",e.jsx(s,{math:"G_\\ell"}),"."]})]}),e.jsxs("p",{className:"mt-2",children:["Thus, a perfect matching in ",e.jsx(s,{math:"G_\\ell"})," is a maximum-weight perfect matching in ",e.jsx(s,{math:"G"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Part 1:"})," For any matching ",e.jsx(s,{math:"M"}),", we have:"]}),e.jsx(r,{math:"w(M) = \\sum_{xy \\in M} w(xy) \\leq \\sum_{xy \\in M} (\\ell(x) + \\ell(y))"}),e.jsxs("p",{className:"mt-2",children:["by the feasibility condition ",e.jsx(s,{math:"\\ell(x) + \\ell(y) \\geq w(xy)"}),". Since ",e.jsx(s,{math:"M"})," saturates at most one endpoint of each vertex:"]}),e.jsx(r,{math:"\\sum_{xy \\in M} (\\ell(x) + \\ell(y)) \\leq \\sum_{v \\in V(G)} \\ell(v)"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 2 (⇐):"})," If ",e.jsx(s,{math:"M"})," is a perfect matching in ",e.jsx(s,{math:"G_\\ell"}),", then all edges of ",e.jsx(s,{math:"M"})," are tight: ",e.jsx(s,{math:"\\ell(x) + \\ell(y) = w(xy)"})," for each"," ",e.jsx(s,{math:"xy \\in M"}),". Since ",e.jsx(s,{math:"M"})," is perfect, every vertex is saturated exactly once, so:"]}),e.jsx(r,{math:"w(M) = \\sum_{xy \\in M} w(xy) = \\sum_{xy \\in M} (\\ell(x) + \\ell(y)) = \\sum_{v \\in V(G)} \\ell(v)"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 2 (⇒):"})," If equality holds, then ",e.jsx(s,{math:"M"})," must saturate every vertex (otherwise the sum over ",e.jsx(s,{math:"M"})," would be less than the sum over all vertices). Furthermore, every edge in"," ",e.jsx(s,{math:"M"})," must be tight (otherwise the weight would be strictly less). Thus ",e.jsx(s,{math:"M"})," is a perfect matching in"," ",e.jsx(s,{math:"G_\\ell"}),"."]})]})]})]}),e.jsxs(t,{title:"Hungarian Algorithm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," Weighted ",e.jsx(s,{math:"X, Y"}),"-bigraph with"," ",e.jsx(s,{math:"|X| = |Y| = n"}),"."]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Initialize: ",e.jsx(s,{math:"\\ell(x) = \\max_y w(xy)"})," for"," ",e.jsx(s,{math:"x \\in X"}),", ",e.jsx(s,{math:"\\ell(y) = 0"})," for"," ",e.jsx(s,{math:"y \\in Y"}),"."]}),e.jsxs("li",{children:["Find a maximum matching ",e.jsx(s,{math:"M"})," in"," ",e.jsx(s,{math:"G_\\ell"}),"."]}),e.jsxs("li",{children:["If ",e.jsx(s,{math:"M"})," is perfect, return ",e.jsx(s,{math:"M"}),"."]}),e.jsxs("li",{children:["Otherwise, adjust labels to add edges to ",e.jsx(s,{math:"G_\\ell"})," ","(making more edges tight) and repeat."]})]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["Running time: ",e.jsx(s,{math:"O(n^3)"}),"."]})]}),e.jsx("h2",{children:"Stable Matchings"}),e.jsx("p",{children:"In the stable matching problem, we have preferences rather than numeric weights. Each vertex ranks its potential partners, and we seek a matching where no two unmatched vertices would prefer each other over their current partners."}),e.jsxs(t,{title:"Stable Matching",children:[e.jsxs("p",{children:["Given an ",e.jsx(s,{math:"X, Y"}),"-bigraph where each vertex ranks its neighbors, a matching ",e.jsx(s,{math:"M"})," is ",e.jsx("strong",{children:"unstable"})," if there exist ",e.jsx(s,{math:"x \\in X"})," and ",e.jsx(s,{math:"y \\in Y"})," ","such that:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx(s,{math:"xy \\notin M"})," (they are not matched to each other)"]}),e.jsxs("li",{children:[e.jsx(s,{math:"x"})," prefers ",e.jsx(s,{math:"y"})," to"," ",e.jsx(s,{math:"x"}),"'s partner in ",e.jsx(s,{math:"M"})," (or"," ",e.jsx(s,{math:"x"})," is unmatched)"]}),e.jsxs("li",{children:[e.jsx(s,{math:"y"})," prefers ",e.jsx(s,{math:"x"})," to"," ",e.jsx(s,{math:"y"}),"'s partner in ",e.jsx(s,{math:"M"})," (or"," ",e.jsx(s,{math:"y"})," is unmatched)"]})]}),e.jsxs("p",{className:"mt-2",children:["Such a pair ",e.jsx(s,{math:"(x, y)"})," is called a"," ",e.jsx("strong",{children:"blocking pair"}),". A matching is ",e.jsx("strong",{children:"stable"})," if it has no blocking pairs."]})]}),e.jsxs(i,{title:"The Roommate Problem",children:[e.jsx("p",{children:"Consider three people: Alice (A), Bob (B), and Carol (C). Suppose:"}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsx("li",{children:"A's preference: B > C"}),e.jsx("li",{children:"B's preference: C > A"}),e.jsx("li",{children:"C's preference: A > B"})]}),e.jsx("p",{className:"mt-2",children:"In any pairing, one person is left out. If we pair A-B, then C is alone, but B prefers C to A and C prefers B to being alone—blocking pair! Similarly for other pairings. No stable matching exists."}),e.jsx("p",{className:"mt-2 text-dark-300",children:"The bipartite version (with two disjoint groups) always has a stable matching."})]}),e.jsxs(a,{title:"Gale-Shapley Theorem (Theorem 3.2.17)",children:[e.jsx("p",{children:"Every bipartite preference system has a stable matching."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:"We prove the Gale-Shapley (proposal) algorithm produces a stable matching."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Termination:"})," Each proposal is made at most once (a proposer never re-proposes to someone who rejected them). With ",e.jsx(s,{math:"n"})," ","proposers and ",e.jsx(s,{math:"n"})," receivers, there are at most"," ",e.jsx(s,{math:"n^2"})," proposals, so the algorithm terminates."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Completeness:"})," We show all proposers are matched at termination. Suppose proposer ",e.jsx(s,{math:"x"})," is unmatched. Then ",e.jsx(s,{math:"x"})," ","proposed to everyone and was rejected by all. Since a receiver only rejects when they have a better partner, every receiver is matched. But then all"," ",e.jsx(s,{math:"n"})," receivers are matched to ",e.jsx(s,{math:"n - 1"})," ","proposers—contradiction."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Stability:"})," Suppose ",e.jsx(s,{math:"(x, y)"})," is a blocking pair: ",e.jsx(s,{math:"x"})," prefers ",e.jsx(s,{math:"y"})," to"," ",e.jsx(s,{math:"x"}),"'s partner, and ",e.jsx(s,{math:"y"})," prefers"," ",e.jsx(s,{math:"x"})," to ",e.jsx(s,{math:"y"}),"'s partner."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(s,{math:"x"})," prefers ",e.jsx(s,{math:"y"})," to their current partner, ",e.jsx(s,{math:"x"})," must have proposed to ",e.jsx(s,{math:"y"})," ","before proposing to their current partner (proposers go down their preference list). So ",e.jsx(s,{math:"y"})," rejected ",e.jsx(s,{math:"x"})," at some point."]}),e.jsxs("p",{className:"mt-2",children:['But receivers only reject for someone they prefer more, and once matched to someone, they only "trade up." So ',e.jsx(s,{math:"y"}),"'s final partner is at least as preferred as whoever caused ",e.jsx(s,{math:"y"})," to reject"," ",e.jsx(s,{math:"x"}),". Thus ",e.jsx(s,{math:"y"})," does not prefer"," ",e.jsx(s,{math:"x"})," to their partner—contradicting our assumption."]})]})]})]}),e.jsxs(t,{title:"Gale-Shapley Algorithm (Proposal Algorithm)",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," Bipartite preference system with sets"," ",e.jsx(s,{math:"X"})," (proposers) and ",e.jsx(s,{math:"Y"})," ","(receivers)."]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsx("li",{children:"All vertices are initially free."}),e.jsxs("li",{children:["While some ",e.jsx(s,{math:"x \\in X"})," is free and hasn't proposed to everyone:",e.jsxs("ul",{className:"ml-4 list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx(s,{math:"x"})," proposes to their most-preferred"," ",e.jsx(s,{math:"y"})," not yet proposed to."]}),e.jsxs("li",{children:["If ",e.jsx(s,{math:"y"})," is free, tentatively match"," ",e.jsx(s,{math:"x"})," and ",e.jsx(s,{math:"y"}),"."]}),e.jsxs("li",{children:["If ",e.jsx(s,{math:"y"})," prefers ",e.jsx(s,{math:"x"})," to their current partner ",e.jsx(s,{math:"x'"}),", replace:"," ",e.jsx(s,{math:"x'"})," becomes free, ",e.jsx(s,{math:"x"})," and"," ",e.jsx(s,{math:"y"})," are matched."]}),e.jsxs("li",{children:["Otherwise, ",e.jsx(s,{math:"x"})," remains free."]})]})]}),e.jsx("li",{children:"Return the final matching."})]})]}),e.jsxs(a,{title:"Theorem 3.2.18 (Properties of Gale-Shapley)",children:[e.jsx("p",{children:"The Gale-Shapley algorithm:"}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Always terminates with a stable matching in ",e.jsx(s,{math:"O(n^2)"})," ","time."]}),e.jsxs("li",{children:["Produces the ",e.jsx("strong",{children:"proposer-optimal"})," stable matching: each proposer gets their best partner among all stable matchings."]}),e.jsxs("li",{children:["Produces the ",e.jsx("strong",{children:"receiver-pessimal"})," stable matching: each receiver gets their worst partner among all stable matchings."]})]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Part 1:"})," Shown in the proof of Theorem 3.2.17. At most"," ",e.jsx(s,{math:"n^2"})," proposals, each taking ",e.jsx(s,{math:"O(1)"})," ","time with proper data structures."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 2 (Proposer-optimal):"})," Call ",e.jsx(s,{math:"y"})," a"," ",e.jsx("em",{children:"valid partner"})," for ",e.jsx(s,{math:"x"})," if some stable matching pairs them. We show each proposer is matched to their best valid partner."]}),e.jsxs("p",{className:"mt-2",children:["Suppose some proposer ",e.jsx(s,{math:"x"})," is rejected by a valid partner during the algorithm. Consider the first such rejection: ",e.jsx(s,{math:"y"})," ","rejects ",e.jsx(s,{math:"x"})," for ",e.jsx(s,{math:"x'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"M"})," be a stable matching where"," ",e.jsx(s,{math:"x"})," is paired with ",e.jsx(s,{math:"y"}),". In"," ",e.jsx(s,{math:"M"}),", let ",e.jsx(s,{math:"x'"})," be paired with"," ",e.jsx(s,{math:"y'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since this is the first rejection by a valid partner, ",e.jsx(s,{math:"x'"})," ","has not yet been rejected by any valid partner. So ",e.jsx(s,{math:"x'"})," ","prefers ",e.jsx(s,{math:"y"})," to ",e.jsx(s,{math:"y'"})," (otherwise"," ",e.jsx(s,{math:"x'"})," would have proposed to ",e.jsx(s,{math:"y'"})," first)."]}),e.jsxs("p",{className:"mt-2",children:["Also, ",e.jsx(s,{math:"y"})," prefers ",e.jsx(s,{math:"x'"})," to"," ",e.jsx(s,{math:"x"})," (that's why ",e.jsx(s,{math:"y"})," rejected"," ",e.jsx(s,{math:"x"}),")."]}),e.jsxs("p",{className:"mt-2",children:["But then ",e.jsx(s,{math:"(x', y)"})," is a blocking pair for"," ",e.jsx(s,{math:"M"}),"—contradiction. So no proposer is ever rejected by a valid partner."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 3 (Receiver-pessimal):"})," Let ",e.jsx(s,{math:"M"})," be the proposer-optimal matching. Suppose receiver ",e.jsx(s,{math:"y"})," is matched to ",e.jsx(s,{math:"x"})," in ",e.jsx(s,{math:"M"})," but prefers"," ",e.jsx(s,{math:"x"})," less than some partner ",e.jsx(s,{math:"x'"})," in another stable matching ",e.jsx(s,{math:"M'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["In ",e.jsx(s,{math:"M'"}),", proposer ",e.jsx(s,{math:"x"})," is matched to some"," ",e.jsx(s,{math:"y' \\neq y"}),". Since ",e.jsx(s,{math:"M"})," is proposer-optimal,"," ",e.jsx(s,{math:"x"})," prefers ",e.jsx(s,{math:"y"})," to ",e.jsx(s,{math:"y'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["But ",e.jsx(s,{math:"y"})," prefers ",e.jsx(s,{math:"x'"})," to"," ",e.jsx(s,{math:"x"}),", so ",e.jsx(s,{math:"(x, y)"})," blocks"," ",e.jsx(s,{math:"M'"}),"—contradiction."]})]})]})]}),e.jsxs(i,{title:"Medical Residency Matching",children:[e.jsx("p",{children:"The National Resident Matching Program (NRMP) uses a variant of Gale-Shapley to match medical school graduates to residency programs. Each year, about 40,000 applicants and 30,000 positions are matched."}),e.jsx("p",{className:"mt-2",children:"Originally hospitals proposed (giving hospitals their optimal matching). Now applicants propose, giving applicants better outcomes on average."}),e.jsx("p",{className:"mt-2 text-dark-300",children:"Alvin Roth, Lloyd Shapley, and David Gale received the 2012 Nobel Prize in Economics partly for this work."})]}),e.jsx("h2",{children:"Min-Max Theorems"}),e.jsx("p",{children:'The König-Egerváry Theorem shows that maximum matching equals minimum vertex cover in bipartite graphs. Such "min-max" relations are fundamental in combinatorial optimization.'}),e.jsx(t,{title:"Min-Max Theorem",children:e.jsxs("p",{children:["A ",e.jsx("strong",{children:"min-max theorem"})," states that the maximum value of one optimization problem equals the minimum value of a related problem. Finding an optimal solution to either problem proves optimality for both."]})}),e.jsx("p",{children:"For matchings in bipartite graphs, several min-max relations hold:"}),e.jsxs(a,{title:"Summary of Min-Max Relations",children:[e.jsxs("p",{children:["For an ",e.jsx(s,{math:"X, Y"}),"-bigraph ",e.jsx(s,{math:"G"}),":"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside space-y-1",children:[e.jsxs("li",{children:[e.jsx(s,{math:"\\alpha'(G) = \\beta(G)"})," (König-Egerváry)"]}),e.jsxs("li",{children:[e.jsx(s,{math:"\\alpha(G) = n(G) - \\beta(G)"})," (Gallai)"]}),e.jsx("li",{children:"Maximum matching = Minimum vertex cover"}),e.jsxs("li",{children:["Maximum independent set = ",e.jsx(s,{math:"n"})," − Minimum vertex cover"]})]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Augmenting Path Algorithm:"})," Finds maximum matching in"," ",e.jsx(s,{math:"O(mn)"})," by repeatedly finding and using augmenting paths."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hopcroft-Karp:"})," Improves to"," ",e.jsx(s,{math:"O(m\\sqrt{n})"})," by finding multiple shortest augmenting paths per phase."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Weighted Matching:"})," The Hungarian algorithm solves the assignment problem in ",e.jsx(s,{math:"O(n^3)"})," using feasible labelings."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Stable Matching:"})," Gale-Shapley always finds a stable matching in bipartite systems. The proposing side gets their optimal outcome."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Applications:"})," Job assignment, organ donation, medical residency matching, online advertising, and more."]})]})]})}export{d as default};
