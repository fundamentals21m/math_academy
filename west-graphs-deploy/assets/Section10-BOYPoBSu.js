import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as i,D as n,T as s,E as r}from"./ContentBlocks-BAFtEaU8.js";import{I as t,M as a}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function j(){return e.jsxs(i,{sectionId:10,children:[e.jsxs("p",{children:["Hall's Theorem and the König-Egerváry Theorem apply only to bipartite graphs. For general graphs, characterizing perfect matchings is more subtle. The key difficulty is the presence of odd cycles, which leads to Tutte's elegant characterization. We also study ",e.jsx(t,{math:"f"}),"-factors, which generalize matchings."]}),e.jsx("h2",{children:"Tutte's 1-Factor Theorem"}),e.jsxs("p",{children:["Recall that a perfect matching is also called a ",e.jsx("strong",{children:"1-factor"}),": a 1-regular spanning subgraph. When does a graph have a 1-factor?"]}),e.jsx(n,{title:"Odd Components",children:e.jsxs("p",{children:["For a graph ",e.jsx(t,{math:"G"})," and vertex subset"," ",e.jsx(t,{math:"S \\subseteq V(G)"}),", let"," ",e.jsx(t,{math:"o(G - S)"})," denote the number of ",e.jsx("strong",{children:"odd components"})," ","of ",e.jsx(t,{math:"G - S"})," (components with an odd number of vertices)."]})}),e.jsxs("p",{children:["The key observation is that a perfect matching must match vertices within each component or match them to ",e.jsx(t,{math:"S"}),". In an odd component, at least one vertex must be matched to ",e.jsx(t,{math:"S"}),"."]}),e.jsxs(s,{title:"Tutte's 1-Factor Theorem (Theorem 3.3.3)",children:[e.jsxs("p",{children:["A graph ",e.jsx(t,{math:"G"})," has a 1-factor (perfect matching) if and only if for every ",e.jsx(t,{math:"S \\subseteq V(G)"}),":"]}),e.jsx(a,{math:"o(G - S) \\leq |S|"}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["This is called ",e.jsx("strong",{children:"Tutte's Condition"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof (Necessity)"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["If ",e.jsx(t,{math:"G"})," has a perfect matching ",e.jsx(t,{math:"M"}),", consider any ",e.jsx(t,{math:"S \\subseteq V(G)"}),". Each odd component of"," ",e.jsx(t,{math:"G - S"})," has an odd number of vertices, so in any matching of its vertices, at least one must match outside the component."]}),e.jsxs("p",{className:"mt-2",children:["Since vertices in odd components can only match to ",e.jsx(t,{math:"S"})," ","(they can't match to even components or other odd components), we need at least ",e.jsx(t,{math:"o(G - S)"})," vertices in ",e.jsx(t,{math:"S"}),". Thus ",e.jsx(t,{math:"o(G - S) \\leq |S|"}),"."]})]})]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof (Sufficiency - Sketch)"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["The sufficiency proof uses a clever argument. Assume Tutte's condition holds but ",e.jsx(t,{math:"G"})," has no perfect matching. Among all such graphs, consider one with the maximum number of edges (adding edges can only help create a matching)."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(t,{math:"G"})," is edge-maximal, for any non-edge"," ",e.jsx(t,{math:"uv"}),", the graph ",e.jsx(t,{math:"G + uv"})," has a perfect matching using ",e.jsx(t,{math:"uv"}),". This forces"," ",e.jsx(t,{math:"G"})," to be a union of complete graphs joined in a specific way, but then we can construct a perfect matching—contradiction."]})]})]})]}),e.jsxs(r,{title:"Petersen Graph",children:[e.jsx("p",{children:"The Petersen graph has 10 vertices and is 3-regular. Does it have a perfect matching?"}),e.jsxs("p",{className:"mt-2",children:["We check Tutte's condition. By symmetry, it suffices to check a few cases. Taking ",e.jsx(t,{math:"S = \\emptyset"})," gives one component (connected graph) with 10 vertices—even, so ",e.jsx(t,{math:"o(G) = 0 \\leq 0"}),". ✓"]}),e.jsx("p",{className:"mt-2",children:"After checking all relevant subsets (by symmetry arguments), Tutte's condition holds. The Petersen graph has a perfect matching—in fact, it has exactly 6 perfect matchings."})]}),e.jsx("h3",{children:"Deficiency and Maximum Matchings"}),e.jsxs(n,{title:"Deficiency",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"deficiency"})," of graph ",e.jsx(t,{math:"G"})," is:"]}),e.jsx(a,{math:"\\text{def}(G) = \\max_{S \\subseteq V(G)} \\left( o(G - S) - |S| \\right)"}),e.jsxs("p",{className:"mt-2",children:["By Tutte's condition, ",e.jsx(t,{math:"G"})," has a perfect matching iff"," ",e.jsx(t,{math:"\\text{def}(G) = 0"}),"."]})]}),e.jsxs(s,{title:"Berge-Tutte Formula (Theorem 3.3.17)",children:[e.jsxs("p",{children:["For any graph ",e.jsx(t,{math:"G"}),":"]}),e.jsx(a,{math:"\\alpha'(G) = \\frac{1}{2}\\left( n(G) - \\text{def}(G) \\right)"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(t,{math:"\\alpha'(G)"})," is the maximum matching number."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["This generalizes both Hall's Theorem (for bipartite graphs) and Tutte's Theorem (when ",e.jsx(t,{math:"\\text{def}(G) = 0"}),")."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Upper bound:"})," Let ",e.jsx(t,{math:"S"})," achieve the deficiency: ",e.jsx(t,{math:"o(G - S) - |S| = \\text{def}(G)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Any matching ",e.jsx(t,{math:"M"})," can saturate at most"," ",e.jsx(t,{math:"|S|"})," vertices from the ",e.jsx(t,{math:"o(G - S)"})," ","odd components (each odd component needs at least one vertex matched to"," ",e.jsx(t,{math:"S"}),"). Thus at least"," ",e.jsx(t,{math:"o(G - S) - |S| = \\text{def}(G)"})," vertices from odd components remain unsaturated."]}),e.jsxs("p",{className:"mt-2",children:["Therefore, ",e.jsx(t,{math:"M"})," saturates at most"," ",e.jsx(t,{math:"n(G) - \\text{def}(G)"})," vertices, giving:"]}),e.jsx(a,{math:"\\alpha'(G) \\leq \\frac{1}{2}(n(G) - \\text{def}(G))"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Lower bound:"})," Construct a new graph"," ",e.jsx(t,{math:"G'"})," from ",e.jsx(t,{math:"G"})," by adding"," ",e.jsx(t,{math:"\\text{def}(G)"})," new vertices, each adjacent to all original vertices."]}),e.jsxs("p",{className:"mt-2",children:["We verify ",e.jsx(t,{math:"G'"})," satisfies Tutte's condition. For any"," ",e.jsx(t,{math:"T \\subseteq V(G')"}),", if ",e.jsx(t,{math:"T"})," ","contains all new vertices, then"," ",e.jsx(t,{math:"o(G' - T) = o(G - S)"})," where"," ",e.jsx(t,{math:"S = T \\cap V(G)"}),". Since ",e.jsx(t,{math:"|T| \\geq \\text{def}(G) + |S|"}),":"]}),e.jsx(a,{math:"o(G' - T) = o(G - S) \\leq |S| + \\text{def}(G) \\leq |T|"}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(t,{math:"T"})," is missing some new vertex ",e.jsx(t,{math:"w"}),", then ",e.jsx(t,{math:"w"})," is adjacent to all of ",e.jsx(t,{math:"G - S"}),", so ",e.jsx(t,{math:"G' - T"})," has at most one component—condition satisfied."]}),e.jsxs("p",{className:"mt-2",children:["By Tutte's Theorem, ",e.jsx(t,{math:"G'"})," has a perfect matching"," ",e.jsx(t,{math:"M'"}),". Restricting to ",e.jsx(t,{math:"G"})," gives a matching of size"," ",e.jsx(t,{math:"\\frac{1}{2}(n(G) + \\text{def}(G)) - \\text{def}(G) = \\frac{1}{2}(n(G) - \\text{def}(G))"}),"."]})]})]})]}),e.jsxs("h2",{children:["Factors and ",e.jsx(t,{math:"f"}),"-Factors"]}),e.jsx("p",{children:"A matching saturates each vertex at most once. What if we want to saturate each vertex a specified number of times?"}),e.jsxs(n,{title:"f-Factor",children:[e.jsxs("p",{children:["Given a function ",e.jsx(t,{math:"f: V(G) \\to \\mathbb{Z}_{\\geq 0}"}),", an"," ",e.jsxs("strong",{children:[e.jsx(t,{math:"f"}),"-factor"]})," ","of graph ",e.jsx(t,{math:"G"})," is a spanning subgraph ",e.jsx(t,{math:"H"})," ","such that ",e.jsx(t,{math:"d_H(v) = f(v)"})," for every vertex"," ",e.jsx(t,{math:"v"}),"."]}),e.jsx("p",{className:"mt-2",children:"Special cases:"}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["A ",e.jsx("strong",{children:"1-factor"})," is a perfect matching (",e.jsx(t,{math:"f \\equiv 1"}),")."]}),e.jsxs("li",{children:["A ",e.jsx("strong",{children:"2-factor"})," is a spanning union of cycles (",e.jsx(t,{math:"f \\equiv 2"}),")."]}),e.jsxs("li",{children:["A ",e.jsxs("strong",{children:[e.jsx(t,{math:"k"}),"-factor"]})," ","is a ",e.jsx(t,{math:"k"}),"-regular spanning subgraph (",e.jsx(t,{math:"f \\equiv k"}),")."]})]})]}),e.jsxs(s,{title:"2-Factor Theorem (Theorem 3.3.9)",children:[e.jsxs("p",{children:["Every ",e.jsx(t,{math:"k"}),"-regular bipartite graph has a 2-factor."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsx("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:e.jsxs("p",{children:["By the König-Egerváry Theorem and Hall's Theorem, every regular bipartite graph has a perfect matching. Remove this matching to get a"," ",e.jsx(t,{math:"(k-1)"}),"-regular bipartite graph, which again has a perfect matching. The union of these two perfect matchings is a 2-factor."]})})]})]}),e.jsxs(s,{title:"Petersen's Theorem (Theorem 3.3.7)",children:[e.jsx("p",{children:"Every 3-regular graph with no cut-edge has a perfect matching."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsx("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:e.jsxs("p",{children:["Verify Tutte's condition. For any ",e.jsx(t,{math:"S"}),", each odd component of ",e.jsx(t,{math:"G - S"})," has an odd total degree from"," ",e.jsx(t,{math:"S"})," (since internal degrees sum to even). Being 3-regular with no cut-edge provides enough connectivity to ensure"," ",e.jsx(t,{math:"o(G - S) \\leq |S|"}),"."]})})]})]}),e.jsxs("h3",{children:["General ",e.jsx(t,{math:"f"}),"-Factor Theorem"]}),e.jsxs(s,{title:"Tutte's f-Factor Theorem (Theorem 3.3.25)",children:[e.jsxs("p",{children:["Let ",e.jsx(t,{math:"f: V(G) \\to \\mathbb{Z}_{\\geq 0}"}),". The graph"," ",e.jsx(t,{math:"G"})," has an ",e.jsx(t,{math:"f"}),"-factor if and only if for every ",e.jsx(t,{math:"S, T \\subseteq V(G)"})," with"," ",e.jsx(t,{math:"S \\cap T = \\emptyset"}),":"]}),e.jsx(a,{math:"\\sum_{v \\in S} f(v) + \\sum_{v \\in T} (d_G(v) - f(v)) - e_G(S, T) - q(S, T) \\geq 0"}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["Here ",e.jsx(t,{math:"e_G(S, T)"})," is the number of edges between"," ",e.jsx(t,{math:"S"})," and ",e.jsx(t,{math:"T"}),", and"," ",e.jsx(t,{math:"q(S, T)"}),' counts certain "bad" components of'," ",e.jsx(t,{math:"G - S - T"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:"The proof reduces to Tutte's 1-factor theorem via a clever construction."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Construction:"})," Build a bipartite graph"," ",e.jsx(t,{math:"H"})," from ",e.jsx(t,{math:"G"})," as follows. For each vertex ",e.jsx(t,{math:"v \\in V(G)"}),", create ",e.jsx(t,{math:"f(v)"})," ","copies in one partite set ",e.jsx(t,{math:"A"})," and"," ",e.jsx(t,{math:"d_G(v) - f(v)"})," copies in the other set"," ",e.jsx(t,{math:"B"}),". For each edge ",e.jsx(t,{math:"uv \\in E(G)"}),", add a complete bipartite graph between the ",e.jsx(t,{math:"B"}),"-copies of ",e.jsx(t,{math:"u"})," and the ",e.jsx(t,{math:"A"}),"-copies of"," ",e.jsx(t,{math:"v"}),", and vice versa."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Equivalence:"})," An ",e.jsx(t,{math:"f"}),"-factor in"," ",e.jsx(t,{math:"G"})," corresponds to a perfect matching in"," ",e.jsx(t,{math:"H"}),". The condition for ",e.jsx(t,{math:"H"})," to have a perfect matching (via Hall's condition) translates to the given inequality."]}),e.jsxs("p",{className:"mt-2",children:[e.jsxs("strong",{children:["Bad components ",e.jsx(t,{math:"q(S, T)"}),":"]})," A component"," ",e.jsx(t,{math:"C"})," of ",e.jsx(t,{math:"G - S - T"}),' is "bad" if the sum ',e.jsx(t,{math:"\\sum_{v \\in C} f(v) + e_G(C, T)"})," has different parity than ",e.jsx(t,{math:"|C|"}),". Such components contribute an extra deficit that must be accounted for."]}),e.jsxs("p",{className:"mt-2",children:["The detailed verification requires careful counting arguments showing that violations of the inequality correspond to obstructions to finding a perfect matching in ",e.jsx(t,{math:"H"}),"."]})]})]})]}),e.jsx("h2",{children:"Edmonds' Matching Algorithm"}),e.jsx("p",{children:`For general (non-bipartite) graphs, finding maximum matchings is more complex due to odd cycles. Jack Edmonds' breakthrough "blossom algorithm" handles this.`}),e.jsxs(n,{title:"Blossom",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"blossom"})," is an odd cycle in which every other edge (except one) belongs to the current matching. The cycle has"," ",e.jsx(t,{math:"2k + 1"})," vertices with ",e.jsx(t,{math:"k"})," matched edges."]}),e.jsxs("p",{className:"mt-2",children:["The key insight: a blossom can be ",e.jsx("strong",{children:"contracted"})," to a single vertex without affecting the existence of augmenting paths."]})]}),e.jsxs(r,{title:"A Simple Blossom",children:[e.jsxs("p",{children:["Consider a 5-cycle ",e.jsx(t,{math:"v_1, v_2, v_3, v_4, v_5"})," with matching"," ",e.jsx(t,{math:"M = \\{v_2v_3, v_4v_5\\}"}),". The vertex"," ",e.jsx(t,{math:"v_1"})," is unsaturated."]}),e.jsxs("p",{className:"mt-2",children:["If we're searching for an augmenting path and reach ",e.jsx(t,{math:"v_1"}),", we can enter the cycle through either ",e.jsx(t,{math:"v_2"})," or"," ",e.jsx(t,{math:"v_5"}),". By contracting the blossom, we simplify the search."]})]}),e.jsxs(n,{title:"Edmonds' Blossom Algorithm",children:[e.jsx("p",{children:"The algorithm maintains:"}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["A current matching ",e.jsx(t,{math:"M"})]}),e.jsx("li",{children:"A forest of alternating trees rooted at unsaturated vertices"})]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Process:"})}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsx("li",{children:"Build alternating trees from unsaturated vertices."}),e.jsxs("li",{children:["If two trees connect via a non-matching edge to an unsaturated vertex:"," ",e.jsx("strong",{children:"augmenting path found"}),"—augment and restart."]}),e.jsxs("li",{children:["If two even-level vertices in the same tree are connected:"," ",e.jsx("strong",{children:"blossom detected"}),"—contract it and continue."]}),e.jsxs("li",{children:["When no more growth possible, ",e.jsx(t,{math:"M"})," is maximum."]}),e.jsx("li",{children:"Expand blossoms to recover the actual matching."})]})]}),e.jsxs(s,{title:"Theorem 3.3.21 (Edmonds' Algorithm)",children:[e.jsxs("p",{children:["Edmonds' blossom algorithm correctly finds a maximum matching in any graph"," ",e.jsx(t,{math:"G"})," in ",e.jsx(t,{math:"O(n^2 m)"})," time."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["With better data structures (Micali-Vazirani), this improves to"," ",e.jsx(t,{math:"O(m\\sqrt{n})"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," The key insight is that blossom contraction preserves the existence of augmenting paths. We prove two claims:"]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("em",{children:"Claim 1:"})," If ",e.jsx(t,{math:"G"})," has an"," ",e.jsx(t,{math:"M"}),"-augmenting path, then the contracted graph"," ",e.jsx(t,{math:"G/B"})," has an ",e.jsx(t,{math:"M/B"}),"-augmenting path, where ",e.jsx(t,{math:"B"})," is a blossom."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("em",{children:"Proof of Claim 1:"})," An augmenting path either avoids"," ",e.jsx(t,{math:"B"})," (unchanged after contraction) or enters and exits"," ",e.jsx(t,{math:"B"}),". In the latter case, since ",e.jsx(t,{math:"B"})," ","is an odd cycle with alternating matched/unmatched edges, we can traverse"," ",e.jsx(t,{math:"B"})," maintaining the alternating property. After contraction, the path visits the contracted vertex."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("em",{children:"Claim 2:"})," An augmenting path in ",e.jsx(t,{math:"G/B"}),' can be "lifted" to an augmenting path in ',e.jsx(t,{math:"G"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("em",{children:"Proof of Claim 2:"})," If the path visits the blossom vertex in"," ",e.jsx(t,{math:"G/B"}),", we expand it by routing through"," ",e.jsx(t,{math:"B"})," appropriately. The odd structure of"," ",e.jsx(t,{math:"B"})," ensures we can enter and exit while maintaining alternation."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Time analysis:"})," We perform at most"," ",e.jsx(t,{math:"n/2"})," augmentations. Each augmentation involves building alternating trees, which takes ",e.jsx(t,{math:"O(nm)"})," time (each edge examined ",e.jsx(t,{math:"O(n)"})," times due to blossom contractions). Total: ",e.jsx(t,{math:"O(n^2 m)"}),"."]}),e.jsxs("p",{className:"mt-2",children:['More sophisticated implementations using the "blossom-shrinking" technique with better bookkeeping achieve ',e.jsx(t,{math:"O(n^3)"})," or"," ",e.jsx(t,{math:"O(m\\sqrt{n})"})," with Micali-Vazirani."]})]})]})]}),e.jsxs(r,{title:"Finding Maximum Matching",children:[e.jsxs("p",{children:["Consider a graph with vertices ",e.jsx(t,{math:"\\{1, 2, 3, 4, 5\\}"})," and edges forming a 5-cycle plus edge 1-3. Start with"," ",e.jsx(t,{math:"M = \\{2-3, 4-5\\}"}),"."]}),e.jsx("p",{className:"mt-2",children:"Build an alternating tree from vertex 1 (unsaturated). Vertices 2 and 5 are reached via non-matching edges. Following matching edges reaches 3 and 4. The edge 1-3 creates a blossom (odd cycle 1-2-3-1 through the 5-cycle)."}),e.jsxs("p",{className:"mt-2",children:["After contraction and expansion, we find"," ",e.jsx(t,{math:"M' = \\{1-2, 3-4\\}"})," leaves vertex 5 unsaturated. Maximum matching has size 2 for this 5-vertex graph."]})]}),e.jsx("h2",{children:"Applications"}),e.jsx("h3",{children:"Scheduling Problems"}),e.jsxs("p",{children:["Many scheduling problems reduce to matching. For example, scheduling"," ",e.jsx(t,{math:"n"})," tasks on ",e.jsx(t,{math:"m"})," machines where each task can only run on certain machines is bipartite matching. With time constraints, we may need general matching theory."]}),e.jsx("h3",{children:"Network Design"}),e.jsxs("p",{children:["Constructing networks where every node has exactly ",e.jsx(t,{math:"k"})," ","connections is a ",e.jsx(t,{math:"k"}),"-factor problem. This appears in designing reliable communication networks."]}),e.jsx("h3",{children:"Chemistry"}),e.jsx("p",{children:"In organic chemistry, molecular graphs represent atoms as vertices and bonds as edges. A perfect matching corresponds to a valid electron pairing (resonance structure). Benzenoid graphs always have perfect matchings by Tutte's theorem."}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Tutte's Condition:"})," A graph has a perfect matching iff"," ",e.jsx(t,{math:"o(G - S) \\leq |S|"})," for all"," ",e.jsx(t,{math:"S \\subseteq V(G)"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Berge-Tutte Formula:"})," ",e.jsx(t,{math:"\\alpha'(G) = \\frac{1}{2}(n(G) - \\text{def}(G))"})," gives maximum matching size."]}),e.jsxs("li",{children:[e.jsxs("strong",{children:[e.jsx(t,{math:"f"}),"-factors:"]})," ","Generalize matchings to specify degree at each vertex."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Petersen's Theorem:"})," 3-regular bridgeless graphs have perfect matchings."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Edmonds' Algorithm:"})," The blossom algorithm finds maximum matchings in general graphs by contracting odd cycles."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Key Difference from Bipartite:"})," Odd cycles create complications requiring the blossom contraction technique."]})]})]})}export{j as default};
