import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as a,E as n,T as t}from"./ContentBlocks-BAFtEaU8.js";import{I as s,M as i}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import{H as r}from"./HamiltonianFinder-Baj_YtFX.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function g(){return e.jsxs(h,{sectionId:21,children:[e.jsx("p",{children:"A Hamiltonian cycle visits every vertex exactly once and returns to start—the graph-theoretic version of the Traveling Salesman Problem. Unlike Eulerian circuits (which we characterized completely), there is no simple criterion for Hamiltonian cycles. We study sufficient conditions that guarantee existence and necessary conditions for specific graph families."}),e.jsx("h2",{children:"Hamiltonian Graphs"}),e.jsxs(a,{title:"Hamiltonian Path and Cycle",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"Hamiltonian path"})," is a path that visits every vertex exactly once."]}),e.jsxs("p",{className:"mt-2",children:["A ",e.jsx("strong",{children:"Hamiltonian cycle"})," is a cycle that visits every vertex exactly once."]}),e.jsxs("p",{className:"mt-2",children:["A graph is ",e.jsx("strong",{children:"Hamiltonian"})," if it has a Hamiltonian cycle."]})]}),e.jsx(n,{title:"Hamiltonian and Non-Hamiltonian Graphs",children:e.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Hamiltonian:"})," ",e.jsx(s,{math:"K_n"})," (",e.jsx(s,{math:"n \\geq 3"}),"), ",e.jsx(s,{math:"C_n"}),","," ",e.jsx(s,{math:"K_{n,n}"})," (",e.jsx(s,{math:"n \\geq 2"}),"), cube graph, dodecahedron"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Non-Hamiltonian:"})," ",e.jsx(s,{math:"K_{m,n}"})," (",e.jsx(s,{math:"m \\neq n"}),"), Petersen graph, any graph with a cut-vertex, bipartite graphs with unequal parts"]})]})}),e.jsx(r,{className:"my-8"}),e.jsx("h2",{children:"Necessary Conditions"}),e.jsxs(t,{title:"Necessary Condition 1",children:[e.jsxs("p",{children:["If ",e.jsx(s,{math:"G"})," is Hamiltonian and ",e.jsx(s,{math:"S"})," is a proper nonempty subset of ",e.jsx(s,{math:"V(G)"}),", then the number of components of ",e.jsx(s,{math:"G - S"})," is at most"," ",e.jsx(s,{math:"|S|"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsx("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:e.jsxs("p",{children:["A Hamiltonian cycle visiting vertices of"," ",e.jsx(s,{math:"G - S"})," must pass through"," ",e.jsx(s,{math:"S"})," between consecutive components. Each transition uses at least one vertex of ",e.jsx(s,{math:"S"}),", so components ≤"," ",e.jsx(s,{math:"|S|"}),"."]})})]})]}),e.jsxs(n,{title:"Petersen Graph is Non-Hamiltonian",children:[e.jsx("p",{children:"The Petersen graph has 10 vertices and is 3-regular. Remove the 5 vertices of the outer pentagon: the remaining 5 vertices (inner star) form an independent set—5 isolated vertices!"}),e.jsxs("p",{className:"mt-2",children:["With ",e.jsx(s,{math:"|S| = 5"})," but 5 components, the necessary condition barely holds. A careful case analysis shows no Hamiltonian cycle exists."]})]}),e.jsxs(t,{title:"Bipartite Necessary Condition",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"A Hamiltonian cycle visits every vertex exactly once, alternating between the two parts of the bipartition."}),e.jsxs("p",{className:"mt-2",children:["In a bipartite graph ",e.jsx(s,{math:"G"})," with parts ",e.jsx(s,{math:"X"})," and"," ",e.jsx(s,{math:"Y"}),", every edge connects a vertex in ",e.jsx(s,{math:"X"})," to one in ",e.jsx(s,{math:"Y"}),"."]}),e.jsxs("p",{className:"mt-2",children:["A Hamiltonian cycle of length ",e.jsx(s,{math:"n = |X| + |Y|"})," must traverse edges alternating: ",e.jsx(s,{math:"x_1 - y_1 - x_2 - y_2 - \\cdots"})," and return to"," ",e.jsx(s,{math:"x_1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For the cycle to close (return from ",e.jsx(s,{math:"Y"})," to"," ",e.jsx(s,{math:"x_1 \\in X"}),"), we need equal numbers of vertices in each part. After visiting ",e.jsx(s,{math:"|X|"})," vertices from ",e.jsx(s,{math:"X"}),", we must have visited exactly ",e.jsx(s,{math:"|X|"})," vertices from"," ",e.jsx(s,{math:"Y"})," to return."]}),e.jsxs("p",{className:"mt-2",children:["Therefore ",e.jsx(s,{math:"|X| = |Y|"})," is necessary."]})]}),children:[e.jsxs("p",{children:["A bipartite graph ",e.jsx(s,{math:"G"})," with bipartition"," ",e.jsx(s,{math:"(X, Y)"})," has a Hamiltonian cycle only if"," ",e.jsx(s,{math:"|X| = |Y|"}),"."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["The Hamiltonian cycle must alternate between ",e.jsx(s,{math:"X"})," and"," ",e.jsx(s,{math:"Y"}),"."]})]}),e.jsx("h2",{children:"Sufficient Conditions"}),e.jsxs(t,{title:"Dirac's Theorem (Theorem 7.2.1)",children:[e.jsxs("p",{children:["If ",e.jsx(s,{math:"G"})," is a simple graph with ",e.jsx(s,{math:"n \\geq 3"})," ","vertices and ",e.jsx(s,{math:"\\delta(G) \\geq n/2"}),", then"," ",e.jsx(s,{math:"G"})," is Hamiltonian."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{math:"P = v_1 v_2 \\cdots v_k"})," be a longest path. If"," ",e.jsx(s,{math:"k < n"}),", all neighbors of ",e.jsx(s,{math:"v_1"})," and"," ",e.jsx(s,{math:"v_k"})," are on ",e.jsx(s,{math:"P"})," (else extend)."]}),e.jsxs("p",{className:"mt-2",children:["By pigeonhole with ",e.jsx(s,{math:"\\delta \\geq n/2"}),", there exists"," ",e.jsx(s,{math:"v_i"})," where ",e.jsx(s,{math:"v_1 v_{i+1}"})," and"," ",e.jsx(s,{math:"v_k v_i"})," are edges. This creates a cycle covering"," ",e.jsx(s,{math:"P"}),". Since ",e.jsx(s,{math:"k < n"}),", an uncovered vertex is adjacent to the cycle, giving a longer path—contradiction."]})]})]})]}),e.jsx(n,{title:"Dirac's Theorem is Sharp",children:e.jsxs("p",{children:["Consider ",e.jsx(s,{math:"K_{n/2, n/2 + 1}"})," (with ",e.jsx(s,{math:"n"})," ","odd). This has ",e.jsx(s,{math:"\\delta = n/2"})," but is not Hamiltonian (unequal parts). So ",e.jsx(s,{math:"\\delta \\geq n/2"})," is best possible."]})}),e.jsxs(t,{title:"Ore's Theorem (Theorem 7.2.3)",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"The proof is similar to Dirac's, using the longest path argument."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 1:"})," Let ",e.jsx(s,{math:"P = v_1 v_2 \\cdots v_k"})," be a longest path in ",e.jsx(s,{math:"G"}),". If ",e.jsx(s,{math:"k < n"}),", all neighbors of"," ",e.jsx(s,{math:"v_1"})," and ",e.jsx(s,{math:"v_k"})," lie on ",e.jsx(s,{math:"P"})," ","(otherwise ",e.jsx(s,{math:"P"})," could be extended)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 2:"})," Form a cycle from ",e.jsx(s,{math:"P"}),". Let"," ",e.jsx(s,{math:"S = \\{'{'}i : v_1 v_{'{'}i+1{'}'} \\in E{'}'}"})," and"," ",e.jsx(s,{math:"T = \\{'{'}i : v_k v_i \\in E{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["We have ",e.jsx(s,{math:"|S| = d(v_1)"})," and ",e.jsx(s,{math:"|T| = d(v_k)"}),", both subsets of ",e.jsx(s,{math:"\\{'{'}1, \\ldots, k-1{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 3:"})," If ",e.jsx(s,{math:"v_1"})," and ",e.jsx(s,{math:"v_k"})," ","are non-adjacent, then ",e.jsx(s,{math:"d(v_1) + d(v_k) \\geq n > k - 1"})," by Ore's condition. By pigeonhole, ",e.jsx(s,{math:"S \\cap T \\neq \\emptyset"}),": some"," ",e.jsx(s,{math:"i \\in S \\cap T"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(s,{math:"v_1 v_{'{'}i+1{'}'} \\cdots v_k v_i \\cdots v_1"})," is a cycle covering ",e.jsx(s,{math:"P"}),". If ",e.jsx(s,{math:"k < n"}),", some vertex"," ",e.jsx(s,{math:"w \\notin P"})," is adjacent to the cycle, giving a longer path—contradiction."]})]}),children:[e.jsxs("p",{children:["If ",e.jsx(s,{math:"G"})," is a simple graph with ",e.jsx(s,{math:"n \\geq 3"})," ","vertices such that for every pair of non-adjacent vertices"," ",e.jsx(s,{math:"u, v"}),":"]}),e.jsx(i,{math:"d(u) + d(v) \\geq n"}),e.jsxs("p",{className:"mt-2",children:["then ",e.jsx(s,{math:"G"})," is Hamiltonian."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"Ore's condition is weaker than Dirac's (allows low-degree vertices if they're adjacent to everything)."})]}),e.jsx(a,{title:"Closure",children:e.jsxs("p",{children:["The ",e.jsx("strong",{children:"closure"})," ",e.jsx(s,{math:"cl(G)"})," of graph"," ",e.jsx(s,{math:"G"})," is obtained by repeatedly adding edges between non-adjacent vertices ",e.jsx(s,{math:"u, v"})," with"," ",e.jsx(s,{math:"d(u) + d(v) \\geq n"})," until no more can be added."]})}),e.jsxs(t,{title:"Bondy-Chvátal Theorem (Theorem 7.2.6)",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇐):"})," If ",e.jsx(s,{math:"cl(G)"})," is Hamiltonian, we show"," ",e.jsx(s,{math:"G"})," is Hamiltonian."]}),e.jsxs("p",{className:"mt-2",children:["Consider the last edge ",e.jsx(s,{math:"e = uv"})," added in forming"," ",e.jsx(s,{math:"cl(G)"})," from ",e.jsx(s,{math:"G"}),". Let"," ",e.jsx(s,{math:"H = cl(G) - e"}),". We had ",e.jsx(s,{math:"d_H(u) + d_H(v) \\geq n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"cl(G)"})," has a Hamiltonian cycle ",e.jsx(s,{math:"C"})," using"," ",e.jsx(s,{math:"e"}),", the Ore-type argument (from the proof of Ore's theorem) shows",e.jsx(s,{math:"H"})," also has a Hamiltonian cycle (using the pigeonhole argument on the path ",e.jsx(s,{math:"C - e"}),")."]}),e.jsxs("p",{className:"mt-2",children:["By induction backward through the closure construction, ",e.jsx(s,{math:"G"})," is Hamiltonian."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇒):"})," If ",e.jsx(s,{math:"G"})," is Hamiltonian, then"," ",e.jsx(s,{math:"cl(G) \\supseteq G"})," is also Hamiltonian (adding edges preserves Hamiltonian cycles)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Uniqueness:"})," The closure is the unique graph containing"," ",e.jsx(s,{math:"G"})," where no non-adjacent pair has degree sum ",e.jsx(s,{math:"\\geq n"}),"."]})]}),children:[e.jsxs("p",{children:["A graph ",e.jsx(s,{math:"G"})," is Hamiltonian if and only if"," ",e.jsx(s,{math:"cl(G)"})," is Hamiltonian."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"The closure is unique (independent of order of edge additions)."})]}),e.jsx(n,{title:"Using Closure",children:e.jsxs("p",{children:["If ",e.jsx(s,{math:"cl(G) = K_n"}),", then ",e.jsx(s,{math:"G"})," is Hamiltonian. This gives a simple sufficient condition checkable in polynomial time."]})}),e.jsx("h2",{children:"Degree Sequences"}),e.jsx(a,{title:"Hamiltonian Degree Sequence",children:e.jsxs("p",{children:["A degree sequence is ",e.jsx("strong",{children:"forcibly Hamiltonian"})," if every simple graph with that degree sequence is Hamiltonian."]})}),e.jsxs(t,{title:"Chvátal's Theorem (Theorem 7.2.8)",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We show any graph ",e.jsx(s,{math:"G"})," with this degree sequence has closure"," ",e.jsx(s,{math:"K_n"}),", hence is Hamiltonian by Bondy-Chvátal."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Claim:"})," If ",e.jsx(s,{math:"G"})," has the given degree sequence and ",e.jsx(s,{math:"u, v"})," are non-adjacent with ",e.jsx(s,{math:"d(u) \\leq d(v)"}),", then ",e.jsx(s,{math:"d(u) + d(v) \\geq n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Proof of claim:"})," Let ",e.jsx(s,{math:"d(u) = k"}),". Since"," ",e.jsx(s,{math:"u"})," is non-adjacent to ",e.jsx(s,{math:"v"}),","," ",e.jsx(s,{math:"u"})," has at most ",e.jsx(s,{math:"n - 2"})," neighbors."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"k < n/2"}),", then by the degree sequence condition, vertex ",e.jsx(s,{math:"v"})," (with ",e.jsx(s,{math:"d(v) \\geq d(u) = k"}),") has the property that the number of vertices with degree ",e.jsx(s,{math:"\\leq k"})," ","is at most ",e.jsx(s,{math:"k"}),". Thus ",e.jsx(s,{math:"d(v) \\geq n - k"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Therefore ",e.jsx(s,{math:"d(u) + d(v) \\geq k + (n-k) = n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This means the closure process adds edges until we reach ",e.jsx(s,{math:"K_n"}),", which is Hamiltonian."]})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(s,{math:"d_1 \\leq d_2 \\leq \\cdots \\leq d_n"})," be a degree sequence with ",e.jsx(s,{math:"n \\geq 3"}),". If for all"," ",e.jsx(s,{math:"k < n/2"}),":"]}),e.jsx(i,{math:"d_k \\leq k \\implies d_{n-k} \\geq n - k"}),e.jsx("p",{className:"mt-2",children:"then the sequence is forcibly Hamiltonian."})]}),e.jsx("h2",{children:"Hamiltonian Paths"}),e.jsx(t,{title:"Path Version of Dirac",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We use a similar argument to Dirac's theorem for cycles."}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"P = v_1 v_2 \\cdots v_k"})," be a longest path in"," ",e.jsx(s,{math:"G"}),". If ",e.jsx(s,{math:"k = n"}),", we're done."]}),e.jsxs("p",{className:"mt-2",children:["Suppose ",e.jsx(s,{math:"k < n"}),". All neighbors of ",e.jsx(s,{math:"v_1"})," ","and ",e.jsx(s,{math:"v_k"})," lie on ",e.jsx(s,{math:"P"})," (else"," ",e.jsx(s,{math:"P"})," could be extended)."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"S = \\{'{'}i : v_1 v_{'{'}i+1{'}'} \\in E{'}'}"})," and"," ",e.jsx(s,{math:"T = \\{'{'}i : v_k v_i \\in E{'}'}"}),". Both are subsets of"," ",e.jsx(s,{math:"\\{'{'}1, \\ldots, k-1{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(s,{math:"|S| \\geq (n-1)/2"})," and ",e.jsx(s,{math:"|T| \\geq (n-1)/2"}),", and ",e.jsx(s,{math:"k - 1 < n - 1"}),", we have"," ",e.jsx(s,{math:"|S| + |T| \\geq n - 1 > k - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["By pigeonhole, some ",e.jsx(s,{math:"i \\in S \\cap T"}),". This creates a cycle covering"," ",e.jsx(s,{math:"P"}),". Since ",e.jsx(s,{math:"k < n"}),", some vertex outside"," ",e.jsx(s,{math:"P"})," is adjacent to this cycle, giving a longer path—contradiction."]})]}),children:e.jsxs("p",{children:["If ",e.jsx(s,{math:"G"})," has ",e.jsx(s,{math:"n \\geq 2"})," vertices and"," ",e.jsx(s,{math:"\\delta(G) \\geq (n-1)/2"}),", then ",e.jsx(s,{math:"G"})," has a Hamiltonian path."]})}),e.jsx(t,{title:"Theorem 7.2.10 (Hamiltonian Path Between Vertices)",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Form a new graph ",e.jsx(s,{math:"G'"})," by adding a new vertex"," ",e.jsx(s,{math:"z"})," adjacent to all vertices of ",e.jsx(s,{math:"G"}),"."]}),e.jsxs("p",{className:"mt-2",children:["In ",e.jsx(s,{math:"G'"}),", for any non-adjacent pair"," ",e.jsx(s,{math:"u, v \\in V(G)"}),":"]}),e.jsx(i,{math:"d_{G'}(u) + d_{G'}(v) = (d_G(u) + 1) + (d_G(v) + 1) = d_G(u) + d_G(v) + 2 \\geq n + 1 = |V(G')|"}),e.jsxs("p",{className:"mt-2",children:["By Ore's theorem, ",e.jsx(s,{math:"G'"})," is Hamiltonian. Let"," ",e.jsx(s,{math:"C"})," be a Hamiltonian cycle in ",e.jsx(s,{math:"G'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Remove ",e.jsx(s,{math:"z"})," from ",e.jsx(s,{math:"C"}),": the remaining path visits all vertices of ",e.jsx(s,{math:"G"})," exactly once."]}),e.jsxs("p",{className:"mt-2",children:["This path is a Hamiltonian path in ",e.jsx(s,{math:"G"}),"."]})]}),children:e.jsxs("p",{children:["If ",e.jsx(s,{math:"G"})," is simple with ",e.jsx(s,{math:"n \\geq 3"})," ","vertices, and for non-adjacent ",e.jsx(s,{math:"u, v"}),":"," ",e.jsx(s,{math:"d(u) + d(v) \\geq n - 1"}),", then there is a Hamiltonian path."]})}),e.jsx("h2",{children:"Special Graph Classes"}),e.jsx(t,{title:"Complete Bipartite Graphs",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇒) Necessity:"})," If ",e.jsx(s,{math:"K_{'{'}m,n{'}'}"})," is Hamiltonian, then ",e.jsx(s,{math:"m = n"})," by the bipartite necessary condition."]}),e.jsxs("p",{className:"mt-2",children:["Also ",e.jsx(s,{math:"m, n \\geq 2"})," since a Hamiltonian cycle needs at least 3 vertices and the cycle must alternate between parts."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐) Sufficiency:"})," Let the parts be"," ",e.jsx(s,{math:"X = \\{'{'}x_1, \\ldots, x_n{'}'}"})," and"," ",e.jsx(s,{math:"Y = \\{'{'}y_1, \\ldots, y_n{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(s,{math:"K_{'{'}n,n{'}'}"})," has every vertex in one part adjacent to every vertex in the other, the cycle:"]}),e.jsx(i,{math:"x_1 - y_1 - x_2 - y_2 - \\cdots - x_n - y_n - x_1"}),e.jsxs("p",{className:"mt-2",children:["visits all ",e.jsx(s,{math:"2n"})," vertices exactly once and returns to the start. This is a Hamiltonian cycle."]})]}),children:e.jsxs("p",{children:[e.jsx(s,{math:"K_{m,n}"})," is Hamiltonian if and only if"," ",e.jsx(s,{math:"m = n \\geq 2"}),"."]})}),e.jsxs(t,{title:"Hypercube is Hamiltonian",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We prove by induction on ",e.jsx(s,{math:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsxs("strong",{children:["Base case (",e.jsx(s,{math:"n = 2"}),"):"]})," ",e.jsx(s,{math:"Q_2 = C_4"}),", which is a Hamiltonian cycle itself."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Inductive step:"})," Assume ",e.jsx(s,{math:"Q_{'{'}n-1{'}'}"})," is Hamiltonian. ",e.jsx(s,{math:"Q_n"})," consists of two copies of"," ",e.jsx(s,{math:"Q_{'{'}n-1{'}'}"})," (one with first bit 0, one with first bit 1), connected by edges between corresponding vertices."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"H_0"})," and ",e.jsx(s,{math:"H_1"})," be Hamiltonian cycles in the two copies. Each vertex ",e.jsx(s,{math:"v"})," in ",e.jsx(s,{math:"H_0"}),' is connected to its "twin" in ',e.jsx(s,{math:"H_1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Remove one edge ",e.jsx(s,{math:"uv"})," from ",e.jsx(s,{math:"H_0"})," and the corresponding edge ",e.jsx(s,{math:"u'v'"})," from ",e.jsx(s,{math:"H_1"}),". Connect"," ",e.jsx(s,{math:"u"})," to ",e.jsx(s,{math:"u'"})," and ",e.jsx(s,{math:"v"})," to"," ",e.jsx(s,{math:"v'"})," using the hypercube edges."]}),e.jsxs("p",{className:"mt-2",children:["The result is a Hamiltonian cycle in ",e.jsx(s,{math:"Q_n"}),"."]})]}),children:[e.jsxs("p",{children:["The ",e.jsx(s,{math:"n"}),"-dimensional hypercube"," ",e.jsx(s,{math:"Q_n"})," is Hamiltonian for ",e.jsx(s,{math:"n \\geq 2"}),"."]}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["In fact, ",e.jsx(s,{math:"Q_n"})," is Hamiltonian laceable: there's a Hamiltonian path between any two vertices of different parities."]})]}),e.jsx("h2",{children:"Complexity"}),e.jsxs(t,{title:"NP-Completeness (Karp, 1972)",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"In NP:"})," A Hamiltonian cycle can be verified in polynomial time by checking that it visits each vertex exactly once and all edges are present."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"NP-hardness:"})," We reduce from 3-SAT."]}),e.jsxs("p",{className:"mt-2",children:["Given a 3-SAT formula with variables ",e.jsx(s,{math:"x_1, \\ldots, x_n"})," and clauses ",e.jsx(s,{math:"C_1, \\ldots, C_m"}),", construct a graph where:"]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Each variable ",e.jsx(s,{math:"x_i"}),' corresponds to a "variable gadget"—a path that can be traversed in two directions (representing true/false)']}),e.jsxs("li",{children:["Each clause ",e.jsx(s,{math:"C_j"}),' corresponds to a "clause gadget" that can only be traversed if at least one of its literals is true']}),e.jsx("li",{children:"The gadgets are connected so that a Hamiltonian cycle exists iff the formula is satisfiable"})]}),e.jsx("p",{className:"mt-2",children:"The construction ensures that the direction of traversal through variable gadgets encodes a truth assignment, and clause gadgets force at least one true literal per clause."})]}),children:[e.jsx("p",{children:"Determining whether a graph has a Hamiltonian cycle is NP-complete."}),e.jsx("p",{className:"mt-2",children:"It remains NP-complete even for:"}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsx("li",{children:"Planar 3-connected cubic graphs"}),e.jsx("li",{children:"Bipartite graphs"}),e.jsx("li",{children:"Grid graphs"})]})]}),e.jsx("p",{children:"This contrasts sharply with Eulerian circuits, which can be found in linear time."}),e.jsx("h2",{children:"Traveling Salesman Problem"}),e.jsxs(a,{title:"TSP",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"Traveling Salesman Problem"})," (TSP) asks: given a weighted complete graph, find a Hamiltonian cycle of minimum total weight."]}),e.jsx("p",{className:"mt-2",children:"The unweighted version (does a Hamiltonian cycle exist?) is a special case."})]}),e.jsxs(t,{title:"TSP Complexity",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"NP-hardness:"}),' TSP decision problem ("is there a tour of cost ≤ k?") is NP-hard by reduction from Hamiltonian Cycle.']}),e.jsxs("p",{className:"mt-2",children:["Given graph ",e.jsx(s,{math:"G"}),", create a complete weighted graph: weight 1 for edges in ",e.jsx(s,{math:"G"}),", weight 2 for non-edges. ",e.jsx(s,{math:"G"})," has a Hamiltonian cycle iff there's a TSP tour of cost ",e.jsx(s,{math:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Inapproximability:"})," For general TSP, suppose there's a polynomial",e.jsx(s,{math:"c"}),"-approximation. Given Hamiltonian Cycle instance"," ",e.jsx(s,{math:"G"}),", set non-edge weights to ",e.jsx(s,{math:"cn + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"G"})," is Hamiltonian, OPT = ",e.jsx(s,{math:"n"}),", and approximation returns ≤ ",e.jsx(s,{math:"cn"}),". If not Hamiltonian, OPT ≥"," ",e.jsx(s,{math:"n - 1 + cn + 1 > cn"}),". This distinguishes the cases, solving NP-complete Hamiltonian Cycle."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Metric TSP:"})," When triangle inequality holds, non-edge weight tricks fail. Christofides: find MST, add minimum matching on odd-degree vertices, find Eulerian tour, shortcut. This gives ",e.jsx(s,{math:"3/2"}),"-approximation."]})]}),children:[e.jsx("p",{children:"TSP is NP-hard. The optimization version has no polynomial-time approximation scheme unless P=NP (in the general case)."}),e.jsx("p",{className:"mt-2",children:"For metric TSP (triangle inequality holds), the Christofides algorithm gives a 3/2-approximation."})]}),e.jsx("h2",{children:"Pancyclic Graphs"}),e.jsx(a,{title:"Pancyclic",children:e.jsxs("p",{children:["A graph ",e.jsx(s,{math:"G"})," is ",e.jsx("strong",{children:"pancyclic"})," if it contains cycles of every length from 3 to ",e.jsx(s,{math:"n"}),"."]})}),e.jsxs(t,{title:"Bondy's Meta-Conjecture",children:[e.jsx("p",{children:'"Almost any non-trivial condition implying that a graph is Hamiltonian also implies that it is pancyclic."'}),e.jsxs("p",{className:"mt-2 text-dark-300",children:["For instance, if ",e.jsx(s,{math:"\\delta \\geq n/2"})," and"," ",e.jsx(s,{math:"G"})," is not bipartite, then ",e.jsx(s,{math:"G"})," is pancyclic or ",e.jsx(s,{math:"G = K_{n/2, n/2}"}),"."]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Hamiltonian:"})," Cycle visiting every vertex exactly once. Much harder than Eulerian."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Necessary:"})," Removing ",e.jsx(s,{math:"k"})," vertices leaves at most ",e.jsx(s,{math:"k"})," components."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Dirac:"})," ",e.jsx(s,{math:"\\delta \\geq n/2"})," implies Hamiltonian."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Ore:"})," ",e.jsx(s,{math:"d(u) + d(v) \\geq n"})," for all non-adjacent ",e.jsx(s,{math:"u, v"})," implies Hamiltonian."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Closure:"})," ",e.jsx(s,{math:"G"})," Hamiltonian iff"," ",e.jsx(s,{math:"cl(G)"})," Hamiltonian."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"NP-Complete:"})," No efficient algorithm known; contrasts with linear-time Eulerian."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"TSP:"})," Weighted version of Hamiltonian cycle; fundamental optimization problem."]})]})]})}export{g as default};
