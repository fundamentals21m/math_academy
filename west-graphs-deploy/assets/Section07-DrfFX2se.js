var me=Object.defineProperty;var xe=(f,o,a)=>o in f?me(f,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):f[o]=a;var _=(f,o,a)=>xe(f,typeof o!="symbol"?o+"":o,a);import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as ge,D as u,E as I,T as L}from"./ContentBlocks-BAFtEaU8.js";import{I as t}from"./MathBlock-_bBfq7Jh.js";import{r as l}from"./vendor-react-Drj8qL0h.js";import{c as je,d as pe,a as ue,C as T,b as fe,f as X,h as Y,j as ve,i as we,m as be,s as ye}from"./HamiltonianFinder-Baj_YtFX.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";class ke{constructor(o){_(this,"parent");_(this,"rank");this.parent=new Map,this.rank=new Map;for(const a of o)this.parent.set(a,a),this.rank.set(a,0)}find(o){return this.parent.get(o)!==o&&this.parent.set(o,this.find(this.parent.get(o))),this.parent.get(o)}union(o,a){const j=this.find(o),x=this.find(a);if(j===x)return!1;const b=this.rank.get(j),g=this.rank.get(x);return b<g?this.parent.set(j,x):b>g?this.parent.set(x,j):(this.parent.set(x,j),this.rank.set(j,b+1)),!0}}function Se(){return{nodes:[{id:"A",x:150,y:100,label:"A"},{id:"B",x:300,y:80,label:"B"},{id:"C",x:450,y:120,label:"C"},{id:"D",x:100,y:250,label:"D"},{id:"E",x:250,y:220,label:"E"},{id:"F",x:400,y:260,label:"F"},{id:"G",x:500,y:320,label:"G"},{id:"H",x:200,y:350,label:"H"}],edges:[{source:"A",target:"B",weight:4},{source:"A",target:"D",weight:2},{source:"A",target:"E",weight:3},{source:"B",target:"C",weight:5},{source:"B",target:"E",weight:1},{source:"C",target:"F",weight:6},{source:"C",target:"G",weight:4},{source:"D",target:"E",weight:3},{source:"D",target:"H",weight:5},{source:"E",target:"F",weight:2},{source:"E",target:"H",weight:4},{source:"F",target:"G",weight:3},{source:"G",target:"H",weight:6}]}}function Ne({className:f=""}){const o=l.useRef(null),[a,j]=l.useState(Se()),[x,b]=l.useState("kruskal"),[g,P]=l.useState([]),[c,N]=l.useState(-1),[y,A]=l.useState(!1),[M,J]=l.useState("medium"),[W,C]=l.useState(new Set),[k,E]=l.useState(null),[F,D]=l.useState(null),[S,O]=l.useState(null),[p,Q]=l.useState("view"),[v,q]=l.useState(null),[G,Z]=l.useState(1),[H,U]=l.useState(null),R=600,B=400,ee={slow:1500,medium:800,fast:300},te=i=>{const s=[],n=[...i.edges].sort((d,z)=>(d.weight??0)-(z.weight??0)),r=new ke(i.nodes.map(d=>d.id));let h=0;for(const d of n)s.push({edge:d,action:"consider",totalWeight:h}),r.union(d.source,d.target)?(h+=d.weight??0,s.push({edge:d,action:"add",totalWeight:h,reason:"Connects new component"})):s.push({edge:d,action:"reject",totalWeight:h,reason:"Would create cycle"});return s},se=(i,s)=>{const n=[],r=new Set([s]);let h=0;for(;r.size<i.nodes.length;){let d=null,z=1/0;for(const w of i.edges){const le=r.has(w.source),ce=r.has(w.target);if(le!==ce){const V=w.weight??0;n.push({edge:w,action:"consider",totalWeight:h}),V<z&&(z=V,d=w)}}if(d){h+=d.weight??0;const w=r.has(d.source)?d.target:d.source;r.add(w),n.push({edge:d,action:"add",totalWeight:h,reason:`Adds vertex ${w}`})}else break}return n};l.useEffect(()=>{if(!y||c>=g.length-1){c>=g.length-1&&A(!1);return}const i=setTimeout(()=>{N(s=>s+1)},ee[M]);return()=>clearTimeout(i)},[y,c,g.length,M]),l.useEffect(()=>{if(c<0){C(new Set),E(null);return}const i=new Set;for(let n=0;n<=c;n++){const r=g[n];r.action==="add"&&(i.add(`${r.edge.source}-${r.edge.target}`),i.add(`${r.edge.target}-${r.edge.source}`)),r.action==="consider"&&(lastConsideredEdge=r.edge)}C(i);const s=g[c];(s==null?void 0:s.action)==="consider"?E(s.edge):E(null)},[c,g]),l.useEffect(()=>{const i=o.current;if(!i)return;const s=i.getContext("2d");if(s){je(s,R,B),pe(s,R,B);for(const n of a.edges){const r=`${n.source}-${n.target}`,h=W.has(r),d=k&&(n.source===k.source&&n.target===k.target||n.source===k.target&&n.target===k.source);ue(s,n,a.nodes,{highlighted:h,color:h?T.path:d?T.nodeSelected:T.edge,width:h?4:d?3:2,showWeight:!0})}if(p==="addEdge"&&v&&S&&S!==v){const n=a.nodes.find(h=>h.id===v),r=a.nodes.find(h=>h.id===S);n&&r&&(s.strokeStyle=T.nodeSelected,s.lineWidth=2,s.setLineDash([6,4]),s.beginPath(),s.moveTo(n.x,n.y),s.lineTo(r.x,r.y),s.stroke(),s.setLineDash([]))}for(const n of a.nodes){const r=x==="prim"&&n.id===H;fe(s,n,{selected:r,highlighted:n.id===S||n.id===v,fillColor:r?T.path:void 0})}}},[a,W,k,S,v,p,x,H]);const ie=l.useCallback(i=>{const s=o.current;if(!s)return;const{x:n,y:r}=X(i,s),h=Y(n,r,a.nodes);if(p==="addNode"&&!h){const d=String.fromCharCode(65+a.nodes.length);j(ve(a,n,r,d));return}if(p==="addEdge"&&h){v?h.id!==v&&(j(we(a,v,h.id,G)),q(null)):q(h.id);return}h&&(i.shiftKey&&x==="prim"?U(h.id):D(h.id))},[a,p,v,G,x]),ne=l.useCallback(i=>{var h;const s=o.current;if(!s)return;const{x:n,y:r}=X(i,s);O(((h=Y(n,r,a.nodes))==null?void 0:h.id)??null),F&&p==="view"&&j(be(a,F,n,r))},[a,F,p]),ae=l.useCallback(()=>{D(null)},[]),re=()=>{var i;if(x==="kruskal")P(te(a));else{const s=H??((i=a.nodes[0])==null?void 0:i.id);s&&(U(s),P(se(a,s)))}N(-1),C(new Set),A(!0)},$=()=>{P([]),N(-1),C(new Set),E(null),A(!1)},he=()=>{c<g.length-1&&N(i=>i+1)},oe=()=>{c>0&&N(i=>i-1)},m=c>=0?g[c]:null,de=(m==null?void 0:m.totalWeight)??0,K=ye(a);return e.jsxs("div",{className:`p-6 rounded-2xl bg-dark-800/50 border border-dark-700/50 ${f}`,children:[e.jsx("h3",{className:"text-xl font-bold text-dark-100 mb-2",children:"Minimum Spanning Tree"}),e.jsx("p",{className:"text-dark-300 mb-6",children:"Watch Kruskal's or Prim's algorithm find the minimum spanning tree step by step."}),e.jsxs("div",{className:"flex flex-col xl:flex-row gap-6",children:[e.jsxs("div",{className:"flex-shrink-0",children:[e.jsx("canvas",{ref:o,width:R,height:B,className:"rounded-xl border border-dark-600",style:{cursor:p==="addNode"?"crosshair":S?"pointer":"default"},onMouseDown:ie,onMouseMove:ne,onMouseUp:ae,onMouseLeave:()=>{D(null),O(null)}}),e.jsxs("div",{className:"mt-4 flex flex-wrap gap-2",children:[[{mode:"view",label:"View"},{mode:"addNode",label:"+ Vertex"},{mode:"addEdge",label:"+ Edge"}].map(({mode:i,label:s})=>e.jsx("button",{onClick:()=>{Q(i),q(null)},className:`px-3 py-2 rounded-lg text-sm font-medium ${p===i?"bg-blue-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600"}`,children:s},i)),p==="addEdge"&&e.jsx("input",{type:"number",min:"1",max:"99",value:G,onChange:i=>Z(parseInt(i.target.value)||1),className:"w-16 px-2 py-2 bg-dark-700 text-dark-100 rounded-lg text-sm",placeholder:"Weight"})]})]}),e.jsxs("div",{className:"flex-1 space-y-4 min-w-0",children:[e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-dark-200 mb-2",children:"Algorithm"}),e.jsxs("div",{className:"flex gap-2",children:[e.jsx("button",{onClick:()=>{b("kruskal"),$()},className:`px-4 py-2 rounded-lg text-sm font-medium ${x==="kruskal"?"bg-green-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600"}`,children:"Kruskal's"}),e.jsx("button",{onClick:()=>{b("prim"),$()},className:`px-4 py-2 rounded-lg text-sm font-medium ${x==="prim"?"bg-green-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600"}`,children:"Prim's"})]})]}),e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-dark-200 mb-2",children:"Speed"}),e.jsx("div",{className:"flex gap-2",children:["slow","medium","fast"].map(i=>e.jsx("button",{onClick:()=>J(i),className:`px-3 py-1.5 rounded-lg text-sm capitalize ${M===i?"bg-blue-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600"}`,children:i},i))})]}),e.jsxs("div",{className:"flex gap-2",children:[!y&&c<0&&e.jsx("button",{onClick:re,disabled:!K,className:`px-4 py-2 rounded-lg text-sm font-medium ${K?"bg-green-600 text-white hover:bg-green-700":"bg-dark-600 text-dark-400 cursor-not-allowed"}`,children:"Start Algorithm"}),(y||c>=0)&&e.jsxs(e.Fragment,{children:[e.jsx("button",{onClick:()=>A(!y),className:"px-4 py-2 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700",children:y?"Pause":"Play"}),e.jsx("button",{onClick:oe,disabled:c<=0,className:"px-3 py-2 bg-dark-700 text-dark-200 rounded-lg text-sm hover:bg-dark-600 disabled:opacity-50",children:"◀ Step"}),e.jsx("button",{onClick:he,disabled:c>=g.length-1,className:"px-3 py-2 bg-dark-700 text-dark-200 rounded-lg text-sm hover:bg-dark-600 disabled:opacity-50",children:"Step ▶"}),e.jsx("button",{onClick:$,className:"px-4 py-2 bg-red-600/20 text-red-400 rounded-lg text-sm hover:bg-red-600/30",children:"Reset"})]})]}),m&&e.jsxs("div",{className:`p-4 rounded-lg ${m.action==="add"?"bg-green-900/30":m.action==="reject"?"bg-red-900/30":"bg-yellow-900/30"}`,children:[e.jsxs("div",{className:"flex justify-between items-center mb-2",children:[e.jsxs("span",{className:"font-medium text-dark-100",children:["Step ",c+1,"/",g.length]}),e.jsx("span",{className:`text-sm ${m.action==="add"?"text-green-400":m.action==="reject"?"text-red-400":"text-yellow-400"}`,children:m.action==="add"?"Added":m.action==="reject"?"Rejected":"Considering"})]}),e.jsxs("div",{className:"text-sm text-dark-300",children:["Edge: ",m.edge.source," — ",m.edge.target,"(weight: ",m.edge.weight,")"]}),m.reason&&e.jsx("div",{className:"text-sm text-dark-400 mt-1",children:m.reason})]}),e.jsxs("div",{className:"p-4 bg-dark-700/50 rounded-lg",children:[e.jsxs("div",{className:"flex justify-between",children:[e.jsx("span",{className:"text-dark-300",children:"Total MST Weight:"}),e.jsx("span",{className:"text-xl font-bold text-green-400",children:de})]}),e.jsxs("div",{className:"flex justify-between mt-2",children:[e.jsx("span",{className:"text-dark-300",children:"Edges in MST:"}),e.jsxs("span",{className:"text-dark-100",children:[W.size/2,"/",a.nodes.length-1]})]})]}),!K&&e.jsx("div",{className:"p-3 bg-red-900/30 rounded-lg text-red-400 text-sm",children:"Graph is not connected. MST algorithms require a connected graph."}),e.jsx("div",{className:"text-sm text-dark-400 space-y-1",children:x==="kruskal"?e.jsxs(e.Fragment,{children:[e.jsx("p",{children:e.jsx("strong",{children:"Kruskal's Algorithm:"})}),e.jsx("p",{children:"1. Sort edges by weight"}),e.jsx("p",{children:"2. Add edges if they don't create a cycle"}),e.jsx("p",{children:"3. Stop when n-1 edges are added"})]}):e.jsxs(e.Fragment,{children:[e.jsx("p",{children:e.jsx("strong",{children:"Prim's Algorithm:"})}),e.jsx("p",{children:"1. Start from a vertex (Shift-click to set)"}),e.jsx("p",{children:"2. Add minimum weight edge to a new vertex"}),e.jsx("p",{children:"3. Repeat until all vertices are included"})]})})]})]})]})}function Fe(){return e.jsxs(ge,{sectionId:7,children:[e.jsxs("p",{children:['"The best spanning tree" may have various meanings. A ',e.jsx("strong",{children:"weighted graph"})," ","is a graph with numerical labels on the edges. When building links to connect locations, the costs of potential links yield a weighted graph. The minimum cost of connecting the system is the minimum total weight of its spanning trees."]}),e.jsxs("p",{children:["Alternatively, the weights may represent distances. In these cases we define the length of a path to be the sum of its edge weights. We may seek a spanning tree with small distances. When discussing weighted graphs,"," ",e.jsx("strong",{children:"we consider only nonnegative edge weights"}),"."]}),e.jsx("h2",{children:"Interactive MST Algorithm"}),e.jsx("p",{children:"Watch Kruskal's or Prim's algorithm find the minimum spanning tree step by step. See how each algorithm greedily selects edges to build the optimal solution."}),e.jsx(Ne,{className:"my-8"}),e.jsx("h2",{children:"Minimum Spanning Trees"}),e.jsxs("p",{children:["In a connected weighted graph of possible communication links, all spanning trees have ",e.jsx(t,{math:"n - 1"})," edges; we seek one that minimizes or maximizes the sum of the edge weights. For these problems, the most naive heuristic quickly produces an optimal solution."]}),e.jsxs(u,{title:"Kruskal's Algorithm (Algorithm 2.3.1)",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," A weighted connected graph."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Idea:"})," Maintain an acyclic spanning subgraph"," ",e.jsx(t,{math:"H"}),", enlarging it by edges with low weight to form a spanning tree. Consider edges in nondecreasing order of weight."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Initialization:"})," Set ",e.jsx(t,{math:"E(H) = \\emptyset"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Iteration:"})," If the next cheapest edge joins two components of"," ",e.jsx(t,{math:"H"}),", include it; otherwise, discard it. Terminate when"," ",e.jsx(t,{math:"H"})," is connected."]})]}),e.jsxs("p",{children:["Unsophisticated locally optimal heuristics are called"," ",e.jsx("strong",{children:"greedy algorithms"}),". They usually don't guarantee optimal solutions, but this one does!"]}),e.jsxs(I,{title:"Running Kruskal's Algorithm",children:[e.jsx("p",{children:"Choices in Kruskal's Algorithm depend only on the order of the weights, not on their values. Consider a graph where we've labeled edges with positive integers to emphasize the order of examination."}),e.jsx("p",{children:"The four cheapest edges might be selected, but then edges that complete cycles with the selected edges must be skipped. Edges of equal weight may be examined in any order; the resulting trees have the same cost."}),e.jsx("p",{children:"Each selected edge combines two components of the growing forest until we have a single spanning tree."})]}),e.jsxs(L,{title:"Theorem 2.3.3 (Kruskal [1956])",children:[e.jsxs("p",{children:["In a connected weighted graph ",e.jsx(t,{math:"G"}),", Kruskal's Algorithm constructs a minimum-weight spanning tree."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"The algorithm produces a tree:"})," It never chooses an edge that completes a cycle. If the final graph has more than one component, then we considered no edge joining two of them, but such an edge would be accepted. Since ",e.jsx(t,{math:"G"})," is connected, some such edge exists. Thus the final graph is connected and acyclic."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"The tree is optimal:"})," Let ",e.jsx(t,{math:"T"})," be the resulting tree, and let ",e.jsx(t,{math:"T^*"})," be a minimum-weight spanning tree. If ",e.jsx(t,{math:"T \\neq T^*"}),", let"," ",e.jsx(t,{math:"e"})," be the first edge chosen for ",e.jsx(t,{math:"T"})," ","that is not in ",e.jsx(t,{math:"T^*"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Adding ",e.jsx(t,{math:"e"})," to ",e.jsx(t,{math:"T^*"})," creates one cycle ",e.jsx(t,{math:"C"}),". Since ",e.jsx(t,{math:"T"})," has no cycle,"," ",e.jsx(t,{math:"C"})," has an edge"," ",e.jsx(t,{math:"e' \\notin E(T)"}),". Consider"," ",e.jsx(t,{math:"T^* + e - e'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(t,{math:"T^*"})," contains ",e.jsx(t,{math:"e'"})," and all edges of ",e.jsx(t,{math:"T"})," chosen before ",e.jsx(t,{math:"e"}),", both ",e.jsx(t,{math:"e'"})," and ",e.jsx(t,{math:"e"})," are available when the algorithm chooses ",e.jsx(t,{math:"e"}),", so"," ",e.jsx(t,{math:"w(e) \\leq w(e')"}),". Thus"," ",e.jsx(t,{math:"T^* + e - e'"})," is a spanning tree with weight at most"," ",e.jsx(t,{math:"T^*"})," that agrees with ",e.jsx(t,{math:"T"})," longer."]}),e.jsxs("p",{className:"mt-2",children:["Repeating this argument eventually yields a minimum-weight spanning tree that agrees completely with ",e.jsx(t,{math:"T"}),"."]})]})]})]}),e.jsxs(u,{title:"Prim's Algorithm",children:[e.jsx("p",{children:"An alternative approach: grow a spanning tree from a single vertex by iteratively adding the cheapest edge that incorporates a new vertex."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Initialization:"})," Start with any vertex ",e.jsx(t,{math:"v"}),". Set ",e.jsx(t,{math:"S = \\{v\\}"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Iteration:"})," Add the cheapest edge from a vertex in"," ",e.jsx(t,{math:"S"})," to a vertex outside ",e.jsx(t,{math:"S"}),". Add the new vertex to ",e.jsx(t,{math:"S"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Termination:"})," When ",e.jsx(t,{math:"S = V(G)"}),"."]})]}),e.jsx("h2",{children:"Shortest Paths"}),e.jsx("p",{children:"How can we find the shortest route from one location to another? How can we find the shortest routes from our home to every place in town? This requires finding shortest paths from one vertex to all other vertices in a weighted graph. Together, these paths form a spanning tree."}),e.jsx(u,{title:"Distance in Weighted Graphs",children:e.jsxs("p",{children:["The ",e.jsx("strong",{children:"distance"})," ",e.jsx(t,{math:"d(u, z)"})," in a weighted graph is the minimum sum of the weights on the edges in a"," ",e.jsx(t,{math:"u, z"}),"-path. We consider only nonnegative weights."]})}),e.jsxs("p",{children:[e.jsx("strong",{children:"Dijkstra's Algorithm"})," solves this problem quickly, using the observation that the ",e.jsx(t,{math:"u, v"}),"-portion of a shortest"," ",e.jsx(t,{math:"u, z"}),"-path must be a shortest"," ",e.jsx(t,{math:"u, v"}),"-path. It finds optimal routes from"," ",e.jsx(t,{math:"u"})," to other vertices ",e.jsx(t,{math:"z"})," in increasing order of ",e.jsx(t,{math:"d(u, z)"}),"."]}),e.jsxs(u,{title:"Dijkstra's Algorithm (Algorithm 2.3.5)",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," A graph (or digraph) with nonnegative edge weights and a starting vertex ",e.jsx(t,{math:"u"}),". Let ",e.jsx(t,{math:"w(xy)"})," be the weight of edge ",e.jsx(t,{math:"xy"})," (or"," ",e.jsx(t,{math:"\\infty"})," if no edge)."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Idea:"})," Maintain the set ",e.jsx(t,{math:"S"})," of vertices to which a shortest path from ",e.jsx(t,{math:"u"})," is known. Also maintain a tentative distance ",e.jsx(t,{math:"t(z)"})," from ",e.jsx(t,{math:"u"})," to each ",e.jsx(t,{math:"z \\notin S"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Initialization:"})," Set ",e.jsx(t,{math:"S = \\{u\\}"}),";"," ",e.jsx(t,{math:"t(u) = 0"}),"; ",e.jsx(t,{math:"t(z) = w(uz)"})," for"," ",e.jsx(t,{math:"z \\neq u"}),"."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Iteration:"})}),e.jsxs("ol",{className:"list-decimal list-inside ml-4 space-y-1",children:[e.jsxs("li",{children:["Select a vertex ",e.jsx(t,{math:"v"})," outside ",e.jsx(t,{math:"S"})," such that ",e.jsx(t,{math:"t(v) = \\min_{z \\notin S} t(z)"}),"."]}),e.jsxs("li",{children:["Add ",e.jsx(t,{math:"v"})," to ",e.jsx(t,{math:"S"}),"."]}),e.jsxs("li",{children:["For each edge ",e.jsx(t,{math:"vz"})," with"," ",e.jsx(t,{math:"z \\notin S"}),", update"," ",e.jsx(t,{math:"t(z) \\leftarrow \\min\\{t(z), t(v) + w(vz)\\}"}),"."]})]}),e.jsxs("p",{className:"mt-2",children:["Continue until ",e.jsx(t,{math:"S = V(G)"})," or"," ",e.jsx(t,{math:"t(z) = \\infty"})," for all"," ",e.jsx(t,{math:"z \\notin S"}),"."]})]}),e.jsxs(I,{title:"Dijkstra's Algorithm",children:[e.jsxs("p",{children:["In a weighted graph, suppose we find shortest paths from vertex"," ",e.jsx(t,{math:"u"})," to vertices ",e.jsx(t,{math:"a, b, c, d, e"})," with distances ",e.jsx(t,{math:"1, 3, 5, 6, 8"}),", respectively."]}),e.jsxs("p",{className:"mt-2",children:["To reconstruct the paths, we only need the edge on which each shortest path arrives at its destination. The earlier portion of a shortest"," ",e.jsx(t,{math:"u, z"}),"-path that reaches ",e.jsx(t,{math:"z"})," on the edge ",e.jsx(t,{math:"vz"})," is a shortest ",e.jsx(t,{math:"u, v"}),"-path."]}),e.jsxs("p",{className:"mt-2",children:['The algorithm can maintain this by recording the "predecessor" vertex whenever the tentative distance is updated. The predecessors form the edges of a spanning tree rooted at ',e.jsx(t,{math:"u"}),"."]})]}),e.jsxs(L,{title:"Theorem 2.3.7 (Correctness of Dijkstra's Algorithm)",children:[e.jsxs("p",{children:["Given a (di)graph ",e.jsx(t,{math:"G"})," and a vertex"," ",e.jsx(t,{math:"u \\in V(G)"}),", Dijkstra's Algorithm computes"," ",e.jsx(t,{math:"d(u, z)"})," for every ",e.jsx(t,{math:"z \\in V(G)"}),"."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["We prove by induction on ",e.jsx(t,{math:"|S|"})," that at each iteration:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["For ",e.jsx(t,{math:"z \\in S"}),","," ",e.jsx(t,{math:"t(z) = d(u, z)"}),"."]}),e.jsxs("li",{children:["For ",e.jsx(t,{math:"z \\notin S"}),", ",e.jsx(t,{math:"t(z)"})," is the least length of a ",e.jsx(t,{math:"u, z"}),"-path reaching"," ",e.jsx(t,{math:"z"})," directly from ",e.jsx(t,{math:"S"}),"."]})]}),e.jsxs("p",{className:"mt-2",children:["When we select ",e.jsx(t,{math:"v"})," (minimum"," ",e.jsx(t,{math:"t(v)"})," outside ",e.jsx(t,{math:"S"}),"), any path visiting vertices outside ",e.jsx(t,{math:"S"})," before reaching"," ",e.jsx(t,{math:"v"})," has length at least ",e.jsx(t,{math:"t(v)"}),". Hence ",e.jsx(t,{math:"d(u, v) = t(v)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Updating tentative distances when adding ",e.jsx(t,{math:"v"})," to"," ",e.jsx(t,{math:"S"})," correctly considers all paths reaching"," ",e.jsx(t,{math:"z"})," directly from the new ",e.jsx(t,{math:"S"}),"."]})]})]})]}),e.jsx("h2",{children:"Breadth-First Search"}),e.jsxs("p",{children:["The special case of Dijkstra's Algorithm for ",e.jsx("strong",{children:"unweighted graphs"})," ","(all edges have weight 1) is Breadth-First Search (BFS)."]}),e.jsxs(u,{title:"Breadth-First Search (Algorithm 2.3.8)",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," An unweighted graph (or digraph) and start vertex"," ",e.jsx(t,{math:"u"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Idea:"})," Maintain a set ",e.jsx(t,{math:"R"})," of vertices reached but not searched, and a set ",e.jsx(t,{math:"S"})," of vertices searched. Use ",e.jsx(t,{math:"R"})," as a ",e.jsx("strong",{children:"queue"})," (First-In First-Out), so the first vertices found are the first explored."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Initialization:"})," ",e.jsx(t,{math:"R = \\{u\\}"}),","," ",e.jsx(t,{math:"S = \\emptyset"}),", ",e.jsx(t,{math:"d(u, u) = 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Iteration:"})," While ",e.jsx(t,{math:"R \\neq \\emptyset"}),", search from the first vertex ",e.jsx(t,{math:"v"})," of"," ",e.jsx(t,{math:"R"}),". Add neighbors of ",e.jsx(t,{math:"v"})," not in"," ",e.jsx(t,{math:"S \\cup R"})," to the back of ",e.jsx(t,{math:"R"})," and assign distance ",e.jsx(t,{math:"d(u, v) + 1"}),". Move"," ",e.jsx(t,{math:"v"})," from ",e.jsx(t,{math:"R"})," to"," ",e.jsx(t,{math:"S"}),"."]})]}),e.jsxs("p",{children:["The largest distance from a vertex ",e.jsx(t,{math:"u"})," to another vertex is the eccentricity ",e.jsx(t,{math:"\\varepsilon(u)"}),". Hence we can compute the"," ",e.jsx("strong",{children:"diameter"})," of a graph by running Breadth-First Search from each vertex."]}),e.jsxs("p",{children:["Like Dijkstra's Algorithm, BFS from ",e.jsx(t,{math:"u"})," yields a tree"," ",e.jsx(t,{math:"T"})," in which for each vertex ",e.jsx(t,{math:"v"}),", the"," ",e.jsx(t,{math:"u, v"}),"-path is a shortest ",e.jsx(t,{math:"u, v"}),"-path."]}),e.jsx("h2",{children:"The Chinese Postman Problem"}),e.jsxs(u,{title:"Chinese Postman Problem",children:[e.jsxs("p",{children:["A mail carrier must traverse all edges in a road network, starting and ending at the Post Office. The edges have nonnegative weights representing distance or time. We seek a ",e.jsx("strong",{children:"closed walk"})," of minimum total length that uses all the edges."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"Named in honor of the Chinese mathematician Guan Meigu [1962], who proposed it."})]}),e.jsx("p",{children:"If every vertex has even degree, then the graph is Eulerian and the answer is the sum of the edge weights. Otherwise, we must repeat some edges."}),e.jsx("p",{children:"Every traversal is an Eulerian circuit of a graph obtained by duplicating edges. Finding the shortest traversal is equivalent to finding the minimum total weight of edges whose duplication will make all vertex degrees even."}),e.jsxs(I,{title:"Solving the Chinese Postman Problem",children:[e.jsx("p",{children:"Consider a graph with eight odd-degree vertices on its outer boundary. To make all degrees even, we must pair up the odd vertices with paths."}),e.jsx("p",{className:"mt-2",children:"If there are only two odd vertices, use Dijkstra's Algorithm to find the shortest path between them."}),e.jsxs("p",{className:"mt-2",children:["If there are ",e.jsx(t,{math:"2k"})," odd vertices, find shortest paths between all pairs using Dijkstra's Algorithm. Then find the minimum total weight of"," ",e.jsx(t,{math:"k"})," paths that pair up all odd vertices (a weighted matching problem)."]})]}),e.jsx("h2",{children:"Trees in Computer Science (Optional)"}),e.jsxs(u,{title:"Rooted Trees",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"rooted tree"})," is a tree with one vertex ",e.jsx(t,{math:"r"}),"chosen as ",e.jsx("strong",{children:"root"}),". For each vertex ",e.jsx(t,{math:"v"}),", let"," ",e.jsx(t,{math:"P(v)"})," be the unique ",e.jsx(t,{math:"v, r"}),"-path."]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["The ",e.jsx("strong",{children:"parent"})," of ",e.jsx(t,{math:"v"})," is its neighbor on"," ",e.jsx(t,{math:"P(v)"}),"."]}),e.jsxs("li",{children:["The ",e.jsx("strong",{children:"children"})," of ",e.jsx(t,{math:"v"})," are its other neighbors."]}),e.jsxs("li",{children:["The ",e.jsx("strong",{children:"ancestors"})," of ",e.jsx(t,{math:"v"})," are the vertices of"," ",e.jsx(t,{math:"P(v) - v"}),"."]}),e.jsxs("li",{children:["The ",e.jsx("strong",{children:"descendants"})," of ",e.jsx(t,{math:"v"})," are vertices"," ",e.jsx(t,{math:"u"})," such that ",e.jsx(t,{math:"P(u)"})," contains"," ",e.jsx(t,{math:"v"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Leaves"})," are vertices with no children."]})]})]}),e.jsxs(u,{title:"Binary Trees",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"binary tree"})," is a rooted plane tree where each vertex has at most two children, and each child is designated as ",e.jsx("strong",{children:"left"})," or"," ",e.jsx("strong",{children:"right"}),"."]}),e.jsx("p",{className:"mt-2",children:"Binary trees permit storage of data for quick access. We store each item at a leaf and access it by following the path from the root (0 for left, 1 for right). The search time is the length of this code word."})]}),e.jsx("h3",{children:"Huffman's Algorithm"}),e.jsxs("p",{children:["Given access probabilities among ",e.jsx(t,{math:"n"})," items, we want to place them at the leaves of a binary tree to minimize expected search time. This is equivalent to optimal prefix-free coding."]}),e.jsxs(u,{title:"Prefix-Free Code",children:[e.jsxs("p",{children:["A binary code is ",e.jsx("strong",{children:"prefix-free"})," if no code word is an initial portion of another. Then the current word ends as soon as the bits since the end of the previous word form a code word."]}),e.jsx("p",{className:"mt-2",children:"Prefix-free binary codes correspond to the leaves of a binary tree using left/right encoding (0 = left, 1 = right)."})]}),e.jsxs(u,{title:"Huffman's Algorithm (Algorithm 2.3.13)",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," Weights (frequencies or probabilities)"," ",e.jsx(t,{math:"p_1, \\ldots, p_n"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Output:"})," Prefix-free code (equivalently, a binary tree)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Idea:"})," Infrequent items should have longer codes; put infrequent items deeper by combining them into parent nodes."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Base case:"})," When ",e.jsx(t,{math:"n = 2"}),", the optimal length is 1, with 0 and 1 as the codes."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Recursion:"})," When ",e.jsx(t,{math:"n > 2"}),", replace the two least likely items ",e.jsx(t,{math:"p, p'"})," with a single item"," ",e.jsx(t,{math:"q = p + p'"}),". Solve for ",e.jsx(t,{math:"n - 1"})," items. Then give children with weights ",e.jsx(t,{math:"p, p'"})," to the leaf with weight ",e.jsx(t,{math:"q"}),"."]})]}),e.jsxs(I,{title:"Huffman Coding",children:[e.jsx("p",{children:"Consider eight items with frequencies 5, 1, 1, 7, 8, 2, 3, 6. Algorithm 2.3.13 combines items from the bottom up:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(t,{math:"1 + 1 = 2"})}),e.jsx("li",{children:e.jsx(t,{math:"2 + 2 = 4"})}),e.jsx("li",{children:e.jsx(t,{math:"3 + 4 = 7"})}),e.jsx("li",{children:e.jsx(t,{math:"5 + 6 = 11"})}),e.jsx("li",{children:e.jsx(t,{math:"7 + 7 = 14"})}),e.jsx("li",{children:e.jsx(t,{math:"8 + 11 = 19"})}),e.jsx("li",{children:e.jsx(t,{math:"14 + 19 = 33"})})]}),e.jsxs("p",{className:"mt-2",children:["The expected code length is ",e.jsx(t,{math:"\\sum p_i l_i = 90/33 < 3"}),", which is less than using fixed-length 3-bit codes for eight items."]})]}),e.jsxs(L,{title:"Theorem 2.3.15 (Optimality of Huffman Coding)",children:[e.jsxs("p",{children:["Given a probability distribution ",e.jsx(t,{math:"\\{p_i\\}"})," on"," ",e.jsx(t,{math:"n"})," items, Huffman's Algorithm produces the prefix-free code with minimum expected length."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Use induction on ",e.jsx(t,{math:"n"}),". Every optimal code has least likely messages at leaves of greatest depth. Since every leaf at maximum depth has a sibling, two least likely messages can be assumed to be siblings."]}),e.jsxs("p",{className:"mt-2",children:["Replacing these siblings with their parent (probability"," ",e.jsx(t,{math:"p_{n-1} + p_n"}),") reduces to an"," ",e.jsx(t,{math:"(n-1)"}),"-item problem. By the induction hypothesis, Huffman's Algorithm is optimal for this. Expanding back gives the optimal tree for ",e.jsx(t,{math:"n"})," items."]})]})]})]}),e.jsxs("p",{children:["Shannon [1948] proved that for every binary code, the expected length is at least the ",e.jsx("strong",{children:"entropy"})," of the distribution:"," ",e.jsx(t,{math:"-\\sum p_i \\log_2 p_i"}),". When each"," ",e.jsx(t,{math:"p_i"})," is a power of ",e.jsx(t,{math:"1/2"}),", the Huffman code achieves this bound exactly."]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Kruskal's Algorithm:"})," Build a minimum spanning tree by greedily adding cheapest edges that don't create cycles."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Prim's Algorithm:"})," Grow a minimum spanning tree from a single vertex by iteratively adding the cheapest edge to a new vertex."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Dijkstra's Algorithm:"})," Find shortest paths from a source vertex by iteratively selecting the vertex with smallest tentative distance and updating neighbors."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Breadth-First Search:"})," Special case of Dijkstra for unweighted graphs; explores vertices in order of distance from the source."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Chinese Postman Problem:"})," Find minimum-weight walk covering all edges; reduces to matching odd-degree vertices optimally."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Huffman's Algorithm:"})," Builds optimal prefix-free codes by recursively combining least frequent items."]})]})]})}export{Fe as default};
