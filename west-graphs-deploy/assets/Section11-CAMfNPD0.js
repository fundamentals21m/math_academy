import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as n,D as t,E as i,T as a}from"./ContentBlocks-BAFtEaU8.js";import{I as s,M as h}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function j(){return e.jsxs(n,{sectionId:11,children:[e.jsx("p",{children:'How resilient is a network to failures? If we remove vertices or edges, does the graph remain connected? The study of connectivity measures how "well-connected" a graph is and identifies its vulnerable points. These concepts are fundamental to network reliability and algorithm design.'}),e.jsx("h2",{children:"Separating Sets and Connectivity"}),e.jsxs(t,{title:"Separating Set and Cut",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"separating set"})," or ",e.jsx("strong",{children:"vertex cut"})," of a connected graph ",e.jsx(s,{math:"G"})," is a set ",e.jsx(s,{math:"S \\subseteq V(G)"})," ","such that ",e.jsx(s,{math:"G - S"})," has more than one component."]}),e.jsxs("p",{className:"mt-2",children:["A ",e.jsx("strong",{children:"disconnecting set"})," of edges is a set"," ",e.jsx(s,{math:"F \\subseteq E(G)"})," such that ",e.jsx(s,{math:"G - F"})," ","has more than one component. A disconnecting set is an"," ",e.jsx("strong",{children:"edge cut"})," if no proper subset is also disconnecting."]})]}),e.jsxs(t,{title:"Connectivity Numbers",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"connectivity"})," (or ",e.jsx("strong",{children:"vertex connectivity"}),")"," ",e.jsx(s,{math:"\\kappa(G)"})," is the minimum size of a vertex cut, or"," ",e.jsx(s,{math:"n - 1"})," if ",e.jsx(s,{math:"G = K_n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"edge-connectivity"})," ",e.jsx(s,{math:"\\kappa'(G)"})," is the minimum size of an edge cut (if ",e.jsx(s,{math:"G"})," is connected)."]}),e.jsxs("p",{className:"mt-2",children:["A graph is ",e.jsxs("strong",{children:[e.jsx(s,{math:"k"}),"-connected"]})," ","if ",e.jsx(s,{math:"\\kappa(G) \\geq k"}),", and"," ",e.jsxs("strong",{children:[e.jsx(s,{math:"k"}),"-edge-connected"]})," ","if ",e.jsx(s,{math:"\\kappa'(G) \\geq k"}),"."]})]}),e.jsx(i,{title:"Connectivity of Common Graphs",children:e.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[e.jsxs("li",{children:[e.jsx(s,{math:"K_n"}),": ",e.jsx(s,{math:"\\kappa = \\kappa' = n - 1"})]}),e.jsxs("li",{children:[e.jsx(s,{math:"K_{m,n}"})," (",e.jsx(s,{math:"m \\leq n"}),"):"," ",e.jsx(s,{math:"\\kappa = \\kappa' = m"})]}),e.jsxs("li",{children:[e.jsx(s,{math:"C_n"}),": ",e.jsx(s,{math:"\\kappa = \\kappa' = 2"})]}),e.jsxs("li",{children:[e.jsx(s,{math:"P_n"}),": ",e.jsx(s,{math:"\\kappa = \\kappa' = 1"})]}),e.jsxs("li",{children:["Petersen graph: ",e.jsx(s,{math:"\\kappa = \\kappa' = 3"})]})]})}),e.jsxs(a,{title:"Theorem 4.1.9 (Connectivity Bounds)",children:[e.jsxs("p",{children:["For any graph ",e.jsx(s,{math:"G"}),":"]}),e.jsx(h,{math:"\\kappa(G) \\leq \\kappa'(G) \\leq \\delta(G)"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{math:"\\delta(G)"})," is the minimum vertex degree."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsxs("strong",{children:[e.jsx(s,{math:"\\kappa'(G) \\leq \\delta(G)"}),":"]})," ","Deleting all edges at a vertex of minimum degree disconnects the graph (isolating that vertex)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsxs("strong",{children:[e.jsx(s,{math:"\\kappa(G) \\leq \\kappa'(G)"}),":"]})," ","Given a minimum edge cut ",e.jsx(s,{math:"[S, \\overline{S}]"}),", for each edge ",e.jsx(s,{math:"e"})," in the cut, include one endpoint in a vertex set ",e.jsx(s,{math:"T"}),". Then ",e.jsx(s,{math:"T"})," is a vertex cut with ",e.jsx(s,{math:"|T| \\leq \\kappa'(G)"}),"."]})]})]})]}),e.jsxs(i,{title:"Strict Inequalities",children:[e.jsxs("p",{children:['Consider a "bowtie" graph: two triangles sharing a vertex. We have'," ",e.jsx(s,{math:"\\delta = 2"}),", ",e.jsx(s,{math:"\\kappa' = 2"}),", but"," ",e.jsx(s,{math:"\\kappa = 1"})," (removing the shared vertex disconnects)."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{math:"K_{2,3}"}),": ",e.jsx(s,{math:"\\delta = 2"}),", but"," ",e.jsx(s,{math:"\\kappa = \\kappa' = 2"}),"."]})]}),e.jsx("h2",{children:"Cut-Vertices and Bridges"}),e.jsxs(t,{title:"Cut-Vertex and Cut-Edge",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"cut-vertex"})," (or ",e.jsx("strong",{children:"articulation point"}),") of a connected graph ",e.jsx(s,{math:"G"})," is a vertex whose deletion increases the number of components."]}),e.jsxs("p",{className:"mt-2",children:["A ",e.jsx("strong",{children:"cut-edge"})," (or ",e.jsx("strong",{children:"bridge"}),") is an edge whose deletion increases the number of components."]})]}),e.jsxs(a,{title:"Theorem 4.1.3 (Cut-Edge Characterization)",children:[e.jsxs("p",{children:["An edge ",e.jsx(s,{math:"e"})," is a cut-edge if and only if"," ",e.jsx(s,{math:"e"})," belongs to no cycle."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇒)"})," If ",e.jsx(s,{math:"e = uv"})," lies on a cycle, then any path using ",e.jsx(s,{math:"e"})," can be rerouted through the rest of the cycle. So ",e.jsx(s,{math:"G - e"})," is connected."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐)"})," If ",e.jsx(s,{math:"e = uv"})," lies on no cycle, then the unique ",e.jsx(s,{math:"u, v"}),"-path in ",e.jsx(s,{math:"G"})," uses"," ",e.jsx(s,{math:"e"}),". Deleting ",e.jsx(s,{math:"e"})," leaves no"," ",e.jsx(s,{math:"u, v"}),"-path."]})]})]})]}),e.jsx(a,{title:"Theorem 4.1.2 (Cut-Vertex Characterization)",children:e.jsxs("p",{children:["A vertex ",e.jsx(s,{math:"v"})," in a connected graph ",e.jsx(s,{math:"G"})," ","is a cut-vertex if and only if there exist vertices"," ",e.jsx(s,{math:"u, w \\neq v"})," such that every"," ",e.jsx(s,{math:"u, w"}),"-path passes through ",e.jsx(s,{math:"v"}),"."]})}),e.jsx("h2",{children:"Blocks"}),e.jsx("p",{children:"Graphs decompose naturally into pieces separated by cut-vertices."}),e.jsxs(t,{title:"Block",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"block"})," of a graph ",e.jsx(s,{math:"G"})," is a maximal connected subgraph of ",e.jsx(s,{math:"G"})," that has no cut-vertex."]}),e.jsx("p",{className:"mt-2 text-dark-300",children:"Equivalently, a block is either a maximal 2-connected subgraph, or a cut-edge (with its endpoints), or an isolated vertex."})]}),e.jsxs(a,{title:"Theorem 4.1.11 (Block Properties)",children:[e.jsxs("ol",{className:"list-decimal list-inside space-y-1",children:[e.jsx("li",{children:"Every edge belongs to exactly one block."}),e.jsx("li",{children:"Two blocks share at most one vertex (which must be a cut-vertex)."}),e.jsxs("li",{children:["The blocks partition ",e.jsx(s,{math:"E(G)"}),"."]})]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Part 1:"})," Let ",e.jsx(s,{math:"e = uv"})," be an edge. Consider the subgraph ",e.jsx(s,{math:"H"})," consisting of all edges that lie on a common cycle with ",e.jsx(s,{math:"e"}),", plus"," ",e.jsx(s,{math:"e"})," itself."]}),e.jsxs("p",{className:"mt-2",children:["We claim ",e.jsx(s,{math:"H"})," is a block. If"," ",e.jsx(s,{math:"H"})," has a cut-vertex ",e.jsx(s,{math:"v"}),", then some edge ",e.jsx(s,{math:"f"})," in ",e.jsx(s,{math:"H"})," would be separated from ",e.jsx(s,{math:"e"})," by ",e.jsx(s,{math:"v"}),". But"," ",e.jsx(s,{math:"f"})," is in ",e.jsx(s,{math:"H"})," precisely because it lies on a cycle with ",e.jsx(s,{math:"e"}),", so removing"," ",e.jsx(s,{math:"v"})," cannot separate them—contradiction."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx(s,{math:"H"})," is maximal: any edge sharing a cycle with any edge of ",e.jsx(s,{math:"H"})," also shares a cycle with ",e.jsx(s,{math:"e"})," ",'(by transitivity of the "same cycle" relation).']}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 2:"})," Suppose blocks ",e.jsx(s,{math:"B_1"})," and"," ",e.jsx(s,{math:"B_2"})," share two vertices ",e.jsx(s,{math:"u"})," and"," ",e.jsx(s,{math:"v"}),". Since ",e.jsx(s,{math:"B_1"})," is 2-connected, there exist internally disjoint ",e.jsx(s,{math:"u, v"}),"-paths in"," ",e.jsx(s,{math:"B_1"}),". Similarly for ",e.jsx(s,{math:"B_2"}),"."]}),e.jsx("p",{className:"mt-2",children:"Taking one path from each block gives a cycle containing edges from both blocks. By Part 1, these edges belong to the same block—contradiction."}),e.jsxs("p",{className:"mt-2",children:["If blocks share exactly one vertex ",e.jsx(s,{math:"v"}),", then"," ",e.jsx(s,{math:"v"})," is a cut-vertex: removing it separates the blocks."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Part 3:"})," Follows from Part 1: each edge is in exactly one block, and every edge is in some block (the edge itself forms a block if it's a cut-edge)."]})]})]})]}),e.jsxs(i,{title:"Finding Blocks",children:[e.jsxs("p",{children:["Consider a graph that is two triangles sharing a vertex ",e.jsx(s,{math:"v"}),". The graph has:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["One cut-vertex: ",e.jsx(s,{math:"v"})]}),e.jsx("li",{children:"Two blocks: the two triangles"}),e.jsx("li",{children:e.jsx(s,{math:"\\kappa(G) = 1"})})]}),e.jsxs("p",{className:"mt-2",children:["A path ",e.jsx(s,{math:"P_n"})," has ",e.jsx(s,{math:"n - 1"})," blocks, each being a single edge."]})]}),e.jsx("h3",{children:"Block-Cutpoint Graph"}),e.jsxs(t,{title:"Block-Cutpoint Graph",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"block-cutpoint graph"})," (or ",e.jsx("strong",{children:"BC-tree"}),") of a connected graph ",e.jsx(s,{math:"G"})," is a bipartite graph"," ",e.jsx(s,{math:"H"})," where:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["One partite set consists of the blocks of ",e.jsx(s,{math:"G"})]}),e.jsxs("li",{children:["The other partite set consists of the cut-vertices of"," ",e.jsx(s,{math:"G"})]}),e.jsxs("li",{children:["Block ",e.jsx(s,{math:"B"})," is adjacent to cut-vertex"," ",e.jsx(s,{math:"v"})," iff ",e.jsx(s,{math:"v \\in V(B)"})]})]})]}),e.jsxs(a,{title:"Theorem 4.1.12",children:[e.jsx("p",{children:"The block-cutpoint graph of a connected graph is a tree."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{math:"G"})," be a connected graph and"," ",e.jsx(s,{math:"H"})," be its block-cutpoint graph."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Connectedness:"})," We show ",e.jsx(s,{math:"H"})," is connected. For any two blocks ",e.jsx(s,{math:"B_1, B_2"}),", pick vertices"," ",e.jsx(s,{math:"u \\in B_1"})," and ",e.jsx(s,{math:"v \\in B_2"}),". Since"," ",e.jsx(s,{math:"G"})," is connected, there is a ",e.jsx(s,{math:"u, v"}),"-path in ",e.jsx(s,{math:"G"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This path passes through a sequence of blocks, consecutive blocks sharing a cut-vertex. This gives a path in ",e.jsx(s,{math:"H"})," from"," ",e.jsx(s,{math:"B_1"})," to ",e.jsx(s,{math:"B_2"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Acyclicity:"})," Suppose ",e.jsx(s,{math:"H"})," contains a cycle. Since ",e.jsx(s,{math:"H"})," is bipartite (blocks and cut-vertices alternate), the cycle has form"," ",e.jsx(s,{math:"B_1, v_1, B_2, v_2, \\ldots, B_k, v_k, B_1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Consider what this means in ",e.jsx(s,{math:"G"}),": we can go from"," ",e.jsx(s,{math:"B_1"})," through ",e.jsx(s,{math:"v_1"})," to"," ",e.jsx(s,{math:"B_2"}),", etc., and return to ",e.jsx(s,{math:"B_1"})," ","through ",e.jsx(s,{math:"v_k"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This means ",e.jsx(s,{math:"v_1"})," and ",e.jsx(s,{math:"v_k"})," are both in ",e.jsx(s,{math:"B_1"}),", and we can reach ",e.jsx(s,{math:"v_k"})," ","from ",e.jsx(s,{math:"v_1"})," via a path through"," ",e.jsx(s,{math:"B_2, \\ldots, B_k"})," that avoids"," ",e.jsx(s,{math:"B_1 - \\{'{'}v_1, v_k{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Combined with paths in ",e.jsx(s,{math:"B_1"}),", this shows all the edges in ",e.jsx(s,{math:"B_1, B_2, \\ldots, B_k"})," lie on common cycles. By Theorem 4.1.11, they should all be in one block—contradicting that"," ",e.jsx(s,{math:"B_1, \\ldots, B_k"})," are distinct blocks."]})]})]})]}),e.jsx("h2",{children:"Edge Cuts and Bonds"}),e.jsx(t,{title:"Bond",children:e.jsxs("p",{children:["A ",e.jsx("strong",{children:"bond"})," is a minimal nonempty edge cut. Equivalently, a bond is an edge cut ",e.jsx(s,{math:"[S, \\overline{S}]"})," such that both"," ",e.jsx(s,{math:"G[S]"})," and ",e.jsx(s,{math:"G[\\overline{S}]"})," are connected."]})}),e.jsxs(a,{title:"Bond Characterization",children:[e.jsx("p",{children:"An edge cut is a bond if and only if it is a minimal disconnecting set."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇒)"})," Suppose ",e.jsx(s,{math:"[S, \\overline{S}]"})," is a bond, so both ",e.jsx(s,{math:"G[S]"})," and"," ",e.jsx(s,{math:"G[\\overline{S}]"})," are connected."]}),e.jsxs("p",{className:"mt-2",children:["We show it's minimal. Suppose we remove some edge"," ",e.jsx(s,{math:"e = uv"})," from the cut, where"," ",e.jsx(s,{math:"u \\in S"})," and ",e.jsx(s,{math:"v \\in \\overline{S}"}),". Since ",e.jsx(s,{math:"G[S]"})," is connected, there's a path from any"," ",e.jsx(s,{math:"s \\in S"})," to ",e.jsx(s,{math:"u"})," within"," ",e.jsx(s,{math:"S"}),". Since ",e.jsx(s,{math:"G[\\overline{S}]"})," is connected, there's a path from ",e.jsx(s,{math:"v"})," to any"," ",e.jsx(s,{math:"t \\in \\overline{S}"})," within ",e.jsx(s,{math:"\\overline{S}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Combined with edge ",e.jsx(s,{math:"e"}),", we get an"," ",e.jsx(s,{math:"s, t"}),"-path using only edges in"," ",e.jsx(s,{math:"G[S] \\cup G[\\overline{S}] \\cup \\{'{'}e{'}'}"}),". So"," ",e.jsx(s,{math:"[S, \\overline{S}] - \\{'{'}e{'}'}"})," doesn't disconnect—the bond is minimal."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐)"})," Suppose ",e.jsx(s,{math:"F"})," is a minimal disconnecting set. Then ",e.jsx(s,{math:"F"})," separates"," ",e.jsx(s,{math:"G"})," into components. Let ",e.jsx(s,{math:"S"})," be one component and ",e.jsx(s,{math:"\\overline{S}"})," be the union of all others."]}),e.jsxs("p",{className:"mt-2",children:["We must show ",e.jsx(s,{math:"G[\\overline{S}]"})," is connected (",e.jsx(s,{math:"G[S]"})," is connected by definition of component). If ",e.jsx(s,{math:"G[\\overline{S}]"})," has multiple components"," ",e.jsx(s,{math:"C_1, C_2, \\ldots"}),", then edges of ",e.jsx(s,{math:"F"})," ","go from ",e.jsx(s,{math:"S"})," to various ",e.jsx(s,{math:"C_i"}),"."]}),e.jsxs("p",{className:"mt-2",children:["But then ",e.jsx(s,{math:"F"})," minus edges to some"," ",e.jsx(s,{math:"C_j"})," still disconnects (separating"," ",e.jsx(s,{math:"S \\cup C_j"})," from other components). This contradicts minimality of ",e.jsx(s,{math:"F"}),". So"," ",e.jsx(s,{math:"G[\\overline{S}]"})," is connected, and"," ",e.jsx(s,{math:"F = [S, \\overline{S}]"})," is a bond."]})]})]})]}),e.jsx(i,{title:"Bonds in a Cycle",children:e.jsxs("p",{children:["In ",e.jsx(s,{math:"C_n"}),", the bonds are exactly the edge sets of size 2 (removing two edges disconnects). Any single edge is not a bond because its removal leaves the graph connected."]})}),e.jsx("h2",{children:"Finding Cut-Vertices (DFS Algorithm)"}),e.jsx("p",{children:"Tarjan's algorithm uses depth-first search to find all cut-vertices and bridges in linear time."}),e.jsxs(t,{title:"Tarjan's Algorithm",children:[e.jsxs("p",{children:["Key concepts for DFS from root ",e.jsx(s,{math:"r"}),":"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx(s,{math:"\\text{disc}[v]"}),": discovery time of"," ",e.jsx(s,{math:"v"})]}),e.jsxs("li",{children:[e.jsx(s,{math:"\\text{low}[v]"}),": minimum discovery time reachable from subtree of ",e.jsx(s,{math:"v"})," via back edges"]})]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Cut-vertex conditions:"})}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["Root ",e.jsx(s,{math:"r"})," is a cut-vertex iff it has ≥2 children in DFS tree"]}),e.jsxs("li",{children:["Non-root ",e.jsx(s,{math:"v"})," is a cut-vertex iff some child"," ",e.jsx(s,{math:"u"})," has"," ",e.jsx(s,{math:"\\text{low}[u] \\geq \\text{disc}[v]"})]})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Bridge condition:"})," Edge ",e.jsx(s,{math:"uv"})," (where"," ",e.jsx(s,{math:"v"})," is child of ",e.jsx(s,{math:"u"}),") is a bridge iff"," ",e.jsx(s,{math:"\\text{low}[v] > \\text{disc}[u]"}),"."]})]}),e.jsxs(a,{title:"Tarjan's Algorithm Complexity",children:[e.jsxs("p",{children:["All cut-vertices and bridges can be found in ",e.jsx(s,{math:"O(n + m)"})," ","time using DFS."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:e.jsx("strong",{children:"Correctness of cut-vertex detection:"})}),e.jsxs("p",{className:"mt-2",children:["For root ",e.jsx(s,{math:"r"}),": ",e.jsx(s,{math:"r"})," is a cut-vertex iff it has ≥2 children in the DFS tree. If ",e.jsx(s,{math:"r"})," has only one child, removing ",e.jsx(s,{math:"r"})," leaves the subtree connected. If ≥2 children, they can only communicate through ",e.jsx(s,{math:"r"})," ","(no cross edges between subtrees in DFS)."]}),e.jsxs("p",{className:"mt-2",children:["For non-root ",e.jsx(s,{math:"v"}),": ",e.jsx(s,{math:"v"})," is a cut-vertex iff some child ",e.jsx(s,{math:"u"})," has"," ",e.jsx(s,{math:"\\text{low}[u] \\geq \\text{disc}[v]"}),". This means the subtree rooted at ",e.jsx(s,{math:"u"})," has no back edge to an ancestor of"," ",e.jsx(s,{math:"v"}),", so removing ",e.jsx(s,{math:"v"})," disconnects this subtree."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Correctness of bridge detection:"})}),e.jsxs("p",{className:"mt-2",children:["Edge ",e.jsx(s,{math:"(u, v)"})," (where ",e.jsx(s,{math:"v"})," is child of"," ",e.jsx(s,{math:"u"}),") is a bridge iff"," ",e.jsx(s,{math:"\\text{low}[v] > \\text{disc}[u]"}),". This means no vertex in"," ",e.jsx(s,{math:"v"}),"'s subtree can reach ",e.jsx(s,{math:"u"})," or its ancestors except through edge ",e.jsx(s,{math:"(u, v)"}),", so"," ",e.jsx(s,{math:"(u, v)"})," lies on no cycle."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Time complexity:"})}),e.jsxs("p",{className:"mt-2",children:["DFS visits each vertex once: ",e.jsx(s,{math:"O(n)"}),". Each edge is examined twice (once from each endpoint): ",e.jsx(s,{math:"O(m)"}),". Computing ",e.jsx(s,{math:"\\text{low}[v]"})," values during DFS adds only constant work per edge."]}),e.jsxs("p",{className:"mt-2",children:["Total: ",e.jsx(s,{math:"O(n + m)"}),"."]})]})]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Connectivity Hierarchy:"})," ",e.jsx(s,{math:"\\kappa(G) \\leq \\kappa'(G) \\leq \\delta(G)"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Cut-vertex:"})," A vertex whose removal disconnects the graph."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Bridge:"})," An edge whose removal disconnects; equivalently, an edge on no cycle."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Blocks:"})," Maximal 2-connected subgraphs; partition the edges and share at most cut-vertices."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"BC-tree:"})," The block-cutpoint graph is always a tree, revealing the hierarchical structure."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Efficiency:"})," All cut-vertices and bridges can be found in linear time using DFS."]})]})]})}export{j as default};
