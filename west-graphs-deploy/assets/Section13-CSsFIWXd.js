import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as xe,D as y,E as L,T as p}from"./ContentBlocks-BAFtEaU8.js";import{I as s,M as k}from"./MathBlock-_bBfq7Jh.js";import{r as m}from"./vendor-react-Drj8qL0h.js";import{c as ue,d as je,C as N,b as ge,f as fe,h as pe}from"./HamiltonianFinder-Baj_YtFX.js";import"./index-CvzwYuJV.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function H(){return{nodes:[{id:"s",x:80,y:200,label:"s",color:"#22c55e"},{id:"a",x:200,y:100,label:"a"},{id:"b",x:200,y:300,label:"b"},{id:"c",x:350,y:100,label:"c"},{id:"d",x:350,y:300,label:"d"},{id:"t",x:520,y:200,label:"t",color:"#ef4444"}],edges:[{source:"s",target:"a",capacity:10,flow:0,directed:!0},{source:"s",target:"b",capacity:8,flow:0,directed:!0},{source:"a",target:"c",capacity:5,flow:0,directed:!0},{source:"a",target:"d",capacity:7,flow:0,directed:!0},{source:"b",target:"a",capacity:3,flow:0,directed:!0},{source:"b",target:"d",capacity:8,flow:0,directed:!0},{source:"c",target:"t",capacity:10,flow:0,directed:!0},{source:"d",target:"c",capacity:4,flow:0,directed:!0},{source:"d",target:"t",capacity:12,flow:0,directed:!0}],source:"s",sink:"t"}}function we(){return{nodes:[{id:"s",x:100,y:200,label:"s",color:"#22c55e"},{id:"a",x:250,y:100,label:"a"},{id:"b",x:250,y:300,label:"b"},{id:"t",x:500,y:200,label:"t",color:"#ef4444"}],edges:[{source:"s",target:"a",capacity:5,flow:0,directed:!0},{source:"s",target:"b",capacity:4,flow:0,directed:!0},{source:"a",target:"b",capacity:3,flow:0,directed:!0},{source:"a",target:"t",capacity:6,flow:0,directed:!0},{source:"b",target:"t",capacity:5,flow:0,directed:!0}],source:"s",sink:"t"}}function ve({className:B=""}){const S=m.useRef(null),[d,T]=m.useState(H()),[x,A]=m.useState([]),[j,F]=m.useState(-1),[q,P]=m.useState(!1),[_,Q]=m.useState("medium"),[M,C]=m.useState([]),[ye,be]=m.useState(!1),[w,O]=m.useState(new Set),[b,Z]=m.useState(!1),[W,G]=m.useState(null),R=600,D=400,ee={slow:1500,medium:800,fast:300},z=n=>{const t=[{node:n.source,path:[n.source]}],c=new Set([n.source]);for(;t.length>0;){const{node:a,path:o}=t.shift();for(const i of n.edges){if(i.source===a&&!c.has(i.target)&&i.capacity-i.flow>0){const l=[...o,i.target];if(i.target===n.sink){let h=1/0;for(let g=0;g<l.length-1;g++){const u=n.edges.find(v=>v.source===l[g]&&v.target===l[g+1]);u&&(h=Math.min(h,u.capacity-u.flow))}return{path:l,bottleneck:h}}c.add(i.target),t.push({node:i.target,path:l})}if(i.target===a&&!c.has(i.source)&&i.flow>0){const r=[...o,i.source];if(i.source===n.sink){let l=i.flow;return{path:r,bottleneck:l}}c.add(i.source),t.push({node:i.source,path:r})}}}return null},se=()=>{P(!0);const n=[],t=JSON.parse(JSON.stringify(d));for(const r of t.edges)r.flow=0;let c=z(t);for(;c;){const{path:r,bottleneck:l}=c;n.push({path:r,flow:l,action:"find_path"});for(let h=0;h<r.length-1;h++){const g=t.edges.find(u=>u.source===r[h]&&u.target===r[h+1]);g&&(g.flow+=l)}n.push({path:r,flow:l,action:"augment"}),c=z(t)}const a=t.edges.filter(r=>r.source===t.source).reduce((r,l)=>r+l.flow,0);n.push({path:[],flow:a,action:"complete"}),A(n),F(-1);const o=new Set([t.source]),i=[t.source];for(;i.length>0;){const r=i.shift();for(const l of t.edges)l.source===r&&!o.has(l.target)&&l.capacity-l.flow>0&&(o.add(l.target),i.push(l.target))}O(o)};m.useEffect(()=>{if(!q||j>=x.length-1){if(j>=x.length-1&&x.length>0){P(!1);const t=JSON.parse(JSON.stringify(d));for(const c of t.edges)c.flow=0;for(let c=0;c<x.length;c++){const a=x[c];if(a.action==="augment")for(let o=0;o<a.path.length-1;o++){const i=t.edges.find(r=>r.source===a.path[o]&&r.target===a.path[o+1]);i&&(i.flow+=a.flow)}}T(t)}return}const n=setTimeout(()=>{F(t=>t+1)},ee[_]);return()=>clearTimeout(n)},[q,j,x.length,_]),m.useEffect(()=>{if(j<0){C([]);return}const n=x[j];if(n&&(C(n.path),n.action==="augment")){const t=JSON.parse(JSON.stringify(d));for(let c=0;c<=j;c++){const a=x[c];if(a.action==="augment")for(let o=0;o<a.path.length-1;o++){const i=t.edges.find(r=>r.source===a.path[o]&&r.target===a.path[o+1]);i&&(i.flow+=a.flow)}}T(t)}},[j,x]),m.useEffect(()=>{const n=S.current;if(!n)return;const t=n.getContext("2d");if(!t)return;ue(t,R,D),je(t,R,D);const c=new Set;for(let a=0;a<M.length-1;a++)c.add(`${M[a]}-${M[a+1]}`);for(const a of d.edges){const o=c.has(`${a.source}-${a.target}`),i=a.flow>=a.capacity,r=d.nodes.find(h=>h.id===a.source),l=d.nodes.find(h=>h.id===a.target);if(r&&l){const h=(r.x+l.x)/2,g=(r.y+l.y)/2;t.strokeStyle=o?N.flow:i?"#ef4444":a.flow>0?N.path:N.edge,t.lineWidth=o?4:a.flow>0?3:2;const u=l.x-r.x,v=l.y-r.y,X=Math.sqrt(u*u+v*v),E=u/X,I=v/X,re=r.x+E*16,le=r.y+I*16,oe=l.x-E*26,ce=l.y-I*26;t.beginPath(),t.moveTo(re,le),t.lineTo(oe,ce),t.stroke();const de=l.x-E*16,he=l.y-I*16,me=Math.atan2(v,u);t.fillStyle=t.strokeStyle,t.save(),t.translate(de,he),t.rotate(me),t.beginPath(),t.moveTo(0,0),t.lineTo(-10,5),t.lineTo(-10,-5),t.closePath(),t.fill(),t.restore();const Y=15,K=-I*Y,J=E*Y;t.fillStyle=N.background;const V=`${a.flow}/${a.capacity}`,U=t.measureText(V);t.fillRect(h+K-U.width/2-4,g+J-10,U.width+8,20),t.fillStyle=i?"#ef4444":N.text,t.font="12px Inter, system-ui, sans-serif",t.textAlign="center",t.textBaseline="middle",t.fillText(V,h+K,g+J)}}if(b&&w.size>0){t.strokeStyle="#ef4444",t.lineWidth=3,t.setLineDash([8,4]);for(const a of d.edges)if(w.has(a.source)&&!w.has(a.target)){const o=d.nodes.find(r=>r.id===a.source),i=d.nodes.find(r=>r.id===a.target);o&&i&&(t.beginPath(),t.moveTo(o.x,o.y),t.lineTo(i.x,i.y),t.stroke())}t.setLineDash([])}for(const a of d.nodes){const o=M.includes(a.id),i=b&&w.has(a.id);ge(t,a,{fillColor:a.color??(i?"#22c55e40":N.node),highlighted:o||a.id===W,strokeColor:i?"#22c55e":void 0,strokeWidth:i?3:2})}},[d,M,b,w,W]);const te=m.useCallback(n=>{var o;const t=S.current;if(!t)return;const{x:c,y:a}=fe(n,t);G(((o=pe(c,a,d.nodes))==null?void 0:o.id)??null)},[d]),ae=()=>{T(H()),A([]),F(-1),C([]),O(new Set),P(!1)},ie=()=>{T(we()),A([]),F(-1),C([]),O(new Set),P(!1)},ne=()=>{const n={...d};n.edges=n.edges.map(t=>({...t,flow:0})),T(n),A([]),F(-1),C([]),O(new Set)},$=d.edges.filter(n=>n.source===d.source).reduce((n,t)=>n+t.flow,0),f=j>=0?x[j]:null;return e.jsxs("div",{className:`p-6 rounded-2xl bg-dark-800/50 border border-dark-700/50 ${B}`,children:[e.jsx("h3",{className:"text-xl font-bold text-dark-100 mb-2",children:"Network Flow"}),e.jsx("p",{className:"text-dark-300 mb-6",children:"Visualize the Ford-Fulkerson algorithm finding maximum flow. Watch as augmenting paths are discovered and flow is pushed through the network."}),e.jsxs("div",{className:"flex flex-col xl:flex-row gap-6",children:[e.jsxs("div",{className:"flex-shrink-0",children:[e.jsx("canvas",{ref:S,width:R,height:D,className:"rounded-xl border border-dark-600",style:{cursor:W?"pointer":"default"},onMouseMove:te,onMouseLeave:()=>G(null)}),e.jsxs("div",{className:"mt-4 flex flex-wrap gap-2",children:[e.jsx("button",{onClick:ae,className:"px-3 py-2 bg-dark-700 text-dark-200 rounded-lg text-sm hover:bg-dark-600",children:"Complex Network"}),e.jsx("button",{onClick:ie,className:"px-3 py-2 bg-dark-700 text-dark-200 rounded-lg text-sm hover:bg-dark-600",children:"Simple Network"})]})]}),e.jsxs("div",{className:"flex-1 space-y-4 min-w-0",children:[e.jsxs("div",{children:[e.jsx("label",{className:"block text-sm font-medium text-dark-200 mb-2",children:"Animation Speed"}),e.jsx("div",{className:"flex gap-2",children:["slow","medium","fast"].map(n=>e.jsx("button",{onClick:()=>Q(n),className:`px-3 py-1.5 rounded-lg text-sm capitalize ${_===n?"bg-blue-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600"}`,children:n},n))})]}),e.jsxs("div",{className:"flex flex-wrap gap-2",children:[e.jsx("button",{onClick:se,disabled:q,className:"px-4 py-2 bg-cyan-600 text-white rounded-lg text-sm font-medium hover:bg-cyan-700 disabled:opacity-50",children:q?"Running...":"Run Ford-Fulkerson"}),e.jsx("button",{onClick:ne,className:"px-4 py-2 bg-dark-700 text-dark-200 rounded-lg text-sm hover:bg-dark-600",children:"Clear Flows"}),e.jsxs("button",{onClick:()=>Z(!b),disabled:w.size===0,className:`px-4 py-2 rounded-lg text-sm ${b?"bg-red-600 text-white":"bg-dark-700 text-dark-200 hover:bg-dark-600 disabled:opacity-50"}`,children:[b?"Hide":"Show"," Min-Cut"]})]}),f&&e.jsxs("div",{className:`p-4 rounded-lg ${f.action==="complete"?"bg-green-900/30":f.action==="augment"?"bg-cyan-900/30":"bg-yellow-900/30"}`,children:[e.jsxs("div",{className:"flex justify-between items-center mb-2",children:[e.jsx("span",{className:"font-medium text-dark-100",children:f.action==="complete"?"Complete!":f.action==="augment"?"Augmenting...":"Found Path"}),e.jsxs("span",{className:"text-sm text-dark-300",children:["Step ",j+1,"/",x.length]})]}),f.path.length>0&&e.jsxs("div",{className:"text-sm text-dark-300",children:["Path: ",f.path.join(" → ")]}),f.action!=="complete"&&e.jsxs("div",{className:"text-sm text-cyan-400 mt-1",children:["Bottleneck: ",f.flow]})]}),e.jsxs("div",{className:"grid grid-cols-2 gap-4",children:[e.jsxs("div",{className:"p-3 bg-dark-700/50 rounded-lg",children:[e.jsx("div",{className:"text-2xl font-bold text-cyan-400",children:$}),e.jsx("div",{className:"text-sm text-dark-300",children:"Total Flow"})]}),e.jsxs("div",{className:"p-3 bg-dark-700/50 rounded-lg",children:[e.jsx("div",{className:"text-2xl font-bold text-dark-100",children:w.size>0?$:"—"}),e.jsx("div",{className:"text-sm text-dark-300",children:"Min-Cut Value"})]})]}),e.jsxs("div",{className:"p-4 bg-dark-700/50 rounded-lg",children:[e.jsx("div",{className:"text-sm font-medium text-dark-200 mb-2",children:"Max-Flow Min-Cut Theorem"}),e.jsx("div",{className:"text-sm text-dark-300",children:"The maximum flow equals the minimum cut capacity. The green vertices show the source side of the minimum cut."})]}),e.jsxs("div",{className:"text-sm text-dark-400 space-y-1",children:[e.jsxs("p",{children:[e.jsx("span",{className:"text-green-400",children:"●"})," Source vertex"]}),e.jsxs("p",{children:[e.jsx("span",{className:"text-red-400",children:"●"})," Sink vertex"]}),e.jsxs("p",{children:[e.jsx("span",{className:"text-cyan-400",children:"—"})," Current augmenting path"]}),e.jsxs("p",{children:[e.jsx("span",{className:"text-red-400",children:"—"})," Saturated edge (flow = capacity)"]})]})]})]})]})}function qe(){return e.jsxs(xe,{sectionId:13,children:[e.jsx("p",{children:`Network flow theory studies how to route "flow" through a network from a source to a sink, respecting capacity constraints. The Max-flow Min-cut Theorem is a cornerstone of combinatorial optimization, elegantly connecting Menger's Theorem to linear programming duality. Flow networks model transportation, communication, and many other systems.`}),e.jsx("h2",{children:"Interactive Flow Network"}),e.jsx("p",{children:"Watch the Ford-Fulkerson algorithm find maximum flow. See augmenting paths, observe flow being pushed through the network, and discover the minimum cut."}),e.jsx(ve,{className:"my-8"}),e.jsx("h2",{children:"Networks and Flows"}),e.jsxs(y,{title:"Network",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"network"})," is a digraph ",e.jsx(s,{math:"N"})," with:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["A ",e.jsx("strong",{children:"source"})," ",e.jsx(s,{math:"s"})," with"," ",e.jsx(s,{math:"d^-(s) = 0"})," (no incoming edges)"]}),e.jsxs("li",{children:["A ",e.jsx("strong",{children:"sink"})," ",e.jsx(s,{math:"t"})," with"," ",e.jsx(s,{math:"d^+(t) = 0"})," (no outgoing edges)"]}),e.jsxs("li",{children:["A ",e.jsx("strong",{children:"capacity function"})," ",e.jsx(s,{math:"c: E(N) \\to \\mathbb{R}^+"})," assigning nonnegative capacities to edges"]})]})]}),e.jsxs(y,{title:"Flow",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"flow"})," on network ",e.jsx(s,{math:"N"})," is a function"," ",e.jsx(s,{math:"f: E(N) \\to \\mathbb{R}^+"})," satisfying:"]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Capacity constraint:"})," ",e.jsx(s,{math:"0 \\leq f(e) \\leq c(e)"})," for all edges"," ",e.jsx(s,{math:"e"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Conservation:"})," For all ",e.jsx(s,{math:"v \\neq s, t"}),":",e.jsx(k,{math:"f^-(v) = f^+(v)"}),"(flow in = flow out)"]})]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"value"})," of flow ",e.jsx(s,{math:"f"})," is"," ",e.jsx(s,{math:"val(f) = f^+(s)"})," (total flow leaving the source)."]})]}),e.jsx(L,{title:"Transportation Network",children:e.jsxs("p",{children:["A distribution company ships goods from factory ",e.jsx(s,{math:"s"})," to warehouse ",e.jsx(s,{math:"t"})," through intermediate cities. Each road has a maximum capacity (trucks per day). A flow assigns truck routes respecting capacities and ensuring that at intermediate cities, trucks entering equals trucks leaving."]})}),e.jsx("h2",{children:"Cuts in Networks"}),e.jsxs(y,{title:"Source-Sink Cut",children:[e.jsxs("p",{children:["An ",e.jsx(s,{math:"s, t"}),"-",e.jsx("strong",{children:"cut"})," in network"," ",e.jsx(s,{math:"N"})," is a partition ",e.jsx(s,{math:"(S, T)"})," of"," ",e.jsx(s,{math:"V(N)"})," with ",e.jsx(s,{math:"s \\in S"})," and"," ",e.jsx(s,{math:"t \\in T"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"capacity"})," of cut ",e.jsx(s,{math:"(S, T)"})," is:"]}),e.jsx(k,{math:"cap(S, T) = \\sum_{e \\in [S, T]} c(e)"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{math:"[S, T]"})," denotes edges from ",e.jsx(s,{math:"S"})," ","to ",e.jsx(s,{math:"T"}),"."]})]}),e.jsxs(p,{title:"Lemma 4.3.4 (Weak Duality)",children:[e.jsxs("p",{children:["For any flow ",e.jsx(s,{math:"f"})," and any ",e.jsx(s,{math:"s, t"}),"-cut"," ",e.jsx(s,{math:"(S, T)"}),":"]}),e.jsx(k,{math:"val(f) \\leq cap(S, T)"}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:["Flow conservation means: for each ",e.jsx(s,{math:"v \\in S - \\{s\\}"}),", flow in equals flow out. Summing over all ",e.jsx(s,{math:"v \\in S"}),":"]}),e.jsx(k,{math:"val(f) = f^+(S) - f^-(S) \\leq f^+(S) \\leq cap(S, T)"}),e.jsxs("p",{children:["where ",e.jsx(s,{math:"f^+(S)"})," is total flow leaving"," ",e.jsx(s,{math:"S"}),"."]})]})]})]}),e.jsx("h2",{children:"The Max-Flow Min-Cut Theorem"}),e.jsxs(p,{title:"Max-Flow Min-Cut Theorem (Theorem 4.3.9)",children:[e.jsxs("p",{children:["In any network, the maximum value of a flow equals the minimum capacity of an"," ",e.jsx(s,{math:"s, t"}),"-cut:"]}),e.jsx(k,{math:"\\max_f val(f) = \\min_{(S,T)} cap(S, T)"}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch (Ford-Fulkerson)"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:"We show that when no augmenting path exists, the current flow equals some cut's capacity. Define:"}),e.jsx(k,{math:"S = \\{v : \\text{there is an augmenting path from } s \\text{ to } v\\}"}),e.jsxs("p",{className:"mt-2",children:["Since there's no augmenting path to ",e.jsx(s,{math:"t"}),","," ",e.jsx(s,{math:"t \\notin S"}),", so ",e.jsx(s,{math:"(S, T)"})," is a cut. For edges from ",e.jsx(s,{math:"S"})," to ",e.jsx(s,{math:"T"}),", flow equals capacity (else augmenting path exists). For edges from"," ",e.jsx(s,{math:"T"})," to ",e.jsx(s,{math:"S"}),", flow is 0. Thus"," ",e.jsx(s,{math:"val(f) = cap(S, T)"}),"."]})]})]})]}),e.jsxs(L,{title:"Computing Max-Flow",children:[e.jsxs("p",{children:["Consider a network with ",e.jsx(s,{math:"s \\to a \\to t"})," (capacity 3),"," ",e.jsx(s,{math:"s \\to b \\to t"})," (capacity 2), and"," ",e.jsx(s,{math:"a \\to b"})," (capacity 1)."]}),e.jsxs("p",{className:"mt-2",children:["Maximum flow: Send 3 through ",e.jsx(s,{math:"s \\to a \\to t"})," and 2 through ",e.jsx(s,{math:"s \\to b \\to t"}),". Total value = 5."]}),e.jsxs("p",{className:"mt-2",children:["Minimum cut: ",e.jsx(s,{math:"S = \\{s\\}"}),","," ",e.jsx(s,{math:"T = \\{a, b, t\\}"}),". Cut capacity = 3 + 2 = 5. ✓"]})]}),e.jsx("h2",{children:"The Ford-Fulkerson Algorithm"}),e.jsxs(y,{title:"Residual Network",children:[e.jsxs("p",{children:["Given network ",e.jsx(s,{math:"N"})," and flow ",e.jsx(s,{math:"f"}),", the"," ",e.jsx("strong",{children:"residual network"})," ",e.jsx(s,{math:"N_f"})," has:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Forward edges:"})," For each edge"," ",e.jsx(s,{math:"e = (u, v)"})," with ",e.jsx(s,{math:"f(e) < c(e)"}),", include ",e.jsx(s,{math:"(u, v)"})," with residual capacity"," ",e.jsx(s,{math:"c(e) - f(e)"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Backward edges:"})," For each edge"," ",e.jsx(s,{math:"e = (u, v)"})," with ",e.jsx(s,{math:"f(e) > 0"}),", include ",e.jsx(s,{math:"(v, u)"})," with residual capacity"," ",e.jsx(s,{math:"f(e)"}),"."]})]})]}),e.jsxs(y,{title:"Augmenting Path",children:[e.jsxs("p",{children:["An ",e.jsx("strong",{children:"augmenting path"})," for flow ",e.jsx(s,{math:"f"})," is an"," ",e.jsx(s,{math:"s, t"}),"-path in the residual network"," ",e.jsx(s,{math:"N_f"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"bottleneck"})," of an augmenting path is the minimum residual capacity along the path."]})]}),e.jsx(y,{title:"Ford-Fulkerson Algorithm",children:e.jsxs("ol",{className:"list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Initialize ",e.jsx(s,{math:"f(e) = 0"})," for all edges."]}),e.jsxs("li",{children:["While there exists an augmenting path ",e.jsx(s,{math:"P"}),":",e.jsxs("ul",{className:"ml-4 list-disc list-inside",children:[e.jsxs("li",{children:["Find bottleneck ",e.jsx(s,{math:"\\delta = \\min_{e \\in P} c_f(e)"}),"."]}),e.jsxs("li",{children:["For each edge ",e.jsx(s,{math:"(u, v)"})," in ",e.jsx(s,{math:"P"}),":",e.jsxs("ul",{className:"ml-4 list-disc list-inside",children:[e.jsxs("li",{children:["If forward edge: increase ",e.jsx(s,{math:"f(u, v)"})," by"," ",e.jsx(s,{math:"\\delta"}),"."]}),e.jsxs("li",{children:["If backward edge: decrease ",e.jsx(s,{math:"f(v, u)"})," by"," ",e.jsx(s,{math:"\\delta"}),"."]})]})]})]})]}),e.jsxs("li",{children:["Return ",e.jsx(s,{math:"f"}),"."]})]})}),e.jsxs(p,{title:"Ford-Fulkerson Correctness",children:[e.jsxs("p",{children:["The Ford-Fulkerson algorithm terminates with a maximum flow when all capacities are rational. With integer capacities, running time is"," ",e.jsx(s,{math:"O(m \\cdot val(f^*))"})," where"," ",e.jsx(s,{math:"val(f^*)"})," is the maximum flow value."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," The algorithm terminates when no augmenting path exists. At this point, define"," ",e.jsx(s,{math:"S = \\{'{'}v : v \\text{ reachable from } s \\text{ in } N_f{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(s,{math:"t \\notin S"})," (no augmenting path to"," ",e.jsx(s,{math:"t"}),"), ",e.jsx(s,{math:"(S, V - S)"})," is an"," ",e.jsx(s,{math:"s, t"}),"-cut."]}),e.jsxs("p",{className:"mt-2",children:["For edges ",e.jsx(s,{math:"(u, v)"})," with ",e.jsx(s,{math:"u \\in S"})," ","and ",e.jsx(s,{math:"v \\notin S"}),": we have"," ",e.jsx(s,{math:"f(u, v) = c(u, v)"})," (else there would be residual capacity and ",e.jsx(s,{math:"v"})," would be reachable)."]}),e.jsxs("p",{className:"mt-2",children:["For edges ",e.jsx(s,{math:"(v, u)"})," with ",e.jsx(s,{math:"v \\notin S"})," ","and ",e.jsx(s,{math:"u \\in S"}),": we have ",e.jsx(s,{math:"f(v, u) = 0"})," ","(else there would be a backward edge and ",e.jsx(s,{math:"v"})," would be reachable)."]}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(s,{math:"val(f) = cap(S, V - S)"}),". By weak duality,"," ",e.jsx(s,{math:"f"})," is maximum and ",e.jsx(s,{math:"(S, V - S)"})," ","is a minimum cut."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Termination:"})," With integer capacities, each augmentation increases ",e.jsx(s,{math:"val(f)"})," by at least 1. Since"," ",e.jsx(s,{math:"val(f) \\leq val(f^*)"}),", we have at most"," ",e.jsx(s,{math:"val(f^*)"})," augmentations."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Time:"})," Finding an augmenting path takes"," ",e.jsx(s,{math:"O(m)"})," (BFS/DFS). Total:"," ",e.jsx(s,{math:"O(m \\cdot val(f^*))"}),"."]})]})]})]}),e.jsx("h3",{children:"Improved Algorithms"}),e.jsx("p",{children:"By choosing augmenting paths more carefully, we can guarantee polynomial time:"}),e.jsxs(p,{title:"Edmonds-Karp Algorithm (1972)",children:[e.jsxs("p",{children:["Using BFS to find shortest augmenting paths, maximum flow can be computed in"," ",e.jsx(s,{math:"O(nm^2)"})," time."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Key lemma:"})," If we always augment along shortest paths (by number of edges), then for any vertex ",e.jsx(s,{math:"v"}),", the distance"," ",e.jsx(s,{math:"d(s, v)"})," in the residual network never decreases throughout the algorithm."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Proof of lemma:"})," Suppose ",e.jsx(s,{math:"d'(s, v) < d(s, v)"})," ","after an augmentation, where ",e.jsx(s,{math:"d'"})," is the new distance. Take the first such ",e.jsx(s,{math:"v"})," (minimum ",e.jsx(s,{math:"d'(s, v)"}),")."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"u"})," be the predecessor of ",e.jsx(s,{math:"v"})," on a shortest ",e.jsx(s,{math:"s, v"}),"-path in ",e.jsx(s,{math:"N'_f"}),". Then ",e.jsx(s,{math:"d'(s, u) = d'(s, v) - 1"}),". By choice of"," ",e.jsx(s,{math:"v"}),", we have ",e.jsx(s,{math:"d(s, u) \\leq d'(s, u)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The edge ",e.jsx(s,{math:"(u, v)"})," is in ",e.jsx(s,{math:"N'_f"})," but either wasn't in ",e.jsx(s,{math:"N_f"})," (so we augmented along"," ",e.jsx(s,{math:"(v, u)"}),") or was. If we augmented along"," ",e.jsx(s,{math:"(v, u)"}),", then ",e.jsx(s,{math:"d(s, u) = d(s, v) + 1"}),", giving ",e.jsx(s,{math:"d'(s, v) \\geq d(s, v)"})," — contradiction."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Augmentation count:"})," An edge ",e.jsx(s,{math:"(u, v)"})," ",'can be "critical" (bottleneck) at most ',e.jsx(s,{math:"n/2"})," times. Each time it's critical, ",e.jsx(s,{math:"d(s, u)"})," increases by at least 2. With ",e.jsx(s,{math:"m"})," edges, total augmentations are"," ",e.jsx(s,{math:"O(nm)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Each BFS takes ",e.jsx(s,{math:"O(m)"})," time. Total:"," ",e.jsx(s,{math:"O(nm \\cdot m) = O(nm^2)"}),"."]})]})]})]}),e.jsxs(p,{title:"Dinic's Algorithm (1970)",children:[e.jsxs("p",{children:["Using blocking flows in layered networks, maximum flow can be computed in"," ",e.jsx(s,{math:"O(n^2 m)"})," time, or"," ",e.jsx(s,{math:"O(m\\sqrt{n})"})," for unit capacity networks."]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof Sketch"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Layered network:"})," Build a BFS layer structure from"," ",e.jsx(s,{math:"s"})," in the residual network. Layer ",e.jsx(s,{math:"L_i"})," ","contains vertices at distance ",e.jsx(s,{math:"i"})," from"," ",e.jsx(s,{math:"s"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Blocking flow:"})," A flow in the layered network where every"," ",e.jsx(s,{math:"s, t"}),"-path has at least one saturated edge. Finding a blocking flow takes ",e.jsx(s,{math:"O(nm)"})," time via DFS."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Key insight:"})," After finding a blocking flow and updating, the distance from ",e.jsx(s,{math:"s"})," to ",e.jsx(s,{math:"t"})," in the new residual network strictly increases. Since"," ",e.jsx(s,{math:"d(s, t) \\leq n - 1"}),", at most ",e.jsx(s,{math:"n"})," ","phases are needed."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"General case:"})," ",e.jsx(s,{math:"n"})," phases, each taking"," ",e.jsx(s,{math:"O(nm)"})," time. Total: ",e.jsx(s,{math:"O(n^2 m)"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Unit capacity:"})," When all capacities are 1, each phase saturates at least ",e.jsx(s,{math:"\\sqrt{m}"})," edges, and the number of phases before distance exceeds ",e.jsx(s,{math:"\\sqrt{n}"})," is"," ",e.jsx(s,{math:"O(\\sqrt{n})"}),". Total: ",e.jsx(s,{math:"O(m\\sqrt{n})"}),"."]})]})]})]}),e.jsx("h2",{children:"Integrality Theorem"}),e.jsxs(p,{title:"Integrality Theorem (Theorem 4.3.11)",children:[e.jsx("p",{children:"If all capacities in a network are integers, then there exists a maximum flow that is integer-valued on all edges."}),e.jsx("p",{className:"mt-2 text-dark-300",children:"The Ford-Fulkerson algorithm automatically produces such an integer flow."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsx("p",{children:"We show the Ford-Fulkerson algorithm maintains integer flows throughout."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Base case:"})," The initial flow ",e.jsx(s,{math:"f \\equiv 0"})," ","is integer-valued."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Inductive step:"})," Suppose ",e.jsx(s,{math:"f"})," is integer-valued. The residual network ",e.jsx(s,{math:"N_f"})," has capacities:"]}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["Forward edges: ",e.jsx(s,{math:"c(e) - f(e)"})," (integer minus integer)"]}),e.jsxs("li",{children:["Backward edges: ",e.jsx(s,{math:"f(e)"})," (integer)"]})]}),e.jsxs("p",{className:"mt-2",children:["All residual capacities are integers. The bottleneck"," ",e.jsx(s,{math:"\\delta"})," of any augmenting path is the minimum of integers, hence an integer."]}),e.jsx("p",{className:"mt-2",children:"After augmentation:"}),e.jsxs("ul",{className:"mt-2 list-disc list-inside",children:[e.jsxs("li",{children:["Forward edges: ",e.jsx(s,{math:"f(e) + \\delta"})," (integer + integer)"]}),e.jsxs("li",{children:["Backward edges: ",e.jsx(s,{math:"f(e) - \\delta"})," (integer − integer)"]})]}),e.jsx("p",{className:"mt-2",children:"The new flow is integer-valued. By induction, the final maximum flow is integer-valued."})]})]})]}),e.jsx("p",{children:"This theorem has powerful consequences: many combinatorial problems can be modeled as integer flow problems."}),e.jsx("h2",{children:"Applications of Max-Flow"}),e.jsx("h3",{children:"Menger's Theorem from Max-Flow"}),e.jsxs(p,{title:"Corollary 4.3.13 (Menger from Max-Flow)",children:[e.jsx("p",{children:"Menger's Theorem (edge version) follows from the Max-Flow Min-Cut Theorem by setting all capacities to 1."}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsx("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:e.jsxs("p",{children:["In a network with unit capacities, by integrality, maximum flow is the number of edge-disjoint ",e.jsx(s,{math:"s, t"}),"-paths. Minimum cut capacity is the minimum number of edges separating"," ",e.jsx(s,{math:"s"})," from ",e.jsx(s,{math:"t"}),". Max-Flow Min-Cut gives Menger's Theorem."]})})]})]}),e.jsx("h3",{children:"Bipartite Matching"}),e.jsxs(p,{title:"Maximum Bipartite Matching via Flow (Corollary 4.3.14)",children:[e.jsxs("p",{children:["Maximum matching in a bipartite graph ",e.jsx(s,{math:"G"})," can be computed by:"]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Create network: Add source ",e.jsx(s,{math:"s"})," connected to all"," ",e.jsx(s,{math:"X"}),"-vertices; add sink ",e.jsx(s,{math:"t"})," ","connected from all ",e.jsx(s,{math:"Y"}),"-vertices."]}),e.jsxs("li",{children:["Direct all edges from ",e.jsx(s,{math:"X"})," to ",e.jsx(s,{math:"Y"}),"."]}),e.jsx("li",{children:"Set all capacities to 1."}),e.jsx("li",{children:"Maximum flow value = Maximum matching size."})]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Matching → Flow:"})," Given a matching ",e.jsx(s,{math:"M"}),", define flow: ",e.jsx(s,{math:"f(e) = 1"})," for edges in ",e.jsx(s,{math:"M"})," ","and their incident ",e.jsx(s,{math:"s"}),"- and ",e.jsx(s,{math:"t"}),"-edges;",e.jsx(s,{math:"f(e) = 0"})," otherwise."]}),e.jsxs("p",{className:"mt-2",children:["This is a valid flow: capacity constraints hold (all edges have capacity 1), and conservation holds (each matched vertex has one unit in, one unit out). Flow value = ",e.jsx(s,{math:"|M|"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Flow → Matching:"})," By integrality, there's an integer maximum flow. Since capacities are 1, flow values are 0 or 1. Edges from"," ",e.jsx(s,{math:"X"})," to ",e.jsx(s,{math:"Y"})," with flow 1 form a matching (conservation ensures each vertex is used at most once)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Optimality:"})," Maximum flow corresponds to maximum matching since both directions preserve size."]})]})]})]}),e.jsx("h3",{children:"König-Egerváry from Max-Flow"}),e.jsx("p",{children:"The König-Egerváry Theorem (maximum matching = minimum vertex cover in bipartite graphs) also follows from Max-Flow Min-Cut applied to the bipartite matching network."}),e.jsx("h3",{children:"Edge-Disjoint Paths"}),e.jsxs(L,{title:"Multi-Commodity Flow",children:[e.jsx("p",{children:"A company needs to route data between multiple source-destination pairs through a network. Each link has limited bandwidth. The multi-commodity flow problem asks: can we satisfy all demands simultaneously?"}),e.jsx("p",{className:"mt-2",children:"For single source-destination, this reduces to max-flow. For multiple pairs, the problem becomes NP-hard in general but has efficient approximations."})]}),e.jsx("h2",{children:"Circulations"}),e.jsxs(y,{title:"Circulation",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"circulation"})," in a network is a flow where"," ",e.jsx(s,{math:"s = t"})," (source equals sink), so conservation holds at every vertex."]}),e.jsx("p",{className:"mt-2",children:"Equivalently, a circulation is an assignment of flows to edges satisfying capacity constraints and conservation everywhere."})]}),e.jsxs(p,{title:"Circulation with Demands (Theorem 4.3.19)",children:[e.jsxs("p",{children:["A network with demands ",e.jsx(s,{math:"d(v)"})," at each vertex (positive for sources, negative for sinks) has a feasible circulation if and only if:"]}),e.jsxs("ol",{className:"mt-2 list-decimal list-inside",children:[e.jsxs("li",{children:[e.jsx(s,{math:"\\sum_v d(v) = 0"})," (total demand is zero)"]}),e.jsxs("li",{children:["For every ",e.jsx(s,{math:"s, t"}),"-cut, the demand can be satisfied"]})]}),e.jsxs("details",{className:"mt-3",children:[e.jsx("summary",{className:"cursor-pointer text-blue-400 hover:text-blue-300",children:"Proof"}),e.jsxs("div",{className:"mt-2 pl-4 border-l-2 border-dark-700",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Reduction to max-flow:"})," Create a standard network by adding a super-source ",e.jsx(s,{math:"s^*"})," and super-sink"," ",e.jsx(s,{math:"t^*"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For each vertex ",e.jsx(s,{math:"v"})," with ",e.jsx(s,{math:"d(v) > 0"})," ","(source), add edge ",e.jsx(s,{math:"(s^*, v)"})," with capacity"," ",e.jsx(s,{math:"d(v)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For each vertex ",e.jsx(s,{math:"v"})," with ",e.jsx(s,{math:"d(v) < 0"})," ","(sink), add edge ",e.jsx(s,{math:"(v, t^*)"})," with capacity"," ",e.jsx(s,{math:"-d(v)"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Equivalence:"})," A feasible circulation exists iff there's a flow that saturates all edges out of ",e.jsx(s,{math:"s^*"})," and into"," ",e.jsx(s,{math:"t^*"}),". This happens iff maximum flow value equals"," ",e.jsx(s,{math:"\\sum_{d(v) > 0} d(v)"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Condition 1:"})," Necessary for any flow to exist (what flows out must equal what flows in)."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Condition 2:"})," By max-flow min-cut, max flow equals min cut. The condition ensures no cut is a bottleneck preventing demand satisfaction."]})]})]})]}),e.jsx("h2",{children:"Key Takeaways"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mt-4",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Max-Flow Min-Cut:"})," The central theorem: maximum flow value equals minimum cut capacity."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Ford-Fulkerson:"})," Find max-flow by repeatedly augmenting along paths in the residual network."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Integrality:"})," With integer capacities, there's always an integer maximum flow."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Unifies Theory:"})," Menger's Theorem, König-Egerváry, and Hall's Theorem all follow from Max-Flow Min-Cut."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Efficient Algorithms:"})," Edmonds-Karp"," ",e.jsx(s,{math:"O(nm^2)"}),", Dinic ",e.jsx(s,{math:"O(n^2 m)"}),", with better bounds for special cases."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Wide Applications:"})," Transportation, communication networks, bipartite matching, scheduling, and more."]})]})]})}export{qe as default};
