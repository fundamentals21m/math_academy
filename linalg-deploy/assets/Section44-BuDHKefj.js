import{j as e}from"./vendor-animation-6GFvN5rC.js";import{L as a,D as i,E as t,T as n}from"./ContentBlocks-_MgE7-JA.js";import{I as s,M as r}from"./MathBlock-BTK9YHZB.js";import"./vendor-react-ByzHzWFU.js";import"./index-BZQLok7r.js";import"./vendor-math-ClxlXyPc.js";import"./vendor-firebase-core-DIJkQv9Q.js";import"./index-Djvuv9mj.js";function p(){return e.jsxs(a,{sectionId:44,children:[e.jsxs("p",{children:["Linear algebra provides powerful tools for ",e.jsx("strong",{children:"cryptography"}),". Matrix operations over finite fields enable encryption, and coding theory uses linear algebra for error correction."]}),e.jsx("h2",{children:"Modular Arithmetic"}),e.jsxs(i,{title:"Finite Fields",className:"my-6",children:[e.jsxs("p",{children:["In cryptography, we work modulo a prime ",e.jsx(s,{children:"p"}),":"]}),e.jsx(r,{children:"\\mathbb{Z}_p = \\{0, 1, 2, \\ldots, p-1\\}"}),e.jsxs("p",{className:"mt-2",children:["All operations are performed mod ",e.jsx(s,{children:"p"}),". Every nonzero element has an inverse."]})]}),e.jsxs(t,{title:"Arithmetic in Z₇",className:"my-6",children:[e.jsxs("p",{children:["In ",e.jsx(s,{children:"\\mathbb{Z}_7"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[e.jsx("li",{children:e.jsx(s,{children:"3 + 5 = 8 \\equiv 1 \\pmod{7}"})}),e.jsx("li",{children:e.jsx(s,{children:"3 \\times 5 = 15 \\equiv 1 \\pmod{7}"})}),e.jsxs("li",{children:[e.jsx(s,{children:"3^{-1} = 5"})," (since ",e.jsx(s,{children:"3 \\times 5 = 1"}),")"]})]})]}),e.jsx("h2",{children:"Hill Cipher"}),e.jsxs(i,{title:"Hill Cipher",className:"my-6",children:[e.jsxs("p",{children:["Encrypt using an invertible matrix ",e.jsx(s,{children:"K"})," over ",e.jsx(s,{children:"\\mathbb{Z}_{26}"}),":"]}),e.jsx(r,{children:"\\mathbf{c} = K\\mathbf{m} \\pmod{26}"}),e.jsxs("p",{className:"mt-2",children:[e.jsx(s,{children:"\\mathbf{m}"})," = message (letters as numbers 0-25)",e.jsx("br",{}),e.jsx(s,{children:"\\mathbf{c}"})," = ciphertext",e.jsx("br",{}),"Decrypt: ",e.jsx(s,{children:"\\mathbf{m} = K^{-1}\\mathbf{c}"})]})]}),e.jsxs(t,{title:"2×2 Hill Cipher",className:"my-6",children:[e.jsx("p",{children:"Key matrix (mod 26):"}),e.jsx(r,{children:"K = \\begin{bmatrix} 3 & 2 \\\\ 5 & 7 \\end{bmatrix}, \\quad K^{-1} = \\begin{bmatrix} 7 & 24 \\\\ 15 & 17 \\end{bmatrix}"}),e.jsxs("p",{className:"mt-2",children:['Encrypt "HI" = (7, 8): ',e.jsx(s,{children:"K(7, 8)^T = (37, 91)^T \\equiv (11, 13)^T"}),' = "LN"']})]}),e.jsx("h2",{children:"Error-Correcting Codes"}),e.jsxs(i,{title:"Linear Code",className:"my-6",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"linear code"})," is a subspace of ",e.jsx(s,{children:"\\mathbb{Z}_2^n"}),". Encode message ",e.jsx(s,{children:"\\mathbf{m}"})," using generator matrix ",e.jsx(s,{children:"G"}),":"]}),e.jsx(r,{children:"\\mathbf{c} = G\\mathbf{m}"}),e.jsx("p",{className:"mt-2",children:"The code adds redundancy to detect and correct errors."})]}),e.jsxs(t,{title:"Hamming (7,4) Code",className:"my-6",children:[e.jsx("p",{children:"Encodes 4 data bits as 7 bits (3 parity bits):"}),e.jsx(r,{children:"G = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{bmatrix}"}),e.jsx("p",{className:"mt-2",children:"Can correct any single-bit error!"})]}),e.jsxs(n,{title:"Parity Check Matrix",className:"my-6",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Definition:"})," The parity check matrix ",e.jsx(s,{children:"H"})," satisfies ",e.jsx(s,{children:"HG = 0"})," where ",e.jsx(s,{children:"G"})," is the generator matrix."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Valid codewords:"})," If ",e.jsx(s,{children:"\\mathbf{c} = G\\mathbf{m}"})," is a valid codeword, then ",e.jsx(s,{children:"H\\mathbf{c} = HG\\mathbf{m} = \\mathbf{0}"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Error detection:"})," Received word ",e.jsx(s,{children:"\\mathbf{r} = \\mathbf{c} + \\mathbf{e}"})," where ",e.jsx(s,{children:"\\mathbf{e}"})," is the error pattern."]}),e.jsx(r,{children:"H\\mathbf{r} = H(\\mathbf{c} + \\mathbf{e}) = H\\mathbf{c} + H\\mathbf{e} = \\mathbf{0} + H\\mathbf{e} = H\\mathbf{e}"}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"syndrome"})," ",e.jsx(s,{children:"H\\mathbf{r}"})," depends only on the error pattern, not the message. If ",e.jsx(s,{children:"\\mathbf{e}"})," is a single bit error in position ",e.jsx(s,{children:"j"}),", then ",e.jsx(s,{children:"H\\mathbf{e}"})," equals column ",e.jsx(s,{children:"j"})," of ",e.jsx(s,{children:"H"}),", identifying the error location."]})]}),children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"parity check matrix"})," ",e.jsx(s,{children:"H"})," detects errors:"]}),e.jsx(r,{children:"H\\mathbf{c} = \\mathbf{0} \\quad \\text{if no error}"}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"H\\mathbf{r} \\neq \\mathbf{0}"}),", the syndrome tells us which bit is wrong."]})]}),e.jsx("h2",{children:"Modern Cryptography"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 my-6 border border-primary-500/20",children:[e.jsx("p",{className:"font-semibold text-primary-400 mb-2",children:"Linear Algebra in Modern Crypto"}),e.jsxs("ul",{className:"list-disc list-inside text-dark-300 text-sm space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"RSA:"})," Matrix operations over ",e.jsx(s,{children:"\\mathbb{Z}_n"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Elliptic curves:"})," Points form a group, arithmetic uses linear algebra"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Lattice cryptography:"})," Hard lattice problems (LWE, SIS)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Post-quantum:"})," Code-based and lattice-based systems"]})]})]}),e.jsx("h2",{children:"Lattice Problems"}),e.jsxs(i,{title:"Learning With Errors (LWE)",className:"my-6",children:[e.jsxs("p",{children:["Given ",e.jsx(s,{children:"A\\mathbf{s} + \\mathbf{e} \\approx \\mathbf{b}"})," where ",e.jsx(s,{children:"\\mathbf{e}"})," is small noise, find ",e.jsx(s,{children:"\\mathbf{s}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This is believed to be hard even for quantum computers, forming the basis of",e.jsx("strong",{children:" post-quantum cryptography"}),"."]})]}),e.jsx("h2",{children:"Key Ideas"}),e.jsx("div",{className:"bg-gradient-to-br from-primary-500/10 to-dark-800/50 rounded-xl p-6 my-6 border border-primary-500/20",children:e.jsxs("ul",{className:"space-y-3 text-dark-200",children:[e.jsxs("li",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-primary-400 font-bold",children:"1."}),e.jsxs("span",{children:["Cryptography uses linear algebra over finite fields ",e.jsx(s,{children:"\\mathbb{Z}_p"}),"."]})]}),e.jsxs("li",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-primary-400 font-bold",children:"2."}),e.jsxs("span",{children:["Hill cipher: ",e.jsx(s,{children:"\\mathbf{c} = K\\mathbf{m}"}),", decrypt with ",e.jsx(s,{children:"K^{-1}"}),"."]})]}),e.jsxs("li",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-primary-400 font-bold",children:"3."}),e.jsx("span",{children:"Linear codes: subspaces that add redundancy for error correction."})]}),e.jsxs("li",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-primary-400 font-bold",children:"4."}),e.jsxs("span",{children:["Parity check matrix ",e.jsx(s,{children:"H"}),": ",e.jsx(s,{children:"H\\mathbf{c} = 0"})," detects errors."]})]}),e.jsxs("li",{className:"flex items-start gap-3",children:[e.jsx("span",{className:"text-primary-400 font-bold",children:"5."}),e.jsx("span",{children:"Lattice-based crypto (LWE) is quantum-resistant."})]})]})})]})}export{p as default};
