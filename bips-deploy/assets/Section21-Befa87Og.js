import{j as e}from"./vendor-animation-CmxkKU9r.js";import"./vendor-react-DamxDR2H.js";import"./vendor-math-p018AHG0.js";import"./index-BjhgI7Zp.js";import{L as l,C as s,D as r,E as i}from"./Callout-Bm0ChKkk.js";import{M as t,I as a}from"./MathBlock-fCav0pL3.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./quizMap-C7tZlcUA.js";function k(){return e.jsxs(l,{sectionId:21,children:[e.jsx("h2",{className:"text-2xl font-bold text-dark-100 mb-6",children:"Merkelized Alternative Script Trees"}),e.jsxs("p",{className:"mb-4",children:["BIP-341 defines ",e.jsx("strong",{children:"Taproot"}),"—SegWit version 1. Taproot combines Schnorr signatures with Merkle trees to create outputs that look identical regardless of their complexity, dramatically improving privacy and efficiency for smart contracts."]}),e.jsx(s,{type:"info",title:"Activated: November 14, 2021",children:e.jsx("p",{children:"Taproot activated at block 709,632 via Speedy Trial (a modified BIP-9). It was Bitcoin's first consensus change since SegWit in 2017, representing years of cryptographic research and careful design."})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"The Core Insight"}),e.jsx("p",{className:"mb-4",children:'Most complex scripts have a "happy path"—the cooperative case where all parties agree. Taproot optimizes for this:'}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-6 border border-dark-700/50 mb-6",children:[e.jsx("p",{className:"text-amber-400 font-semibold mb-3",children:"Taproot's Key Innovation"}),e.jsxs("p",{className:"text-dark-300",children:["The output commits to both a ",e.jsx("strong",{children:"key path"})," (single signature for cooperation) and a ",e.jsx("strong",{children:"script path"})," (fallback scripts for disputes). When the key path is used, the scripts remain hidden—the spend looks like any single-sig transaction."]})]}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Output Structure"}),e.jsx("p",{className:"mb-4",children:"A Taproot output (P2TR) is a SegWit v1 witness program:"}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-5 font-mono text-sm mb-6",children:[e.jsx("p",{className:"text-dark-400 mb-2",children:"# P2TR scriptPubKey"}),e.jsx("p",{className:"text-amber-400",children:"OP_1 <32-byte-output-key>"}),e.jsx("p",{className:"text-xs text-dark-500 mt-3",children:"OP_1 indicates SegWit version 1. The 32 bytes are the x-only output key Q."})]}),e.jsxs(r,{title:"Output Key (Q)",children:[e.jsx("p",{children:"The output key Q is a tweaked version of the internal key P:"}),e.jsx(t,{children:"Q = P + H(P \\| m) \\cdot G"}),e.jsxs("p",{className:"mt-2",children:["Where ",e.jsx(a,{children:"m"}),' is the Merkle root of the script tree (or empty for key-path-only outputs). This "commits" the scripts to the public key.']})]}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Key Path Spending"}),e.jsx("p",{className:"mb-4",children:"The simplest way to spend a Taproot output—provide a Schnorr signature:"}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-5 mb-6",children:[e.jsx("p",{className:"text-dark-400 mb-2 font-mono text-sm",children:"# Witness for key path"}),e.jsx("p",{className:"font-mono text-sm text-amber-400",children:"<64-byte-schnorr-signature>"}),e.jsx("p",{className:"text-dark-500 text-xs mt-3",children:"That's it! Just one signature. No script revealed, no Merkle proof needed."})]}),e.jsx(i,{title:"Key Path Advantages",children:e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Privacy:"})," Indistinguishable from single-key spend"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Efficiency:"})," Smallest possible witness (64 bytes)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Multisig invisible:"})," With MuSig2, even N-of-N looks like 1-of-1"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Contracts hidden:"})," Complex conditions never revealed if unused"]})]})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Script Path Spending"}),e.jsx("p",{className:"mb-4",children:"When cooperation fails, fallback scripts can be revealed:"}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-5 font-mono text-sm mb-6",children:[e.jsx("p",{className:"text-dark-400 mb-2",children:"# Witness for script path"}),e.jsx("p",{className:"text-dark-300",children:"<script inputs...>"}),e.jsx("p",{className:"text-amber-400",children:"<script>"}),e.jsx("p",{className:"text-emerald-400",children:"<control block>"}),e.jsx("p",{className:"text-xs text-dark-500 mt-3",children:"Control block = leaf version || internal key || Merkle proof"})]}),e.jsx(r,{title:"MAST (Merkelized Alternative Script Trees)",children:e.jsx("p",{children:"Multiple spending conditions are organized in a Merkle tree. Only the path to the used script is revealed. Other conditions remain hidden, improving privacy for complex contracts."})}),e.jsx(i,{title:"Script Tree Example",children:e.jsxs("div",{className:"space-y-4",children:[e.jsx("p",{className:"text-dark-300",children:"A Lightning commitment might have these paths:"}),e.jsx("div",{className:"bg-dark-900 rounded-lg p-4 font-mono text-xs",children:e.jsx("pre",{className:"text-dark-300",children:`        [Root]
       /      \\
    [AB]      [CD]
   /    \\    /    \\
  A      B  C      D

A: Alice + Bob (key path via MuSig)
B: Alice after timeout
C: Bob with revocation key
D: HTLC redemption`})}),e.jsx("p",{className:"text-dark-500 text-sm",children:"If Alice and Bob cooperate (path A via key path), B/C/D are never revealed. Only a failure mode exposes the used script and its Merkle siblings."})]})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Control Block"}),e.jsx("p",{className:"mb-4",children:"The control block proves a script is committed to by the output:"}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-5 font-mono text-xs mb-6",children:[e.jsx("p",{className:"text-dark-400 mb-2",children:"# Control block structure"}),e.jsx("p",{children:e.jsx("span",{className:"text-purple-400",children:"[1 byte: leaf version + parity]"})}),e.jsx("p",{children:e.jsx("span",{className:"text-amber-400",children:"[32 bytes: internal key P x-coordinate]"})}),e.jsx("p",{children:e.jsx("span",{className:"text-emerald-400",children:"[32 × k bytes: Merkle proof]"})}),e.jsx("p",{className:"text-dark-500 mt-3",children:"The verifier reconstructs Q from P and the Merkle root, confirming the script is valid."})]}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Key Tweaking"}),e.jsx("p",{className:"mb-4",children:"The tweak binds scripts to the public key cryptographically:"}),e.jsx(t,{children:'t = \\text{tagged\\_hash}(\\text{"TapTweak"}, P \\| m)'}),e.jsx(t,{children:"Q = P + t \\cdot G"}),e.jsxs("p",{className:"mb-4 text-dark-400",children:["To sign for the key path, the signer computes the tweaked private key:",e.jsx(a,{children:"q = p + t"})]}),e.jsx(s,{type:"info",title:"Key-Only Outputs",children:e.jsxs("p",{children:["For outputs with no script tree (just key path), the tweak uses an empty Merkle root:",e.jsx("code",{className:"text-amber-400 ml-2",children:'t = tagged_hash("TapTweak", P)'}),". This proves no hidden scripts exist."]})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Benefits Summary"}),e.jsxs("div",{className:"grid md:grid-cols-2 gap-4 mb-6",children:[e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4 border border-emerald-500/30",children:[e.jsx("p",{className:"text-emerald-400 font-bold mb-2",children:"Privacy"}),e.jsxs("ul",{className:"text-sm text-dark-300 space-y-1",children:[e.jsx("li",{children:"Key path hides all scripts"}),e.jsx("li",{children:"Multisig looks like single-sig"}),e.jsx("li",{children:"Only used script revealed"})]})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4 border border-emerald-500/30",children:[e.jsx("p",{className:"text-emerald-400 font-bold mb-2",children:"Efficiency"}),e.jsxs("ul",{className:"text-sm text-dark-300 space-y-1",children:[e.jsx("li",{children:"64-byte key path witness"}),e.jsx("li",{children:"Log(n) Merkle proofs"}),e.jsx("li",{children:"Batch verification"})]})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4 border border-emerald-500/30",children:[e.jsx("p",{className:"text-emerald-400 font-bold mb-2",children:"Flexibility"}),e.jsxs("ul",{className:"text-sm text-dark-300 space-y-1",children:[e.jsx("li",{children:"Unlimited script paths"}),e.jsx("li",{children:"New opcodes via Tapscript"}),e.jsx("li",{children:"Future soft fork hooks"})]})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4 border border-emerald-500/30",children:[e.jsx("p",{className:"text-emerald-400 font-bold mb-2",children:"Security"}),e.jsxs("ul",{className:"text-sm text-dark-300 space-y-1",children:[e.jsx("li",{children:"Provably secure Schnorr"}),e.jsx("li",{children:"Tagged hash separation"}),e.jsx("li",{children:"Commitment binding"})]})]})]}),e.jsx(s,{type:"success",title:"The Modern Standard",children:e.jsx("p",{children:"Taproot is increasingly the default for new Bitcoin applications. Its combination of privacy, efficiency, and programmability makes it superior to P2WPKH/P2WSH for most use cases. Understanding Taproot is essential for modern Bitcoin development."})})]})}export{k as default};
