import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l,D as i,C as t,T as n,E as r}from"./Callout-iZusXhjX.js";import{M as s}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-DlQjnR56.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./quizMap-_5rFmvYC.js";function b(){return e.jsxs(l,{sectionId:11,children:[e.jsx("h2",{children:"Knapsack"}),e.jsx("p",{children:"The knapsack (or subset sum) problem was the first NP-complete problem proposed as a basis for public-key cryptography. While early knapsack cryptosystems were broken, they remain historically important and have influenced modern designs."}),e.jsx("h3",{children:"The Subset Sum Problem"}),e.jsxs(i,{title:"Subset Sum Problem",children:["Given a set of positive integers ",e.jsx(s,{math:"\\{a_1, a_2, \\ldots, a_n\\}",inline:!0})," and a target sum ",e.jsx("em",{children:"S"}),", find a subset that sums to ",e.jsx("em",{children:"S"}),". Equivalently, find"," ",e.jsx(s,{math:"x_1, x_2, \\ldots, x_n \\in \\{0, 1\\}",inline:!0})," such that:",e.jsx(s,{math:"\\sum_{i=1}^{n} x_i a_i = S"})]}),e.jsxs(t,{type:"info",children:[e.jsx("strong",{children:"NP-Completeness:"})," The subset sum problem is NP-complete. The general case is believed to have no polynomial-time algorithm."]}),e.jsx("h3",{children:"Superincreasing Sequences"}),e.jsxs(i,{title:"Superincreasing Sequence",children:["A sequence ",e.jsx(s,{math:"(b_1, b_2, \\ldots, b_n)",inline:!0})," is ",e.jsx("strong",{children:"superincreasing"})," ","if each element is greater than the sum of all preceding elements:",e.jsx(s,{math:"b_k > \\sum_{i=1}^{k-1} b_i \\quad \\text{for all } k \\geq 2"})]}),e.jsxs(n,{title:"Easy Knapsack",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We prove correctness of the greedy algorithm by induction on ",e.jsx("em",{children:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Base case:"})," For ",e.jsx(s,{math:"n = 1",inline:!0}),", the algorithm correctly determines whether ",e.jsx(s,{math:"S = b_1",inline:!0})," or has no solution."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Inductive step:"})," Assume the algorithm works for sequences of length ",e.jsx(s,{math:"n - 1",inline:!0}),". Consider a superincreasing sequence ",e.jsx(s,{math:"(b_1, \\ldots, b_n)",inline:!0})," and target ",e.jsx("em",{children:"S"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Claim:"})," If a solution exists with ",e.jsx(s,{math:"b_n",inline:!0})," included, then the greedy algorithm must include ",e.jsx(s,{math:"b_n",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Proof of claim:"})," Since the sequence is superincreasing:"]}),e.jsx(s,{math:"\\sum_{i=1}^{n-1} b_i < b_n"}),e.jsxs("p",{children:["Therefore, if ",e.jsx(s,{math:"b_n",inline:!0})," is in the solution but we don't include it, we cannot reach any target ",e.jsx(s,{math:"S \\geq b_n",inline:!0})," using only ",e.jsx(s,{math:"b_1, \\ldots, b_{n-1}",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Conversely:"})," If ",e.jsx(s,{math:"S < b_n",inline:!0}),", then ",e.jsx(s,{math:"b_n",inline:!0})," cannot be in any solution (it would exceed ",e.jsx("em",{children:"S"})," by itself)."]}),e.jsxs("p",{className:"mt-2",children:["Thus the greedy choice is always correct. After deciding on ",e.jsx(s,{math:"b_n",inline:!0}),", we have a subproblem of size ",e.jsx(s,{math:"n - 1",inline:!0})," with target ",e.jsx(s,{math:"S' = S - b_n",inline:!0})," (if included) or ",e.jsx(s,{math:"S' = S",inline:!0})," (if not). By induction, the greedy algorithm solves this correctly."]}),e.jsxs("p",{className:"mt-2",children:["The algorithm makes exactly ",e.jsx("em",{children:"n"})," decisions, each in constant time, giving ",e.jsx(s,{math:"O(n)",inline:!0})," total complexity."]})]}),children:["For a superincreasing sequence, the subset sum problem can be solved in ",e.jsx(s,{math:"O(n)",inline:!0})," ","time using a greedy algorithm:",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Start with the largest element ",e.jsx(s,{math:"b_n",inline:!0})]}),e.jsxs("li",{children:["If ",e.jsx(s,{math:"b_n \\leq S",inline:!0}),", include it and set ",e.jsx(s,{math:"S := S - b_n",inline:!0})]}),e.jsxs("li",{children:["Repeat for ",e.jsx(s,{math:"b_{n-1}, b_{n-2}, \\ldots, b_1",inline:!0})]})]})]}),e.jsxs(r,{title:"Solving Easy Knapsack",children:[e.jsxs("p",{children:["Sequence: ",e.jsx(s,{math:"(2, 3, 7, 14, 30)",inline:!0}),". Find subset summing to ",e.jsx(s,{math:"S = 23",inline:!0}),"."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Solution:"})}),e.jsxs("ol",{className:"list-decimal list-inside mt-2",children:[e.jsxs("li",{children:[e.jsx(s,{math:"30 > 23",inline:!0}),", skip"]}),e.jsxs("li",{children:[e.jsx(s,{math:"14 \\leq 23",inline:!0}),", include. ",e.jsx(s,{math:"S := 23 - 14 = 9",inline:!0})]}),e.jsxs("li",{children:[e.jsx(s,{math:"7 \\leq 9",inline:!0}),", include. ",e.jsx(s,{math:"S := 9 - 7 = 2",inline:!0})]}),e.jsxs("li",{children:[e.jsx(s,{math:"3 > 2",inline:!0}),", skip"]}),e.jsxs("li",{children:[e.jsx(s,{math:"2 \\leq 2",inline:!0}),", include. ",e.jsx(s,{math:"S := 2 - 2 = 0",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:["Answer: ",e.jsx(s,{math:"\\{2, 7, 14\\}",inline:!0})," (indices 1, 3, 4)"]})]}),e.jsx("h3",{children:"Merkle-Hellman Knapsack Cryptosystem"}),e.jsxs(i,{title:"Merkle-Hellman Cryptosystem",children:[e.jsx("p",{children:e.jsx("strong",{children:"Key Generation:"})}),e.jsxs("ol",{className:"list-decimal list-inside space-y-1",children:[e.jsxs("li",{children:["Choose superincreasing sequence ",e.jsx(s,{math:"(b_1, \\ldots, b_n)",inline:!0})," (private)"]}),e.jsxs("li",{children:["Choose ",e.jsx(s,{math:"M > \\sum b_i",inline:!0})," and ",e.jsx(s,{math:"W",inline:!0})," with ",e.jsx(s,{math:"\\gcd(W, M) = 1",inline:!0})]}),e.jsxs("li",{children:["Compute public key: ",e.jsx(s,{math:"a_i = W \\cdot b_i \\bmod M",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Encryption:"})," For binary message ",e.jsx(s,{math:"(x_1, \\ldots, x_n)",inline:!0}),":"]}),e.jsx(s,{math:"S = \\sum_{i=1}^{n} x_i a_i"}),e.jsx("p",{children:e.jsx("strong",{children:"Decryption:"})}),e.jsxs("ol",{className:"list-decimal list-inside",children:[e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"S' = W^{-1} \\cdot S \\bmod M",inline:!0})]}),e.jsxs("li",{children:["Solve easy knapsack for ",e.jsx(s,{math:"(b_1, \\ldots, b_n)",inline:!0})," with target ",e.jsx(s,{math:"S'",inline:!0})]})]})]}),e.jsxs(r,{title:"Merkle-Hellman Example",children:[e.jsxs("p",{children:["Private: ",e.jsx(s,{math:"(2, 5, 9, 21)",inline:!0}),", ",e.jsx(s,{math:"M = 50",inline:!0}),", ",e.jsx(s,{math:"W = 31",inline:!0})]}),e.jsxs("p",{className:"mt-2",children:["Public key: ",e.jsx(s,{math:"a_i = 31 \\cdot b_i \\bmod 50",inline:!0})]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:e.jsx(s,{math:"a_1 = 31 \\cdot 2 = 62 \\equiv 12 \\pmod{50}",inline:!0})}),e.jsx("li",{children:e.jsx(s,{math:"a_2 = 31 \\cdot 5 = 155 \\equiv 5 \\pmod{50}",inline:!0})}),e.jsx("li",{children:e.jsx(s,{math:"a_3 = 31 \\cdot 9 = 279 \\equiv 29 \\pmod{50}",inline:!0})}),e.jsx("li",{children:e.jsx(s,{math:"a_4 = 31 \\cdot 21 = 651 \\equiv 1 \\pmod{50}",inline:!0})})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Encrypt (1, 0, 1, 1):"})," ",e.jsx(s,{math:"S = 12 + 29 + 1 = 42",inline:!0})]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Decrypt:"})}),e.jsxs("ul",{className:"list-disc list-inside",children:[e.jsx("li",{children:e.jsx(s,{math:"W^{-1} = 31^{-1} \\equiv 21 \\pmod{50}",inline:!0})}),e.jsx("li",{children:e.jsx(s,{math:"S' = 21 \\cdot 42 \\bmod 50 = 882 \\bmod 50 = 32",inline:!0})}),e.jsxs("li",{children:["Solve easy knapsack: ",e.jsx(s,{math:"32 = 21 + 9 + 2",inline:!0})," → (1, 0, 1, 1) ✓"]})]})]}),e.jsx("h3",{children:"Shamir's Attack"}),e.jsxs(n,{title:"Shamir's Attack (1984)",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"The attack exploits the structure hidden in the public key through lattice techniques. We outline the key ideas:"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 1: Lattice formulation."})," Construct the lattice ",e.jsx(s,{math:"\\Lambda",inline:!0})," generated by the rows of:"]}),e.jsx(s,{math:"\\begin{pmatrix} 1 & 0 & \\cdots & 0 & a_1 \\\\ 0 & 1 & \\cdots & 0 & a_2 \\\\ \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\ 0 & 0 & \\cdots & 1 & a_n \\\\ 0 & 0 & \\cdots & 0 & -n \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 2: Short vector existence."})," The private superincreasing sequence ",e.jsx(s,{math:"(b_1, \\ldots, b_n)",inline:!0})," satisfies ",e.jsx(s,{math:"a_i \\equiv W b_i \\pmod{M}",inline:!0}),". This implies:"]}),e.jsx(s,{math:"a_i = W b_i - k_i M \\text{ for some } k_i"}),e.jsxs("p",{children:["The vector ",e.jsx(s,{math:"(b_1, b_2, \\ldots, b_n, W)",inline:!0})," lies in a sublattice and has unusually small norm because the ",e.jsx(s,{math:"b_i",inline:!0})," form a superincreasing sequence with relatively small entries."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 3: LLL reduction."})," Apply the LLL algorithm to find a reduced basis. With high probability, the shortest vectors in the reduced basis reveal linear combinations that expose the trapdoor structure."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Step 4: Extract trapdoor."})," From short lattice vectors, recover a pair ",e.jsx(s,{math:"(W', M')",inline:!0})," such that ",e.jsx(s,{math:"a_i W'^{-1} \\bmod M'",inline:!0})," yields a superincreasing-like sequence that enables decryption."]}),e.jsxs("p",{className:"mt-2",children:["The LLL algorithm runs in polynomial time ",e.jsx(s,{math:"O(n^6 \\log^3 B)",inline:!0})," where ",e.jsx("em",{children:"B"})," bounds the entries. Since the lattice dimension is ",e.jsx(s,{math:"n + 1",inline:!0}),", the entire attack is polynomial in the key length."]})]}),children:["The Merkle-Hellman cryptosystem can be broken in polynomial time using lattice reduction. Given the public key ",e.jsx(s,{math:"(a_1, \\ldots, a_n)",inline:!0}),", one can find a different trapdoor pair ",e.jsx(s,{math:"(W', M')",inline:!0})," that allows decryption."]}),e.jsx("p",{children:"The attack uses the LLL algorithm for lattice basis reduction to find short vectors in a certain lattice constructed from the public key."}),e.jsxs(t,{type:"warning",children:[e.jsx("strong",{children:"Broken!"})," The Merkle-Hellman cryptosystem and its variants are considered insecure. More sophisticated knapsack-based systems have also been broken."]}),e.jsx("h3",{children:"Modern Lattice Cryptography"}),e.jsx("p",{children:"Despite the failure of early knapsack schemes, lattice problems remain central to post-quantum cryptography:"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Lattice-Based Problems"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Shortest Vector Problem (SVP):"})," Find shortest nonzero vector in lattice"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Closest Vector Problem (CVP):"})," Find lattice point closest to target"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Learning With Errors (LWE):"})," Solve noisy linear equations"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Ring-LWE:"})," Structured version enabling efficient crypto"]})]})]}),e.jsxs(i,{title:"NTRU (1996)",children:["A lattice-based cryptosystem using polynomial rings that has resisted attacks for decades. Operations are in ",e.jsx(s,{math:"\\mathbb{Z}[x]/(x^N - 1)",inline:!0}),":",e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Small polynomial secrets ",e.jsx("em",{children:"f"}),", ",e.jsx("em",{children:"g"})]}),e.jsxs("li",{children:["Public key: ",e.jsx(s,{math:"h = g \\cdot f^{-1} \\pmod{q}",inline:!0})]}),e.jsx("li",{children:"Security from difficulty of finding short vectors"})]})]}),e.jsxs(t,{type:"success",children:[e.jsx("strong",{children:"Post-Quantum:"})," Lattice-based cryptography (Kyber, Dilithium) was selected by NIST for post-quantum standardization. Unlike RSA/ECC, these schemes resist quantum attacks."]}),e.jsx("h3",{children:"Lessons Learned"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Cryptographic Design Principles"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Worst-case vs. average-case:"})," NP-completeness is worst-case; crypto needs average-case hardness"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Trapdoor quality:"})," The trapdoor must not leak through the public key"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Reduction tightness:"})," Security should reduce tightly to the hard problem"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Conservative design:"})," Large security margins against unknown attacks"]})]})]})]})}export{b as default};
