import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l,D as t,C as r,T as s,E as n}from"./Callout-iZusXhjX.js";import{M as i}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-DlQjnR56.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./quizMap-_5rFmvYC.js";function f(){return e.jsxs(l,{sectionId:3,children:[e.jsx("h2",{children:"Some Applications to Factoring"}),e.jsx("p",{children:"The problem of factoring large integers is central to cryptography. In this section, we explore how properties of congruences can be used for factorization, setting the stage for more sophisticated methods."}),e.jsx("h3",{children:"The Factoring Problem"}),e.jsxs(t,{title:"Factoring Problem",children:["Given a composite integer ",e.jsx("em",{children:"n"}),", find its prime factorization:",e.jsx(i,{math:"n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}"}),"For cryptographic purposes, we are particularly interested in the case where"," ",e.jsx(i,{math:"n = pq",inline:!0})," is a product of two large primes."]}),e.jsxs(r,{type:"warning",children:[e.jsx("strong",{children:"Computational Hardness:"})," No polynomial-time algorithm is known for factoring. The best known algorithms (like the General Number Field Sieve) run in subexponential time:",e.jsx(i,{math:"O\\left(\\exp\\left(c(\\log n)^{1/3}(\\log \\log n)^{2/3}\\right)\\right)"})]}),e.jsx("h3",{children:"Trial Division"}),e.jsxs(s,{title:"Trial Division Bound",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Suppose ",e.jsx("em",{children:"n"})," is composite. Then ",e.jsx(i,{math:"n = ab",inline:!0})," for some integers ",e.jsx(i,{math:"1 < a, b < n",inline:!0}),"."]}),e.jsxs("p",{children:["We cannot have both ",e.jsx(i,{math:"a > \\sqrt{n}",inline:!0})," and ",e.jsx(i,{math:"b > \\sqrt{n}",inline:!0}),", for then:"]}),e.jsx(i,{math:"n = ab > \\sqrt{n} \\cdot \\sqrt{n} = n"}),e.jsxs("p",{children:["which is a contradiction. Therefore, at least one of ",e.jsx("em",{children:"a"})," or ",e.jsx("em",{children:"b"})," satisfies ",e.jsx(i,{math:"a \\leq \\sqrt{n}",inline:!0})," or ",e.jsx(i,{math:"b \\leq \\sqrt{n}",inline:!0}),"."]}),e.jsxs("p",{children:["Without loss of generality, assume ",e.jsx(i,{math:"a \\leq \\sqrt{n}",inline:!0}),". Since ",e.jsx(i,{math:"a > 1",inline:!0}),", ",e.jsx("em",{children:"a"})," has a prime divisor ",e.jsx("em",{children:"p"}),", and we have:"]}),e.jsx(i,{math:"p \\leq a \\leq \\sqrt{n}"}),e.jsxs("p",{children:["Moreover, ",e.jsx(i,{math:"p \\mid a",inline:!0})," and ",e.jsx(i,{math:"a \\mid n",inline:!0})," imply ",e.jsx(i,{math:"p \\mid n",inline:!0}),"."]}),e.jsxs("p",{children:["Contrapositive: if no prime ",e.jsx(i,{math:"p \\leq \\sqrt{n}",inline:!0})," divides ",e.jsx("em",{children:"n"}),", then ",e.jsx("em",{children:"n"})," has no nontrivial factorization, so ",e.jsx("em",{children:"n"})," is prime."]})]}),children:["To factor ",e.jsx("em",{children:"n"})," by trial division, we only need to test primes up to"," ",e.jsx(i,{math:"\\sqrt{n}",inline:!0}),". If no prime ",e.jsx(i,{math:"p \\leq \\sqrt{n}",inline:!0})," ","divides ",e.jsx("em",{children:"n"}),", then ",e.jsx("em",{children:"n"})," is prime."]}),e.jsxs(n,{title:"Trial Division",children:[e.jsxs("p",{children:["Factor ",e.jsx(i,{math:"n = 1001",inline:!0})," by trial division."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," We test primes up to ",e.jsx(i,{math:"\\sqrt{1001} \\approx 31.6",inline:!0}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:e.jsx(i,{math:"1001 / 7 = 143",inline:!0})}),e.jsx("li",{children:e.jsx(i,{math:"143 / 11 = 13",inline:!0})})]}),e.jsxs("p",{children:["Therefore, ",e.jsx(i,{math:"1001 = 7 \\times 11 \\times 13",inline:!0}),"."]})]}),e.jsx("h3",{children:"Fermat's Factoring Method"}),e.jsxs("p",{children:["Fermat observed that if ",e.jsx(i,{math:"n = ab",inline:!0})," with ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," close to ",e.jsx(i,{math:"\\sqrt{n}",inline:!0}),", we can write:"]}),e.jsx(i,{math:"n = \\left(\\frac{a+b}{2}\\right)^2 - \\left(\\frac{a-b}{2}\\right)^2 = x^2 - y^2"}),e.jsxs(s,{title:"Fermat's Method",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," Suppose ",e.jsx(i,{math:"n = ab",inline:!0})," with ",e.jsx(i,{math:"a \\leq b",inline:!0}),". Set:"]}),e.jsx(i,{math:"x = \\frac{a + b}{2}, \\quad y = \\frac{b - a}{2}"}),e.jsxs("p",{children:["Then ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"})," are positive (since ",e.jsx(i,{math:"a, b \\geq 1",inline:!0}),") and:"]}),e.jsx(i,{math:"x^2 - y^2 = \\frac{(a+b)^2 - (b-a)^2}{4} = \\frac{4ab}{4} = ab = n"}),e.jsxs("p",{children:["So ",e.jsx(i,{math:"n = (x-y)(x+y) = ab",inline:!0})," where ",e.jsx(i,{math:"x - y = a",inline:!0})," and ",e.jsx(i,{math:"x + y = b",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Termination:"})," Since ",e.jsx(i,{math:"a \\leq \\sqrt{n} \\leq b",inline:!0}),", we have:"]}),e.jsx(i,{math:"x = \\frac{a + b}{2} \\geq \\frac{\\sqrt{n} + \\sqrt{n}}{2} = \\sqrt{n}"}),e.jsxs("p",{children:["Starting from ",e.jsx(i,{math:"\\lceil \\sqrt{n} \\rceil",inline:!0})," and incrementing, we will eventually reach the value ",e.jsx(i,{math:"x = (a+b)/2",inline:!0})," at which point ",e.jsx(i,{math:"x^2 - n = y^2",inline:!0})," is a perfect square."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Efficiency:"})," The method is fast when ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," are close to ",e.jsx(i,{math:"\\sqrt{n}",inline:!0}),", as then ",e.jsx(i,{math:"x \\approx \\sqrt{n}",inline:!0})," and few iterations are needed."]})]}),children:["To factor ",e.jsx("em",{children:"n"}),":",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Start with ",e.jsx(i,{math:"x = \\lceil \\sqrt{n} \\rceil",inline:!0})]}),e.jsxs("li",{children:["Compute ",e.jsx(i,{math:"y^2 = x^2 - n",inline:!0})]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"y^2",inline:!0})," is a perfect square, then ",e.jsx(i,{math:"n = (x-y)(x+y)",inline:!0})]}),e.jsxs("li",{children:["Otherwise, increment ",e.jsx("em",{children:"x"})," and repeat"]})]})]}),e.jsxs(n,{title:"Fermat's Method",children:[e.jsxs("p",{children:["Factor ",e.jsx(i,{math:"n = 5959",inline:!0})," using Fermat's method."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," ",e.jsx(i,{math:"\\sqrt{5959} \\approx 77.2",inline:!0}),", so start with ",e.jsx(i,{math:"x = 78",inline:!0}),":"]}),e.jsxs("div",{className:"font-mono text-sm space-y-1 mt-2",children:[e.jsx("p",{children:"x = 78: 78² - 5959 = 6084 - 5959 = 125 (not a square)"}),e.jsx("p",{children:"x = 79: 79² - 5959 = 6241 - 5959 = 282 (not a square)"}),e.jsx("p",{children:"x = 80: 80² - 5959 = 6400 - 5959 = 441 = 21² ✓"})]}),e.jsxs("p",{className:"mt-2",children:["So ",e.jsx(i,{math:"n = (80-21)(80+21) = 59 \\times 101",inline:!0}),"."]})]}),e.jsx("h3",{children:"The Difference of Squares Method"}),e.jsxs(s,{title:"Factoring via Congruence",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["From ",e.jsx(i,{math:"x^2 \\equiv y^2 \\pmod{n}",inline:!0}),", we have:"]}),e.jsx(i,{math:"n \\mid (x^2 - y^2) = (x-y)(x+y)"}),e.jsxs("p",{children:["Let ",e.jsx(i,{math:"d_1 = \\gcd(x - y, n)",inline:!0})," and ",e.jsx(i,{math:"d_2 = \\gcd(x + y, n)",inline:!0}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"n \\mid (x-y)(x+y)",inline:!0}),", the prime factors of ",e.jsx("em",{children:"n"})," must divide the product ",e.jsx(i,{math:"(x-y)(x+y)",inline:!0}),"."]}),e.jsx("p",{children:e.jsx("strong",{children:"Why the factors are nontrivial:"})}),e.jsxs("p",{children:["If ",e.jsx(i,{math:"d_1 = n",inline:!0}),", then ",e.jsx(i,{math:"n \\mid (x - y)",inline:!0}),", meaning ",e.jsx(i,{math:"x \\equiv y \\pmod{n}",inline:!0}),", which contradicts our assumption."]}),e.jsxs("p",{children:["If ",e.jsx(i,{math:"d_1 = 1",inline:!0}),", then ",e.jsx(i,{math:"\\gcd(x - y, n) = 1",inline:!0}),", so all prime factors of ",e.jsx("em",{children:"n"})," must divide ",e.jsx(i,{math:"(x + y)",inline:!0}),". This means ",e.jsx(i,{math:"n \\mid (x + y)",inline:!0}),", giving ",e.jsx(i,{math:"x \\equiv -y \\pmod{n}",inline:!0}),", again contradicting our assumption."]}),e.jsxs("p",{children:["Therefore ",e.jsx(i,{math:"1 < d_1 < n",inline:!0}),", making ",e.jsx(i,{math:"d_1",inline:!0})," a nontrivial factor of ",e.jsx("em",{children:"n"}),"."]}),e.jsxs("p",{children:["The same argument applies to ",e.jsx(i,{math:"d_2",inline:!0}),", and we have ",e.jsx(i,{math:"n = d_1 \\cdot (n/d_1)",inline:!0})," where both factors can be computed using the GCD."]})]}),children:["Suppose we find integers ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"})," such that:",e.jsx(i,{math:"x^2 \\equiv y^2 \\pmod{n} \\quad \\text{but} \\quad x \\not\\equiv \\pm y \\pmod{n}"}),"Then ",e.jsx(i,{math:"\\gcd(x - y, n)",inline:!0})," and ",e.jsx(i,{math:"\\gcd(x + y, n)",inline:!0})," ","give nontrivial factors of ",e.jsx("em",{children:"n"}),"."]}),e.jsx("p",{children:"This observation is the basis of many modern factoring algorithms, including the Quadratic Sieve and Number Field Sieve."}),e.jsxs(n,{title:"Difference of Squares",children:[e.jsxs("p",{children:["Factor ",e.jsx(i,{math:"n = 77",inline:!0})," given that ",e.jsx(i,{math:"10^2 \\equiv 23^2 \\pmod{77}",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," Since ",e.jsx(i,{math:"10 \\not\\equiv \\pm 23 \\pmod{77}",inline:!0}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:[e.jsx(i,{math:"\\gcd(23 - 10, 77) = \\gcd(13, 77) = 1",inline:!0})," (no luck)"]}),e.jsxs("li",{children:[e.jsx(i,{math:"\\gcd(23 + 10, 77) = \\gcd(33, 77) = 11",inline:!0})," ✓"]})]}),e.jsxs("p",{children:["So ",e.jsx(i,{math:"77 = 11 \\times 7",inline:!0}),"."]})]}),e.jsx("h3",{children:"Pollard's p - 1 Method"}),e.jsxs(t,{title:"Smooth Numbers",children:["An integer is ",e.jsx("strong",{children:"B-smooth"})," if all its prime factors are at most ",e.jsx("em",{children:"B"}),". For example, ",e.jsx(i,{math:"60 = 2^2 \\cdot 3 \\cdot 5",inline:!0})," is 5-smooth."]}),e.jsxs(s,{title:"Pollard's p - 1 Method",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Why it works:"})," Suppose ",e.jsx("em",{children:"p"})," is a prime factor of ",e.jsx("em",{children:"n"})," and ",e.jsx(i,{math:"p - 1",inline:!0})," is ",e.jsx("em",{children:"B"}),"-smooth."]}),e.jsxs("p",{children:["By definition of ",e.jsx("em",{children:"B"}),"-smooth, every prime power ",e.jsx(i,{math:"q^k",inline:!0})," dividing ",e.jsx(i,{math:"p - 1",inline:!0})," satisfies ",e.jsx(i,{math:"q^k \\leq B",inline:!0}),"."]}),e.jsxs("p",{children:["The number ",e.jsx(i,{math:"M = \\text{lcm}(1, 2, \\ldots, B)",inline:!0})," is divisible by every integer up to ",e.jsx("em",{children:"B"}),", so in particular:"]}),e.jsx(i,{math:"(p - 1) \\mid M"}),e.jsxs("p",{children:["By Fermat's Little Theorem, if ",e.jsx(i,{math:"\\gcd(a, p) = 1",inline:!0}),":"]}),e.jsx(i,{math:"a^{p-1} \\equiv 1 \\pmod{p}"}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"(p-1) \\mid M",inline:!0}),", we have ",e.jsx(i,{math:"M = k(p-1)",inline:!0})," for some integer ",e.jsx("em",{children:"k"}),", so:"]}),e.jsx(i,{math:"a^M = (a^{p-1})^k \\equiv 1^k = 1 \\pmod{p}"}),e.jsxs("p",{children:["Therefore ",e.jsx(i,{math:"p \\mid (a^M - 1)",inline:!0}),", which means ",e.jsx(i,{math:"p \\mid (b - 1)",inline:!0})," where ",e.jsx(i,{math:"b = a^M \\bmod n",inline:!0}),"."]}),e.jsxs("p",{children:["Computing ",e.jsx(i,{math:"d = \\gcd(b - 1, n)",inline:!0}),", we get ",e.jsx(i,{math:"p \\mid d",inline:!0}),". If we're lucky that ",e.jsx(i,{math:"d \\neq n",inline:!0})," (i.e., not all prime factors of ",e.jsx("em",{children:"n"})," divide ",e.jsx(i,{math:"b - 1",inline:!0}),"), then ",e.jsx("em",{children:"d"})," is a nontrivial factor."]})]}),children:["If ",e.jsx("em",{children:"n"})," has a prime factor ",e.jsx("em",{children:"p"})," such that ",e.jsx(i,{math:"p - 1",inline:!0})," is"," ",e.jsx("em",{children:"B"}),"-smooth, then we can find ",e.jsx("em",{children:"p"})," efficiently:",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Compute ",e.jsx(i,{math:"M = \\text{lcm}(1, 2, \\ldots, B) = \\prod_{q \\leq B} q^{\\lfloor \\log_q B \\rfloor}",inline:!0})]}),e.jsxs("li",{children:["For a random ",e.jsx("em",{children:"a"}),", compute ",e.jsx(i,{math:"b = a^M \\bmod n",inline:!0})]}),e.jsxs("li",{children:["Compute ",e.jsx(i,{math:"d = \\gcd(b - 1, n)",inline:!0})]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"1 < d < n",inline:!0}),", then ",e.jsx("em",{children:"d"})," is a factor"]})]})]}),e.jsxs("p",{children:["The method works because if ",e.jsx(i,{math:"(p-1) \\mid M",inline:!0}),", then by Fermat's Little Theorem, ",e.jsx(i,{math:"a^M \\equiv 1 \\pmod{p}",inline:!0}),", so ",e.jsx(i,{math:"p \\mid (b - 1)",inline:!0}),"."]}),e.jsxs(n,{title:"Pollard's p - 1 Method",children:[e.jsxs("p",{children:["Factor ",e.jsx(i,{math:"n = 540143",inline:!0})," using ",e.jsx(i,{math:"B = 13",inline:!0}),"."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Solution:"})}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:e.jsx(i,{math:"M = 2^3 \\cdot 3^2 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 = 360360",inline:!0})}),e.jsxs("li",{children:["Let ",e.jsx(i,{math:"a = 2",inline:!0}),", compute ",e.jsx(i,{math:"2^{360360} \\bmod 540143 = 53047",inline:!0})]}),e.jsx("li",{children:e.jsx(i,{math:"\\gcd(53046, 540143) = 421",inline:!0})})]}),e.jsxs("p",{children:["We found that ",e.jsx(i,{math:"540143 = 421 \\times 1283",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["This worked because ",e.jsx(i,{math:"420 = 2^2 \\cdot 3 \\cdot 5 \\cdot 7",inline:!0})," is 7-smooth."]})]}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Key Insight:"})," Pollard's p - 1 method is fast when ",e.jsx(i,{math:"p - 1",inline:!0})," ","has only small prime factors. This is why cryptographic primes are often chosen to be"," ",e.jsx("strong",{children:"safe primes"}),": ",e.jsx(i,{math:"p = 2q + 1",inline:!0})," where ",e.jsx("em",{children:"q"})," is also prime."]}),e.jsx("h3",{children:"Time Complexity Comparison"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Factoring Methods"}),e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Method"}),e.jsx("th",{className:"text-left py-2",children:"Complexity"}),e.jsx("th",{className:"text-left py-2",children:"Best for"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Trial Division"}),e.jsx("td",{className:"py-2",children:e.jsx(i,{math:"O(\\sqrt{n})",inline:!0})}),e.jsx("td",{className:"py-2",children:"Small factors"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Fermat's Method"}),e.jsx("td",{className:"py-2",children:e.jsx(i,{math:"O(n^{1/4})",inline:!0})}),e.jsx("td",{className:"py-2",children:"Factors near √n"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Pollard's p - 1"}),e.jsx("td",{className:"py-2",children:"Depends on smoothness"}),e.jsx("td",{className:"py-2",children:"Smooth p - 1"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"Pollard's Rho"}),e.jsx("td",{className:"py-2",children:e.jsx(i,{math:"O(n^{1/4})",inline:!0})}),e.jsx("td",{className:"py-2",children:"General purpose"})]})]})]})]})]})}export{f as default};
