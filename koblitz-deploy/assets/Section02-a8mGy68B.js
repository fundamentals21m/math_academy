import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as s,E as t,T as n,C as r}from"./Callout-_WjMxNQI.js";import{M as i}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-CrtEkn2Z.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-_5rFmvYC.js";function p(){return e.jsxs(h,{sectionId:2,children:[e.jsx("h2",{children:"Congruences"}),e.jsx("p",{children:"Modular arithmetic is the foundation of modern cryptography. In this section, we develop the theory of congruences, including Fermat's Little Theorem, Euler's theorem, and the Chinese Remainder Theorem."}),e.jsx("h3",{children:"Basic Definitions"}),e.jsxs(s,{title:"Congruence",children:["Let ",e.jsx("em",{children:"m"})," be a positive integer. We say that ",e.jsx("em",{children:"a"})," is ",e.jsx("strong",{children:"congruent"})," to"," ",e.jsx("em",{children:"b"})," modulo ",e.jsx("em",{children:"m"}),", written ",e.jsx(i,{math:"a \\equiv b \\pmod{m}",inline:!0}),", if"," ",e.jsx(i,{math:"m \\mid (a - b)",inline:!0}),", i.e., if ",e.jsx("em",{children:"m"})," divides the difference"," ",e.jsx("em",{children:"a - b"}),"."]}),e.jsxs(s,{title:"Residue Class",children:["The ",e.jsx("strong",{children:"residue class"})," of an integer ",e.jsx("em",{children:"a"})," modulo ",e.jsx("em",{children:"m"})," is the set of all integers congruent to ",e.jsx("em",{children:"a"})," modulo ",e.jsx("em",{children:"m"}),":",e.jsx(i,{math:"\\bar{a} = \\{a + km : k \\in \\mathbb{Z}\\}"}),"The set of residue classes modulo ",e.jsx("em",{children:"m"})," is denoted ",e.jsx(i,{math:"\\mathbb{Z}/m\\mathbb{Z}",inline:!0}),"."]}),e.jsx("h3",{children:"Properties of Congruences"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Basic Properties"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx(i,{math:"a \\equiv a \\pmod{m}",inline:!0})," (reflexivity)"]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"a \\equiv b \\pmod{m}",inline:!0}),", then ",e.jsx(i,{math:"b \\equiv a \\pmod{m}",inline:!0})," (symmetry)"]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"a \\equiv b \\pmod{m}",inline:!0})," and ",e.jsx(i,{math:"b \\equiv c \\pmod{m}",inline:!0}),", then ",e.jsx(i,{math:"a \\equiv c \\pmod{m}",inline:!0})," (transitivity)"]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"a \\equiv b \\pmod{m}",inline:!0})," and ",e.jsx(i,{math:"c \\equiv d \\pmod{m}",inline:!0}),", then ",e.jsx(i,{math:"a + c \\equiv b + d \\pmod{m}",inline:!0})]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"a \\equiv b \\pmod{m}",inline:!0})," and ",e.jsx(i,{math:"c \\equiv d \\pmod{m}",inline:!0}),", then ",e.jsx(i,{math:"ac \\equiv bd \\pmod{m}",inline:!0})]})]})]}),e.jsx("h3",{children:"Euler's Phi Function"}),e.jsxs(s,{title:"Euler's Phi Function",children:["For a positive integer ",e.jsx("em",{children:"n"}),", the ",e.jsx("strong",{children:"Euler phi function"})," ",e.jsx(i,{math:"\\varphi(n)",inline:!0})," counts the number of integers between 1 and ",e.jsx("em",{children:"n"})," ","that are relatively prime to ",e.jsx("em",{children:"n"}),":",e.jsx(i,{math:"\\varphi(n) = |\\{k : 1 \\leq k \\leq n, \\gcd(k, n) = 1\\}|"})]}),e.jsx(t,{title:"Computing φ(n)",children:e.jsxs("ul",{className:"list-disc list-inside space-y-1",children:[e.jsx("li",{children:e.jsx(i,{math:"\\varphi(1) = 1",inline:!0})}),e.jsxs("li",{children:[e.jsx(i,{math:"\\varphi(p) = p - 1",inline:!0})," for prime ",e.jsx("em",{children:"p"})]}),e.jsxs("li",{children:[e.jsx(i,{math:"\\varphi(p^k) = p^{k-1}(p - 1)",inline:!0})," for prime power"]}),e.jsxs("li",{children:[e.jsx(i,{math:"\\varphi(12) = \\varphi(4)\\varphi(3) = 2 \\cdot 2 = 4",inline:!0})," (the numbers 1, 5, 7, 11)"]})]})}),e.jsxs(n,{title:"Euler's Phi Formula",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We prove this in two steps."}),e.jsxs("p",{children:[e.jsx("strong",{children:"Step 1: Prime powers."})," For ",e.jsx(i,{math:"n = p^k",inline:!0}),", an integer ",e.jsx(i,{math:"1 \\leq m \\leq p^k",inline:!0})," is not coprime to ",e.jsx(i,{math:"p^k",inline:!0})," if and only if ",e.jsx(i,{math:"p \\mid m",inline:!0}),"."]}),e.jsxs("p",{children:["The multiples of ",e.jsx("em",{children:"p"})," in ",e.jsx(i,{math:"\\{1, 2, \\ldots, p^k\\}",inline:!0})," are ",e.jsx(i,{math:"p, 2p, 3p, \\ldots, p^{k-1} \\cdot p",inline:!0}),", which number ",e.jsx(i,{math:"p^{k-1}",inline:!0}),"."]}),e.jsx("p",{children:"Therefore:"}),e.jsx(i,{math:"\\varphi(p^k) = p^k - p^{k-1} = p^{k-1}(p - 1) = p^k \\left(1 - \\frac{1}{p}\\right)"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Step 2: Multiplicativity."})," If ",e.jsx(i,{math:"\\gcd(m, n) = 1",inline:!0}),", then ",e.jsx(i,{math:"\\varphi(mn) = \\varphi(m)\\varphi(n)",inline:!0}),"."]}),e.jsxs("p",{children:["By the Chinese Remainder Theorem, the map ",e.jsx(i,{math:"\\mathbb{Z}/mn\\mathbb{Z} \\to \\mathbb{Z}/m\\mathbb{Z} \\times \\mathbb{Z}/n\\mathbb{Z}",inline:!0})," given by ",e.jsx(i,{math:"x \\mapsto (x \\bmod m, x \\bmod n)",inline:!0})," is a ring isomorphism."]}),e.jsxs("p",{children:["An element ",e.jsx("em",{children:"x"})," is a unit in ",e.jsx(i,{math:"\\mathbb{Z}/mn\\mathbb{Z}",inline:!0})," if and only if ",e.jsx(i,{math:"(x \\bmod m, x \\bmod n)",inline:!0})," is a unit, which happens if and only if both components are units. Thus:"]}),e.jsx(i,{math:"\\varphi(mn) = \\varphi(m) \\cdot \\varphi(n)"}),e.jsxs("p",{children:["Combining these results for ",e.jsx(i,{math:"n = p_1^{a_1} \\cdots p_k^{a_k}",inline:!0}),":"]}),e.jsx(i,{math:"\\varphi(n) = \\prod_{i=1}^{k} \\varphi(p_i^{a_i}) = \\prod_{i=1}^{k} p_i^{a_i}\\left(1 - \\frac{1}{p_i}\\right) = n \\prod_{p \\mid n}\\left(1 - \\frac{1}{p}\\right)"})]}),children:["For ",e.jsx(i,{math:"n = p_1^{a_1} p_2^{a_2} \\cdots p_k^{a_k}",inline:!0}),":",e.jsx(i,{math:"\\varphi(n) = n \\prod_{p \\mid n} \\left(1 - \\frac{1}{p}\\right) = n \\cdot \\frac{p_1 - 1}{p_1} \\cdot \\frac{p_2 - 1}{p_2} \\cdots \\frac{p_k - 1}{p_k}"})]}),e.jsx("h3",{children:"Fermat's Little Theorem and Euler's Theorem"}),e.jsxs(n,{title:"Fermat's Little Theorem",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Consider the ",e.jsx(i,{math:"p - 1",inline:!0})," nonzero residue classes modulo ",e.jsx("em",{children:"p"}),":"]}),e.jsx(i,{math:"1, 2, 3, \\ldots, p-1"}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"\\gcd(a, p) = 1",inline:!0}),", multiplication by ",e.jsx("em",{children:"a"})," permutes these residue classes. That is, the products:"]}),e.jsx(i,{math:"a \\cdot 1, a \\cdot 2, a \\cdot 3, \\ldots, a \\cdot (p-1)"}),e.jsxs("p",{children:["are just a rearrangement of ",e.jsx(i,{math:"1, 2, 3, \\ldots, p-1",inline:!0})," modulo ",e.jsx("em",{children:"p"}),"."]}),e.jsx("p",{children:"Taking the product of all elements in each list:"}),e.jsx(i,{math:"(a \\cdot 1)(a \\cdot 2)(a \\cdot 3) \\cdots (a \\cdot (p-1)) \\equiv 1 \\cdot 2 \\cdot 3 \\cdots (p-1) \\pmod{p}"}),e.jsx(i,{math:"a^{p-1} \\cdot (p-1)! \\equiv (p-1)! \\pmod{p}"}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"\\gcd((p-1)!, p) = 1",inline:!0})," (none of the factors ",e.jsx(i,{math:"1, 2, \\ldots, p-1",inline:!0})," are divisible by ",e.jsx("em",{children:"p"}),"), we can cancel ",e.jsx(i,{math:"(p-1)!",inline:!0})," to obtain:"]}),e.jsx(i,{math:"a^{p-1} \\equiv 1 \\pmod{p}"}),e.jsxs("p",{children:["Multiplying both sides by ",e.jsx("em",{children:"a"})," gives the equivalent form ",e.jsx(i,{math:"a^p \\equiv a \\pmod{p}",inline:!0}),", which holds even when ",e.jsx(i,{math:"p \\mid a",inline:!0})," (both sides are 0)."]})]}),children:["If ",e.jsx("em",{children:"p"})," is prime and ",e.jsx(i,{math:"\\gcd(a, p) = 1",inline:!0}),", then:",e.jsx(i,{math:"a^{p-1} \\equiv 1 \\pmod{p}"}),"Equivalently, for any integer ",e.jsx("em",{children:"a"}),":",e.jsx(i,{math:"a^p \\equiv a \\pmod{p}"})]}),e.jsxs(n,{title:"Euler's Theorem",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{math:"r_1, r_2, \\ldots, r_{\\varphi(n)}",inline:!0})," be a reduced residue system modulo ",e.jsx("em",{children:"n"}),", i.e., representatives of all residue classes coprime to ",e.jsx("em",{children:"n"}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"\\gcd(a, n) = 1",inline:!0}),", multiplication by ",e.jsx("em",{children:"a"})," permutes this set. That is:"]}),e.jsx(i,{math:"ar_1, ar_2, \\ldots, ar_{\\varphi(n)}"}),e.jsxs("p",{children:["is a rearrangement of ",e.jsx(i,{math:"r_1, r_2, \\ldots, r_{\\varphi(n)}",inline:!0})," modulo ",e.jsx("em",{children:"n"}),"."]}),e.jsx("p",{children:"This is because:"}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(i,{math:"\\gcd(ar_i, n) = 1",inline:!0})," since ",e.jsx(i,{math:"\\gcd(a, n) = \\gcd(r_i, n) = 1",inline:!0})]}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"ar_i \\equiv ar_j \\pmod{n}",inline:!0}),", then ",e.jsx(i,{math:"r_i \\equiv r_j \\pmod{n}",inline:!0})," (cancellation works since ",e.jsx(i,{math:"\\gcd(a,n)=1",inline:!0}),")"]})]}),e.jsx("p",{children:"Taking the product:"}),e.jsx(i,{math:"(ar_1)(ar_2) \\cdots (ar_{\\varphi(n)}) \\equiv r_1 r_2 \\cdots r_{\\varphi(n)} \\pmod{n}"}),e.jsx(i,{math:"a^{\\varphi(n)} \\cdot \\prod_{i=1}^{\\varphi(n)} r_i \\equiv \\prod_{i=1}^{\\varphi(n)} r_i \\pmod{n}"}),e.jsxs("p",{children:["Since each ",e.jsx(i,{math:"r_i",inline:!0})," is coprime to ",e.jsx("em",{children:"n"}),", so is their product. Canceling gives:"]}),e.jsx(i,{math:"a^{\\varphi(n)} \\equiv 1 \\pmod{n}"})]}),children:["If ",e.jsx(i,{math:"\\gcd(a, n) = 1",inline:!0}),", then:",e.jsx(i,{math:"a^{\\varphi(n)} \\equiv 1 \\pmod{n}"}),"This generalizes Fermat's Little Theorem (since ",e.jsx(i,{math:"\\varphi(p) = p - 1",inline:!0}),")."]}),e.jsxs(t,{title:"Computing Large Powers",children:[e.jsxs("p",{children:["Find the last digit of ",e.jsx(i,{math:"7^{222}",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," We need ",e.jsx(i,{math:"7^{222} \\pmod{10}",inline:!0}),". Since ",e.jsx(i,{math:"\\varphi(10) = 4",inline:!0})," and ",e.jsx(i,{math:"\\gcd(7, 10) = 1",inline:!0}),":"]}),e.jsx(i,{math:"7^4 \\equiv 1 \\pmod{10}"}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"222 = 4 \\cdot 55 + 2",inline:!0}),":"]}),e.jsx(i,{math:"7^{222} = (7^4)^{55} \\cdot 7^2 \\equiv 1^{55} \\cdot 49 \\equiv 9 \\pmod{10}"})]}),e.jsx("h3",{children:"The Chinese Remainder Theorem"}),e.jsxs(n,{title:"Chinese Remainder Theorem",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Existence:"})," Let ",e.jsx(i,{math:"M = m_1 m_2 \\cdots m_r",inline:!0})," and ",e.jsx(i,{math:"M_i = M / m_i",inline:!0})," for each ",e.jsx("em",{children:"i"}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"\\gcd(M_i, m_i) = 1",inline:!0})," (as ",e.jsx(i,{math:"M_i",inline:!0})," is a product of moduli coprime to ",e.jsx(i,{math:"m_i",inline:!0}),"), there exists ",e.jsx(i,{math:"N_i",inline:!0})," such that:"]}),e.jsx(i,{math:"M_i N_i \\equiv 1 \\pmod{m_i}"}),e.jsx("p",{children:"Define:"}),e.jsx(i,{math:"x = \\sum_{i=1}^{r} a_i M_i N_i"}),e.jsxs("p",{children:["For each ",e.jsx("em",{children:"j"}),", we have ",e.jsx(i,{math:"M_i \\equiv 0 \\pmod{m_j}",inline:!0})," when ",e.jsx(i,{math:"i \\neq j",inline:!0})," (since ",e.jsx(i,{math:"m_j \\mid M_i",inline:!0}),"). Thus:"]}),e.jsx(i,{math:"x \\equiv a_j M_j N_j \\equiv a_j \\cdot 1 = a_j \\pmod{m_j}"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Uniqueness:"})," Suppose ",e.jsx(i,{math:"x",inline:!0})," and ",e.jsx(i,{math:"x'",inline:!0})," both satisfy all congruences. Then:"]}),e.jsx(i,{math:"x \\equiv x' \\pmod{m_i} \\quad \\text{for all } i"}),e.jsxs("p",{children:["This means ",e.jsx(i,{math:"m_i \\mid (x - x')",inline:!0})," for all ",e.jsx("em",{children:"i"}),". Since the ",e.jsx(i,{math:"m_i",inline:!0})," are pairwise coprime:"]}),e.jsx(i,{math:"M = m_1 m_2 \\cdots m_r \\mid (x - x')"}),e.jsxs("p",{children:["Therefore ",e.jsx(i,{math:"x \\equiv x' \\pmod{M}",inline:!0}),", proving uniqueness modulo ",e.jsx("em",{children:"M"}),"."]})]}),children:["Let ",e.jsx(i,{math:"m_1, m_2, \\ldots, m_r",inline:!0})," be pairwise relatively prime positive integers. Then the system of congruences:",e.jsx(i,{math:"x \\equiv a_1 \\pmod{m_1}, \\quad x \\equiv a_2 \\pmod{m_2}, \\quad \\ldots, \\quad x \\equiv a_r \\pmod{m_r}"}),"has a unique solution modulo ",e.jsx(i,{math:"M = m_1 m_2 \\cdots m_r",inline:!0}),"."]}),e.jsxs(t,{title:"Solving a System of Congruences",children:[e.jsxs("p",{children:["Find ",e.jsx("em",{children:"x"})," such that ",e.jsx(i,{math:"x \\equiv 2 \\pmod{3}",inline:!0}),","," ",e.jsx(i,{math:"x \\equiv 3 \\pmod{5}",inline:!0}),", ",e.jsx(i,{math:"x \\equiv 2 \\pmod{7}",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," Let ",e.jsx(i,{math:"M = 3 \\cdot 5 \\cdot 7 = 105",inline:!0}),"."]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(i,{math:"M_1 = 35",inline:!0}),", need ",e.jsx(i,{math:"35N_1 \\equiv 1 \\pmod{3}",inline:!0}),", so ",e.jsx(i,{math:"N_1 = 2",inline:!0})]}),e.jsxs("li",{children:[e.jsx(i,{math:"M_2 = 21",inline:!0}),", need ",e.jsx(i,{math:"21N_2 \\equiv 1 \\pmod{5}",inline:!0}),", so ",e.jsx(i,{math:"N_2 = 1",inline:!0})]}),e.jsxs("li",{children:[e.jsx(i,{math:"M_3 = 15",inline:!0}),", need ",e.jsx(i,{math:"15N_3 \\equiv 1 \\pmod{7}",inline:!0}),", so ",e.jsx(i,{math:"N_3 = 1",inline:!0})]})]}),e.jsx(i,{math:"x = 2 \\cdot 35 \\cdot 2 + 3 \\cdot 21 \\cdot 1 + 2 \\cdot 15 \\cdot 1 = 140 + 63 + 30 = 233 \\equiv 23 \\pmod{105}"})]}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Cryptographic Application:"})," The Chinese Remainder Theorem is used in RSA to speed up decryption by a factor of 4, and forms the basis of secret sharing schemes."]}),e.jsx("h3",{children:"Modular Inverses"}),e.jsxs(s,{title:"Modular Inverse",children:["The ",e.jsx("strong",{children:"modular inverse"})," of ",e.jsx("em",{children:"a"})," modulo ",e.jsx("em",{children:"m"})," is an integer ",e.jsx("em",{children:"b"})," such that:",e.jsx(i,{math:"ab \\equiv 1 \\pmod{m}"}),"It exists if and only if ",e.jsx(i,{math:"\\gcd(a, m) = 1",inline:!0}),", and can be computed using the extended Euclidean algorithm."]}),e.jsxs(n,{title:"Existence of Inverses",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Necessity:"})," Suppose ",e.jsx("em",{children:"b"})," is an inverse of ",e.jsx("em",{children:"a"})," modulo ",e.jsx("em",{children:"m"}),", so ",e.jsx(i,{math:"ab \\equiv 1 \\pmod{m}",inline:!0}),"."]}),e.jsxs("p",{children:["Then ",e.jsx(i,{math:"ab = 1 + km",inline:!0})," for some integer ",e.jsx("em",{children:"k"}),", which gives ",e.jsx(i,{math:"ab - km = 1",inline:!0}),"."]}),e.jsxs("p",{children:["If ",e.jsx(i,{math:"d = \\gcd(a, m)",inline:!0}),", then ",e.jsx(i,{math:"d \\mid a",inline:!0})," and ",e.jsx(i,{math:"d \\mid m",inline:!0}),", so ",e.jsx(i,{math:"d \\mid (ab - km) = 1",inline:!0}),". Thus ",e.jsx(i,{math:"d = 1",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Sufficiency:"})," If ",e.jsx(i,{math:"\\gcd(a, m) = 1",inline:!0}),", then by Bezout's identity there exist integers ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"})," such that:"]}),e.jsx(i,{math:"ax + my = 1"}),e.jsxs("p",{children:["Reducing modulo ",e.jsx("em",{children:"m"}),": ",e.jsx(i,{math:"ax \\equiv 1 \\pmod{m}",inline:!0}),". Thus ",e.jsx(i,{math:"b = x",inline:!0})," is an inverse of ",e.jsx("em",{children:"a"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Uniqueness:"})," Suppose ",e.jsx(i,{math:"ab_1 \\equiv ab_2 \\equiv 1 \\pmod{m}",inline:!0}),". Then ",e.jsx(i,{math:"a(b_1 - b_2) \\equiv 0 \\pmod{m}",inline:!0}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"\\gcd(a, m) = 1",inline:!0}),", we can cancel ",e.jsx("em",{children:"a"})," to get ",e.jsx(i,{math:"b_1 \\equiv b_2 \\pmod{m}",inline:!0}),"."]})]}),children:["The integer ",e.jsx("em",{children:"a"})," has a multiplicative inverse modulo ",e.jsx("em",{children:"m"})," if and only if"," ",e.jsx(i,{math:"\\gcd(a, m) = 1",inline:!0}),". In this case, the inverse is unique modulo ",e.jsx("em",{children:"m"}),"."]}),e.jsxs(t,{title:"Computing a Modular Inverse",children:[e.jsx("p",{children:"Find the inverse of 7 modulo 26."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," Using the extended Euclidean algorithm:"]}),e.jsxs("div",{className:"font-mono text-sm space-y-1 mt-2",children:[e.jsx("p",{children:"26 = 7 × 3 + 5"}),e.jsx("p",{children:"7 = 5 × 1 + 2"}),e.jsx("p",{children:"5 = 2 × 2 + 1"})]}),e.jsxs("p",{className:"mt-2",children:["Working backwards: ",e.jsx(i,{math:"1 = 5 - 2 \\cdot 2 = 5 - 2(7 - 5) = 3 \\cdot 5 - 2 \\cdot 7 = 3(26 - 3 \\cdot 7) - 2 \\cdot 7 = 3 \\cdot 26 - 11 \\cdot 7",inline:!0})]}),e.jsxs("p",{children:["Thus ",e.jsx(i,{math:"7^{-1} \\equiv -11 \\equiv 15 \\pmod{26}",inline:!0}),"."]})]}),e.jsx("h3",{children:"Time Complexity"}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Efficiency:"})," Computing ",e.jsx(i,{math:"a^n \\pmod{m}",inline:!0})," using repeated squaring requires only ",e.jsx(i,{math:"O(\\log n)",inline:!0})," multiplications, each taking"," ",e.jsx(i,{math:"O((\\log m)^2)",inline:!0})," bit operations. Total: ",e.jsx(i,{math:"O((\\log n)(\\log m)^2)",inline:!0}),"."]})]})}export{p as default};
