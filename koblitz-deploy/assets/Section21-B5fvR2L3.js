import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as n,T as i,D as r,E as l,C as t}from"./Callout-_WjMxNQI.js";import{M as s}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-CrtEkn2Z.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-_5rFmvYC.js";function j(){return e.jsxs(n,{sectionId:21,children:[e.jsx("h2",{children:"Elliptic Curve Factorization"}),e.jsx("p",{children:"Lenstra's elliptic curve factorization method (ECM) is a powerful algorithm for finding small to medium-sized factors of large numbers. Unlike the quadratic sieve or NFS, ECM's running time depends on the size of the factor, not the number being factored."}),e.jsx("h3",{children:"The Basic Idea"}),e.jsxs("p",{children:["ECM generalizes Pollard's ",e.jsx(s,{math:"p-1",inline:!0})," method. Recall that"," ",e.jsx(s,{math:"p-1",inline:!0})," works when ",e.jsx(s,{math:"p-1",inline:!0})," is smooth. ECM uses elliptic curves where the group order ",e.jsx(s,{math:"\\#E(\\mathbb{F}_p)",inline:!0})," ","varies, giving many chances to find a smooth order."]}),e.jsxs(i,{title:"Key Observation",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We establish why varying elliptic curves gives ECM its power."}),e.jsxs("p",{children:[e.jsx("strong",{children:"Hasse's bound:"})," For any elliptic curve ",e.jsx("em",{children:"E"})," over ",e.jsx(s,{math:"\\mathbb{F}_p",inline:!0}),", the group order ",e.jsx(s,{math:"\\#E(\\mathbb{F}_p) = p + 1 - t",inline:!0})," where ",e.jsx(s,{math:"|t| \\leq 2\\sqrt{p}",inline:!0}),". The trace ",e.jsx("em",{children:"t"})," depends on the curve."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Distribution of orders:"})," By the Sato-Tate theorem (proven by Taylor et al., 2008), as we vary over elliptic curves mod ",e.jsx("em",{children:"p"}),", the normalized trace ",e.jsx(s,{math:"t/(2\\sqrt{p})",inline:!0})," is distributed according to a semicircular distribution on ",e.jsx(s,{math:"[-1, 1]",inline:!0}),"."]}),e.jsxs("p",{children:["More precisely, the number of isomorphism classes of elliptic curves over ",e.jsx(s,{math:"\\mathbb{F}_p",inline:!0})," with order ",e.jsx(s,{math:"m = p + 1 - t",inline:!0})," is given by the Kronecker class number ",e.jsx(s,{math:"H(t^2 - 4p)",inline:!0})," (for ",e.jsx(s,{math:"|t| < 2\\sqrt{p}",inline:!0}),")."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Smoothness probability:"})," If ",e.jsx(s,{math:"m = \\#E(\\mathbb{F}_p)",inline:!0})," happens to be ",e.jsx("em",{children:"B"}),"-smooth, the ECM computation of ",e.jsx(s,{math:"M \\cdot P",inline:!0})," (where ",e.jsx(s,{math:"M = \\text{lcm}(1,2,\\ldots,B)",inline:!0}),") will yield the identity mod ",e.jsx("em",{children:"p"})," but not necessarily mod ",e.jsx("em",{children:"n"}),", revealing ",e.jsx("em",{children:"p"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Key advantage:"})," Unlike Pollard's ",e.jsx(s,{math:"p-1",inline:!0})," method (which is stuck with ",e.jsx(s,{math:"p-1",inline:!0}),"), ECM can try ",e.jsx(s,{math:"p + 1 - t",inline:!0})," for various ",e.jsx("em",{children:"t"})," in the Hasse interval. Since there are ",e.jsx(s,{math:"\\sim 4\\sqrt{p}",inline:!0})," possible orders, if any one is smooth, ECM succeeds. The probability that at least one of many random integers near ",e.jsx("em",{children:"p"})," is smooth is much higher than for a single fixed value."]})]}),children:["For an elliptic curve ",e.jsx("em",{children:"E"})," and prime factor ",e.jsx("em",{children:"p"})," of ",e.jsx("em",{children:"n"}),":",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(s,{math:"\\#E(\\mathbb{F}_p) \\in [p + 1 - 2\\sqrt{p}, p + 1 + 2\\sqrt{p}]",inline:!0})}),e.jsx("li",{children:"Different curves give different orders in this range"}),e.jsx("li",{children:"If we're unlucky with one curve, try another!"})]})]}),e.jsx("h3",{children:"Lenstra's ECM Algorithm"}),e.jsxs(r,{title:"ECM Algorithm",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Input:"})," Composite ",e.jsx("em",{children:"n"}),", smoothness bound ",e.jsx("em",{children:"B"})]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Choose random curve ",e.jsx("em",{children:"E"})," and point ",e.jsx("em",{children:"P"})," (mod ",e.jsx("em",{children:"n"}),")"]}),e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"M = \\text{lcm}(1, 2, \\ldots, B)",inline:!0})]}),e.jsxs("li",{children:["Try to compute ",e.jsx(s,{math:"Q = MP",inline:!0})," using group law mod ",e.jsx("em",{children:"n"})]}),e.jsx("li",{children:"If computation fails (GCD gives factor), output factor"}),e.jsx("li",{children:"If no factor found, try new curve and repeat"})]})]}),e.jsxs("p",{children:["The computation fails when we need to invert a number ",e.jsx("em",{children:"d"})," with"," ",e.jsx(s,{math:"1 < \\gcd(d, n) < n",inline:!0}),". This happens exactly when"," ",e.jsx(s,{math:"MP = \\mathcal{O}",inline:!0})," mod ",e.jsx("em",{children:"p"})," but not mod ",e.jsx("em",{children:"n"}),"."]}),e.jsxs(l,{title:"ECM Example",children:[e.jsxs("p",{children:["Factor ",e.jsx(s,{math:"n = 455839",inline:!0})," using curve ",e.jsx(s,{math:"y^2 = x^3 + 5x - 5",inline:!0}),", point ",e.jsx(s,{math:"P = (1, 1)",inline:!0})]}),e.jsxs("p",{className:"mt-2",children:["Compute ",e.jsx(s,{math:"2! \\cdot P = 2P",inline:!0}),":"]}),e.jsxs("p",{children:["Slope ",e.jsx(s,{math:"\\lambda = (3 \\cdot 1^2 + 5)/(2 \\cdot 1) = 8/2 = 4",inline:!0})]}),e.jsx("p",{children:e.jsx(s,{math:"2P = (14, -57)",inline:!0})}),e.jsxs("p",{className:"mt-2",children:["Compute ",e.jsx(s,{math:"3! \\cdot P = 6P = 3 \\cdot 2P",inline:!0}),":"]}),e.jsxs("p",{children:["During calculation of ",e.jsx(s,{math:"3 \\cdot 2P",inline:!0}),", need to invert some denominator ",e.jsx("em",{children:"d"}),"..."]}),e.jsxs("p",{children:["If ",e.jsx(s,{math:"\\gcd(d, 455839) = 599",inline:!0}),", we found factor 599!"]}),e.jsxs("p",{className:"mt-2",children:["Check: ",e.jsx(s,{math:"455839 = 599 \\times 761",inline:!0})]})]}),e.jsx("h3",{children:"Stage 2 Improvement"}),e.jsxs(r,{title:"ECM Stage 2",children:["After Stage 1 with bound ",e.jsx("em",{children:"B1"}),", the group order may have one large prime factor"," ",e.jsx(s,{math:"q \\in (B_1, B_2]",inline:!0}),". Stage 2 handles this:",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["After Stage 1, we have ",e.jsx(s,{math:"Q = M \\cdot P",inline:!0})," where"," ",e.jsx(s,{math:"M = \\prod_{p^a \\leq B_1} p^a",inline:!0})]}),e.jsxs("li",{children:["For each prime ",e.jsx(s,{math:"q \\in (B_1, B_2]",inline:!0}),", check if ",e.jsx(s,{math:"qQ = \\mathcal{O}",inline:!0})]}),e.jsxs("li",{children:["Efficiently: precompute ",e.jsx(s,{math:"Q, 2Q, 4Q, 6Q, \\ldots",inline:!0})," and"," ","use differences between consecutive primes"]})]}),"Stage 2 significantly increases success probability with moderate extra cost."]}),e.jsx("h3",{children:"Complexity Analysis"}),e.jsxs(i,{title:"ECM Complexity",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We derive the subexponential complexity of ECM for finding a prime factor ",e.jsx("em",{children:"p"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Success probability per curve:"})," The group order ",e.jsx(s,{math:"m = \\#E(\\mathbb{F}_p)",inline:!0})," is a random-looking integer in the interval ",e.jsx(s,{math:"[p + 1 - 2\\sqrt{p}, p + 1 + 2\\sqrt{p}]",inline:!0}),". By the Canfield-Erdos-Pomerance theorem, the probability that ",e.jsx("em",{children:"m"})," is ",e.jsx("em",{children:"B"}),"-smooth is approximately:"]}),e.jsx(s,{math:"\\rho(u) \\approx u^{-u}, \\quad u = \\frac{\\ln p}{\\ln B}"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Cost per curve:"})," Computing ",e.jsx(s,{math:"M \\cdot P",inline:!0})," where ",e.jsx(s,{math:"M = \\text{lcm}(1, \\ldots, B) \\approx e^B",inline:!0})," requires ",e.jsx(s,{math:"O(B)",inline:!0})," elliptic curve operations (via prime-by-prime multiplication). Each EC operation costs ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Expected curves needed:"})," ",e.jsx(s,{math:"1/\\rho(u) \\approx u^u",inline:!0})," curves on average."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Total cost:"})," ",e.jsx(s,{math:"T(B) = B \\cdot u^u \\cdot (\\log n)^{O(1)}",inline:!0})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Optimization:"})," Set ",e.jsx(s,{math:"B = L(p)^{1/\\sqrt{2}}",inline:!0})," where ",e.jsx(s,{math:"L(p) = e^{\\sqrt{\\ln p \\ln \\ln p}}",inline:!0}),". Then:"]}),e.jsx(s,{math:"u = \\frac{\\ln p}{\\ln B} = \\frac{\\ln p}{(1/\\sqrt{2})\\sqrt{\\ln p \\ln \\ln p}} = \\sqrt{2} \\cdot \\sqrt{\\frac{\\ln p}{\\ln \\ln p}}"}),e.jsx(s,{math:"u \\ln u = \\sqrt{2} \\cdot \\sqrt{\\frac{\\ln p}{\\ln \\ln p}} \\cdot \\frac{1}{2}\\ln\\left(\\frac{\\ln p}{\\ln \\ln p}\\right) = \\frac{1}{\\sqrt{2}} \\sqrt{\\ln p \\ln \\ln p} + o(\\cdot)"}),e.jsxs("p",{children:["Thus ",e.jsx(s,{math:"u^u = L(p)^{1/\\sqrt{2} + o(1)}",inline:!0})," and:"]}),e.jsx(s,{math:"T = B \\cdot u^u = L(p)^{1/\\sqrt{2}} \\cdot L(p)^{1/\\sqrt{2}} = L(p)^{\\sqrt{2} + o(1)}"}),e.jsxs("p",{children:["Crucially, this depends only on ",e.jsx("em",{children:"p"}),", not on the size of ",e.jsx("em",{children:"n"}),'. ECM is thus optimal for finding "small" factors of large numbers.']})]}),children:["To find a prime factor ",e.jsx("em",{children:"p"})," of ",e.jsx("em",{children:"n"}),", ECM requires expected time:",e.jsx(s,{math:"L(p)^{\\sqrt{2} + o(1)} = \\exp\\left((1 + o(1))\\sqrt{2 \\ln p \\ln \\ln p}\\right)"}),e.jsxs("p",{className:"mt-2",children:["Note: The complexity depends on ",e.jsx("em",{children:"p"}),", not on ",e.jsx("em",{children:"n"}),"!"]})]}),e.jsxs(t,{type:"info",children:[e.jsx("strong",{children:"Optimal for Small Factors:"})," ECM excels when ",e.jsx("em",{children:"n"}),' has a "small" factor (up to ~60 digits). For balanced semiprimes where ',e.jsx(s,{math:"p \\approx q \\approx \\sqrt{n}",inline:!0}),", NFS is faster."]}),e.jsx("h3",{children:"Parameter Selection"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Recommended ECM Parameters"}),e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Factor Size"}),e.jsx("th",{className:"text-left py-2",children:"B1"}),e.jsx("th",{className:"text-left py-2",children:"B2"}),e.jsx("th",{className:"text-left py-2",children:"Curves"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"20 digits"}),e.jsx("td",{className:"py-2",children:"11,000"}),e.jsx("td",{className:"py-2",children:"1.9M"}),e.jsx("td",{className:"py-2",children:"74"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"30 digits"}),e.jsx("td",{className:"py-2",children:"250,000"}),e.jsx("td",{className:"py-2",children:"130M"}),e.jsx("td",{className:"py-2",children:"214"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"40 digits"}),e.jsx("td",{className:"py-2",children:"3M"}),e.jsx("td",{className:"py-2",children:"5.7B"}),e.jsx("td",{className:"py-2",children:"430"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"50 digits"}),e.jsx("td",{className:"py-2",children:"43M"}),e.jsx("td",{className:"py-2",children:"240B"}),e.jsx("td",{className:"py-2",children:"904"})]})]})]})]}),e.jsx("h3",{children:"Montgomery Curves"}),e.jsxs(r,{title:"Montgomery Form",children:["For efficiency, ECM often uses curves in ",e.jsx("strong",{children:"Montgomery form"}),":",e.jsx(s,{math:"By^2 = x^3 + Ax^2 + x"}),"Point addition uses only x-coordinates (projective), avoiding expensive field inversions. This gives approximately 3Ã— speedup over Weierstrass form."]}),e.jsx("h3",{children:"Comparison with Other Methods"}),e.jsx("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Method"}),e.jsx("th",{className:"text-left py-2",children:"Complexity"}),e.jsx("th",{className:"text-left py-2",children:"Best For"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Trial Division"}),e.jsx("td",{className:"py-2",children:e.jsx(s,{math:"O(p)",inline:!0})}),e.jsx("td",{className:"py-2",children:"Very small factors"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Pollard Rho"}),e.jsx("td",{className:"py-2",children:e.jsx(s,{math:"O(\\sqrt{p})",inline:!0})}),e.jsx("td",{className:"py-2",children:"Small factors"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Pollard p-1"}),e.jsx("td",{className:"py-2",children:"Depends on smoothness"}),e.jsx("td",{className:"py-2",children:"Smooth p-1"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"ECM"}),e.jsx("td",{className:"py-2",children:e.jsx(s,{math:"L(p)^{\\sqrt{2}}",inline:!0})}),e.jsx("td",{className:"py-2",children:"Medium factors (~60 digits)"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"QS/NFS"}),e.jsx("td",{className:"py-2",children:e.jsx(s,{math:"L(n)^{c}",inline:!0})}),e.jsx("td",{className:"py-2",children:"Balanced semiprimes"})]})]})]})}),e.jsx("h3",{children:"ECM Records"}),e.jsx("p",{children:"ECM is primarily used to find factors in the 30-70 digit range. Record factors found:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"2019: 83-digit factor (using special hardware)"}),e.jsx("li",{children:"Commonly finds 50-60 digit factors in large-scale searches"}),e.jsx("li",{children:"Essential preprocessing step before running NFS"})]}),e.jsxs(t,{type:"success",children:[e.jsx("strong",{children:"Practical Impact:"})," ECM is the method of choice for finding medium-sized factors. It's used routinely to remove small factors before attempting expensive NFS factorizations, and for factoring numbers in computational number theory research."]})]})}export{j as default};
