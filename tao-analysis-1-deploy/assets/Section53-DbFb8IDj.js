import{j as e}from"./index-Bm0rKt3j.js";import{L as l,D as s,E as i,T as t}from"./ContentBlocks-7534iGiv.js";import{I as n,M as a}from"./MathBlock-Cx6jY3TB.js";import{C as r}from"./Callout-BLBRIJWs.js";function x(){return e.jsxs(l,{sectionId:53,children:[e.jsxs("p",{children:["In the previous chapter we reviewed differentiation - one of the two pillars of single variable calculus. The other pillar is, of course, ",e.jsx("em",{children:"integration"}),", which is the focus of this chapter."]}),e.jsx("p",{children:"Our strategy in defining the Riemann integral is as follows: we begin by first defining a notion of integration on a very simple class of functions - the piecewise constant functions. Then, we handle more general functions by approximating them by piecewise constant functions."}),e.jsxs("p",{children:["Before we can introduce the concept of an integral, we need to describe how one can partition a large interval into smaller intervals. In this chapter, all intervals will be ",e.jsx("em",{children:"bounded"})," intervals."]}),e.jsx("h2",{children:"Connected Sets"}),e.jsx(s,{id:"11.1.1",title:"Connected sets",children:e.jsxs("p",{children:["Let ",e.jsx(n,{children:"X"})," be a subset of ",e.jsxs(n,{children:["\\mathbb","{R}"]}),". We say that"," ",e.jsx(n,{children:"X"})," is ",e.jsx("strong",{children:"connected"})," iff the following property is true: whenever ",e.jsx(n,{children:"x, y"})," are elements in ",e.jsx(n,{children:"X"})," such that"," ",e.jsx(n,{children:String.raw`x < y`}),", the bounded interval ",e.jsx(n,{children:"[x, y]"})," is a subset of ",e.jsx(n,{children:"X"})," (i.e., every number between ",e.jsx(n,{children:"x"})," and"," ",e.jsx(n,{children:"y"})," is also in ",e.jsx(n,{children:"X"}),")."]})}),e.jsx(i,{id:"11.1.3",title:"Examples of connected sets",children:e.jsxs("ul",{className:"list-disc list-inside space-y-2",children:[e.jsxs("li",{children:["The set ",e.jsx(n,{children:"[1, 2]"})," is connected, because if ",e.jsx(n,{children:String.raw`x < y`})," both lie in ",e.jsx(n,{children:"[1, 2]"}),", then ",e.jsx(n,{children:String.raw`1 \leq x < y \leq 2`}),", and so every element between ",e.jsx(n,{children:"x"})," and ",e.jsx(n,{children:"y"})," also lies in ",e.jsx(n,{children:"[1, 2]"}),"."]}),e.jsxs("li",{children:["Similarly, the set ",e.jsx(n,{children:"(1, 2)"})," is connected."]}),e.jsxs("li",{children:["The set ",e.jsx(n,{children:String.raw`[1, 2] \cup [3, 4]`})," is ",e.jsx("em",{children:"not"})," connected: take ",e.jsx(n,{children:"x = 1.5"})," and ",e.jsx(n,{children:"y = 3.5"}),", both in the set, but"," ",e.jsx(n,{children:"2.5 \\in [1.5, 3.5]"})," is not in the set."]}),e.jsxs("li",{children:["The real line ",e.jsxs(n,{children:["\\mathbb","{R}"]})," is connected."]}),e.jsxs("li",{children:["The empty set and singleton sets like ",e.jsx(n,{children:String.raw`\{3\}`})," are connected, but for trivial reasons (they don't contain two elements ",e.jsx(n,{children:"x, y"})," with"," ",e.jsx(n,{children:String.raw`x < y`}),")."]})]})}),e.jsxs(t,{id:"11.1.4",title:"Lemma: Bounded and connected sets are intervals",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"X"})," be a subset of the real line. Then the following two statements are logically equivalent:"]}),e.jsxs("ol",{className:"list-alpha list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(n,{children:"X"})," is bounded and connected."]}),e.jsxs("li",{children:[e.jsx(n,{children:"X"})," is a bounded interval."]})]}),e.jsxs("div",{className:"proof",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(b) implies (a):"})," If ",e.jsx(n,{children:"X"})," is a bounded interval, it is clearly bounded. To show it's connected, if ",e.jsx(n,{children:String.raw`x < y`})," are in ",e.jsx(n,{children:"X"}),", then any ",e.jsx(n,{children:"z"})," with ",e.jsx(n,{children:String.raw`x < z < y`})," is also in ",e.jsx(n,{children:"X"})," by the definition of an interval."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(a) implies (b):"})," Suppose ",e.jsx(n,{children:"X"})," is bounded and connected and non-empty. Let ",e.jsx(n,{children:String.raw`a = \inf X`})," and ",e.jsx(n,{children:String.raw`b = \sup X`}),". By connectedness, if ",e.jsx(n,{children:String.raw`x, y \in X`})," with ",e.jsx(n,{children:String.raw`x < y`}),", then ",e.jsx(n,{children:String.raw`[x, y] \subseteq X`}),". One can show that ",e.jsx(n,{children:"X"})," is one of the intervals ",e.jsx(n,{children:"(a, b)"}),", ",e.jsx(n,{children:"[a, b)"}),", ",e.jsx(n,{children:"(a, b]"}),", or ",e.jsx(n,{children:"[a, b]"})," depending on whether the endpoints are included."]})]})]}),e.jsx(r,{type:"note",children:e.jsxs("p",{children:["Recall that intervals are allowed to be singleton points (e.g., the degenerate interval ",e.jsx(n,{children:String.raw`[2, 2] = \{2\}`}),"), or even the empty set."]})}),e.jsxs(t,{id:"11.1.6",title:"Corollary: Intersection of bounded intervals",children:[e.jsxs("p",{children:["If ",e.jsx(n,{children:"I"})," and ",e.jsx(n,{children:"J"})," are bounded intervals, then the intersection ",e.jsx(n,{children:String.raw`I \cap J`})," is also a bounded interval."]}),e.jsx("div",{className:"proof",children:e.jsxs("p",{children:["The intersection of two bounded sets is bounded. The intersection of two connected sets is connected (if ",e.jsx(n,{children:String.raw`x < y`})," are both in ",e.jsx(n,{children:String.raw`I \cap J`}),", then ",e.jsx(n,{children:String.raw`[x, y] \subseteq I`})," and"," ",e.jsx(n,{children:String.raw`[x, y] \subseteq J`}),", so ",e.jsx(n,{children:String.raw`[x, y] \subseteq I \cap J`}),"). By Lemma 11.1.4, ",e.jsx(n,{children:String.raw`I \cap J`})," is a bounded interval."]})})]}),e.jsxs(i,{id:"11.1.7",title:"Intersections of intervals",children:[e.jsxs("p",{children:["The intersection of ",e.jsx(n,{children:"[2, 4]"})," and ",e.jsx(n,{children:"[4, 6]"})," is"," ",e.jsx(n,{children:String.raw`\{4\}`}),", which is also a bounded interval."]}),e.jsxs("p",{className:"mt-2",children:["The intersection of ",e.jsx(n,{children:"(2, 4)"})," and ",e.jsx(n,{children:"(4, 6)"})," is"," ",e.jsx(n,{children:"\\emptyset"}),", which is also a bounded interval."]})]}),e.jsx("h2",{children:"Length of Intervals"}),e.jsxs(s,{id:"11.1.8",title:"Length of intervals",children:[e.jsxs("p",{children:["If ",e.jsx(n,{children:"I"})," is a bounded interval, we define the ",e.jsx("strong",{children:"length"})," of"," ",e.jsx(n,{children:"I"}),", denoted ",e.jsx(n,{children:"|I|"}),", as follows:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["If ",e.jsx(n,{children:"I"})," is one of ",e.jsx(n,{children:"[a, b]"}),", ",e.jsx(n,{children:"(a, b)"}),","," ",e.jsx(n,{children:"[a, b)"}),", or ",e.jsx(n,{children:"(a, b]"})," for some real numbers"," ",e.jsx(n,{children:String.raw`a < b`}),", then ",e.jsx(n,{children:"|I| := b - a"}),"."]}),e.jsxs("li",{children:["If ",e.jsx(n,{children:"I"})," is a point or the empty set, then ",e.jsx(n,{children:"|I| = 0"}),"."]})]})]}),e.jsx(i,{id:"11.1.9",title:"Examples of interval lengths",children:e.jsxs("p",{children:["The length of ",e.jsx(n,{children:"[3, 5]"})," is 2, as is the length of ",e.jsx(n,{children:"(3, 5)"}),". The length of ",e.jsx(n,{children:String.raw`\{5\}`})," or the empty set is 0."]})}),e.jsx("h2",{children:"Partitions"}),e.jsx(s,{id:"11.1.10",title:"Partitions",children:e.jsxs("p",{children:["Let ",e.jsx(n,{children:"I"})," be a bounded interval. A ",e.jsx("strong",{children:"partition"})," of"," ",e.jsx(n,{children:"I"})," is a finite set ",e.jsxs(n,{children:["\\mathbf","{P}"]})," of bounded intervals contained in ",e.jsx(n,{children:"I"}),", such that every ",e.jsx(n,{children:"x"})," in ",e.jsx(n,{children:"I"})," lies in exactly one of the bounded intervals ",e.jsx(n,{children:"J"})," in ",e.jsxs(n,{children:["\\mathbf","{P}"]}),"."]})}),e.jsx(r,{type:"note",children:e.jsxs("p",{children:["A partition is a ",e.jsx("em",{children:"set of intervals"}),", while each interval is itself a set of real numbers. Thus a partition is a set consisting of other sets."]})}),e.jsxs(i,{id:"11.1.12",title:"Examples of partitions",children:[e.jsxs("p",{children:["The set ",e.jsx(n,{children:String.raw`\mathbf{P} = \{\{1\}, (1, 3), [3, 5), \{5\}, (5, 8], \emptyset\}`})," is a partition of ",e.jsx(n,{children:"[1, 8]"}),", because all intervals in ",e.jsxs(n,{children:["\\mathbf","{P}"]})," lie in ",e.jsx(n,{children:"[1, 8]"}),", and each element of ",e.jsx(n,{children:"[1, 8]"})," lies in exactly one interval in ",e.jsxs(n,{children:["\\mathbf","{P}"]}),"."]}),e.jsxs("p",{className:"mt-2",children:["Note that one could remove the empty set from ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and still obtain a partition."]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Non-examples:"})}),e.jsxs("ul",{className:"list-disc list-inside mt-1 space-y-1",children:[e.jsxs("li",{children:[e.jsx(n,{children:String.raw`\{[1, 4], [3, 5]\}`})," is not a partition of ",e.jsx(n,{children:"[1, 5]"})," because some elements are in more than one interval."]}),e.jsxs("li",{children:[e.jsx(n,{children:String.raw`\{(1, 3), (3, 5)\}`})," is not a partition of ",e.jsx(n,{children:"(1, 5)"})," because the point 3 is not in any interval."]}),e.jsxs("li",{children:[e.jsx(n,{children:String.raw`\{(0, 3), [3, 5)\}`})," is not a partition of ",e.jsx(n,{children:"(1, 5)"})," because",e.jsx(n,{children:"(0, 3)"})," is not contained in ",e.jsx(n,{children:"(1, 5)"}),"."]})]})]}),e.jsx("h2",{children:"Length is Finitely Additive"}),e.jsxs(t,{id:"11.1.13",title:"Length is finitely additive",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"I"})," be a bounded interval, ",e.jsx(n,{children:"n"})," be a natural number, and let ",e.jsxs(n,{children:["\\mathbf","{P}"]})," be a partition of ",e.jsx(n,{children:"I"})," of cardinality ",e.jsx(n,{children:"n"}),". Then:"]}),e.jsx(a,{children:String.raw`|I| = \sum_{J \in \mathbf{P}} |J|`}),e.jsxs("div",{className:"proof",children:[e.jsxs("p",{children:["We prove this by induction on ",e.jsx(n,{children:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Base case:"})," If ",e.jsx(n,{children:"n = 0"}),", then ",e.jsx(n,{children:"I"})," must be empty, and the claim holds trivially. If ",e.jsx(n,{children:"n = 1"}),", then the partition is"," ",e.jsx(n,{children:String.raw`\{J\}`})," with ",e.jsx(n,{children:"J = I"}),", and the claim is immediate."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Inductive step:"})," Suppose the claim holds for partitions of size"," ",e.jsx(n,{children:"n"}),". Let ",e.jsxs(n,{children:["\\mathbf","{P}"]})," be a partition of ",e.jsx(n,{children:"I"})," of size ",e.jsx(n,{children:"n + 1"}),". If ",e.jsx(n,{children:"I"})," is empty or a point, all intervals in ",e.jsxs(n,{children:["\\mathbf","{P}"]})," have length zero and the claim is trivial."]}),e.jsxs("p",{className:"mt-2",children:["Otherwise, ",e.jsx(n,{children:"I"})," has the form ",e.jsx(n,{children:"(a, b)"}),", ",e.jsx(n,{children:"(a, b]"}),","," ",e.jsx(n,{children:"[a, b)"}),", or ",e.jsx(n,{children:"[a, b]"}),". One can find an interval"," ",e.jsx(n,{children:String.raw`K \in \mathbf{P}`})," containing an endpoint of ",e.jsx(n,{children:"I"}),". Then ",e.jsx(n,{children:"I - K"})," is also an interval, and ",e.jsx(n,{children:String.raw`\mathbf{P} - \{K\}`})," is a partition of ",e.jsx(n,{children:"I - K"}),". By induction:"]}),e.jsx(a,{children:String.raw`|I - K| = \sum_{J \in \mathbf{P} - \{K\}} |J|`}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(n,{children:"|I| = |K| + |I - K|"}),", we get ",e.jsx(n,{children:String.raw`|I| = \sum_{J \in \mathbf{P}} |J|`}),"."]})]})]}),e.jsx("h2",{children:"Finer and Coarser Partitions"}),e.jsxs(s,{id:"11.1.14",title:"Finer and coarser partitions",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"I"})," be a bounded interval, and let ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and"," ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," be two partitions of ",e.jsx(n,{children:"I"}),"."]}),e.jsxs("p",{className:"mt-2",children:["We say that ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," is ",e.jsx("strong",{children:"finer"})," than"," ",e.jsxs(n,{children:["\\mathbf","{P}"]})," (or equivalently, that ",e.jsxs(n,{children:["\\mathbf","{P}"]})," is"," ",e.jsx("strong",{children:"coarser"})," than ",e.jsxs(n,{children:["\\mathbf","{P}","'"]}),") if for every"," ",e.jsx(n,{children:String.raw`J \in \mathbf{P}'`}),", there exists a"," ",e.jsx(n,{children:String.raw`K \in \mathbf{P}`})," such that ",e.jsx(n,{children:String.raw`J \subseteq K`}),"."]})]}),e.jsxs(i,{id:"11.1.15",title:"Comparing partitions",children:[e.jsxs("p",{children:["The partition ",e.jsx(n,{children:String.raw`\{[1, 2), \{2\}, (2, 3), [3, 4]\}`})," is finer than ",e.jsx(n,{children:String.raw`\{[1, 2], (2, 4]\}`}),"."]}),e.jsxs("p",{className:"mt-2",children:["Both partitions are finer than ",e.jsx(n,{children:String.raw`\{[1, 4]\}`}),", which is the coarsest possible partition of ",e.jsx(n,{children:"[1, 4]"}),"."]}),e.jsxs("p",{className:"mt-2",children:['Note that there is no "finest" partition of ',e.jsx(n,{children:"[1, 4]"})," (since all partitions are required to be finite)."]})]}),e.jsx(r,{type:"warning",children:e.jsxs("p",{children:["We do not compare partitions of different intervals. If ",e.jsxs(n,{children:["\\mathbf","{P}"]})," is a partition of ",e.jsx(n,{children:"[1, 4]"})," and ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," is a partition of ",e.jsx(n,{children:"[2, 5]"}),", we would not say that one is coarser or finer than the other."]})}),e.jsx("h2",{children:"Common Refinement"}),e.jsxs(s,{id:"11.1.16",title:"Common refinement",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"I"})," be a bounded interval, and let ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and"," ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," be two partitions of ",e.jsx(n,{children:"I"}),". We define the"," ",e.jsx("strong",{children:"common refinement"})," ",e.jsx(n,{children:String.raw`\mathbf{P} \# \mathbf{P}'`})," of"," ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," to be the set:"]}),e.jsx(a,{children:String.raw`\mathbf{P} \# \mathbf{P}' := \{K \cap J : K \in \mathbf{P} \text{ and } J \in \mathbf{P}'\}`})]}),e.jsxs(i,{id:"11.1.17",title:"Common refinement example",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:String.raw`\mathbf{P} := \{[1, 3), [3, 4]\}`})," and"," ",e.jsx(n,{children:String.raw`\mathbf{P}' := \{[1, 2], (2, 4]\}`})," be two partitions of ",e.jsx(n,{children:"[1, 4]"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(n,{children:String.raw`\mathbf{P} \# \mathbf{P}' = \{[1, 2], (2, 3), [3, 4], \emptyset\}`}),"."]})]}),e.jsxs(t,{id:"11.1.18",title:"Lemma: Common refinement is a partition",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"I"})," be a bounded interval, and let ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and"," ",e.jsxs(n,{children:["\\mathbf","{P}","'"]})," be two partitions of ",e.jsx(n,{children:"I"}),". Then ",e.jsx(n,{children:String.raw`\mathbf{P} \# \mathbf{P}'`})," is also a partition of ",e.jsx(n,{children:"I"}),", and is both finer than ",e.jsxs(n,{children:["\\mathbf","{P}"]})," and finer than ",e.jsxs(n,{children:["\\mathbf","{P}","'"]}),"."]}),e.jsxs("div",{className:"proof",children:[e.jsxs("p",{children:["Each element ",e.jsx(n,{children:String.raw`K \cap J`})," is a bounded interval by Corollary 11.1.6. For any ",e.jsx(n,{children:String.raw`x \in I`}),", there is exactly one ",e.jsx(n,{children:String.raw`K \in \mathbf{P}`})," and exactly one ",e.jsx(n,{children:String.raw`J \in \mathbf{P}'`})," containing ",e.jsx(n,{children:"x"}),", so ",e.jsx(n,{children:"x"})," lies in exactly one element of ",e.jsx(n,{children:String.raw`\mathbf{P} \# \mathbf{P}'`}),"."]}),e.jsxs("p",{className:"mt-2",children:["For fineness: any ",e.jsx(n,{children:String.raw`K \cap J \in \mathbf{P} \# \mathbf{P}'`})," satisfies"," ",e.jsx(n,{children:String.raw`K \cap J \subseteq K`})," where ",e.jsx(n,{children:String.raw`K \in \mathbf{P}`}),", so ",e.jsx(n,{children:String.raw`\mathbf{P} \# \mathbf{P}'`})," is finer than ",e.jsxs(n,{children:["\\mathbf","{P}"]}),". Similarly for ",e.jsxs(n,{children:["\\mathbf","{P}","'"]}),"."]})]})]}),e.jsx(r,{type:"info",children:e.jsxs("p",{children:[e.jsx("strong",{children:"Why partitions matter:"})," Partitions are the foundation for defining the Riemann integral. We will use them to define piecewise constant functions (which are easy to integrate), and then approximate more general functions by piecewise constant ones. The common refinement operation allows us to compare different approximations."]})})]})}export{x as default};
