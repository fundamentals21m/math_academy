import{j as e}from"./vendor-animation-0o8UKZ_1.js";import"./vendor-react-Drj8qL0h.js";import"./vendor-math-p018AHG0.js";import"./index-B5nJM3q3.js";import{L as n,D as t,E as r,C as i}from"./Callout-BoWwIfEn.js";import{I as s,M as l}from"./MathBlock-uz1iP4cD.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-B3IzoTDS.js";function j(){return e.jsxs(n,{sectionId:7,children:[e.jsx("h2",{className:"text-2xl font-bold text-dark-100 mb-6",children:"Implementation Pitfalls"}),e.jsx("p",{className:"mb-4",children:"Understanding the math is necessary but not sufficient. Implementing elliptic curve cryptography correctly is surprisingly difficult. Even small mistakes can completely break security."}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Big Integer Arithmetic"}),e.jsx("p",{className:"mb-4",children:"secp256k1 uses 256-bit numbers, but most CPUs only support 64-bit arithmetic natively. This creates several challenges:"}),e.jsxs(t,{title:"Multi-Precision Arithmetic",children:[e.jsx("p",{children:'A 256-bit number must be represented as an array of smaller "limbs." For example, four 64-bit limbs or eight 32-bit limbs. Operations must handle:'}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Carries:"})," Addition overflow propagates between limbs"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Borrows:"})," Subtraction underflow propagates between limbs"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Multiplication:"})," Produces 512-bit intermediate results"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Reduction:"})," Bringing results back mod ",e.jsx(s,{children:"p"})]})]})]}),e.jsxs(r,{title:"Limb Representation",children:[e.jsx("p",{children:"A 256-bit number in four 64-bit limbs:"}),e.jsx(l,{children:"n = l_0 + l_1 \\cdot 2^{64} + l_2 \\cdot 2^{128} + l_3 \\cdot 2^{192}"}),e.jsx("p",{className:"mt-2",children:"Multiplication of two such numbers requires computing all 16 partial products and managing carries carefully."})]}),e.jsx(i,{type:"warning",title:"Don't Roll Your Own",children:e.jsx("p",{children:"Implementing big integer arithmetic correctly is extremely error-prone. Use battle-tested libraries like GMP, or better yet, use a complete ECC library like libsecp256k1."})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Constant-Time Operations"}),e.jsxs("p",{className:"mb-4",children:["This is perhaps the most subtle and dangerous pitfall. ",e.jsx("strong",{children:"Timing attacks"})," ","can extract secret keys by measuring how long operations take."]}),e.jsxs(t,{title:"Timing Side Channels",children:[e.jsx("p",{children:"If the execution time of cryptographic operations depends on secret values, an attacker can measure timing differences to learn those secrets."}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4 mt-3 text-sm",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"Dangerous patterns:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"Conditional branches on secret data"}),e.jsx("li",{children:"Array indexing with secret indices"}),e.jsx("li",{children:"Early-exit optimizations"}),e.jsx("li",{children:"Variable-time multiplication"})]})]})]}),e.jsxs(r,{title:"Dangerous vs. Safe Code",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"Dangerous (timing leak):"}),e.jsx("pre",{className:"bg-dark-800 rounded-lg p-3 mt-2 text-sm font-mono overflow-x-auto",children:`// Leaks information about bit value
if (secret_bit == 1) {
    R = point_add(R, G);  // Takes ~1ms
}`}),e.jsx("p",{className:"text-emerald-400 font-bold mt-4",children:"Safe (constant time):"}),e.jsx("pre",{className:"bg-dark-800 rounded-lg p-3 mt-2 text-sm font-mono overflow-x-auto",children:`// Always does both, selects result
T = point_add(R, G);
R = constant_time_select(secret_bit, T, R);`})]}),e.jsx(i,{type:"error",title:"Real-World Timing Attacks",children:e.jsx("p",{children:"In 2011, researchers extracted an OpenSSL private key by measuring timing variations in ECDSA signing—remotely, over a network. The attack exploited timing differences in modular inversion."})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Point Representations"}),e.jsx("p",{className:"mb-4",children:"Different coordinate systems offer different performance trade-offs:"}),e.jsx("div",{className:"overflow-x-auto mb-6",children:e.jsxs("table",{className:"w-full text-sm",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"text-left",children:[e.jsx("th",{className:"pb-2",children:"Representation"}),e.jsx("th",{className:"pb-2",children:"Coordinates"}),e.jsx("th",{className:"pb-2",children:"Inversions"}),e.jsx("th",{className:"pb-2",children:"Use Case"})]})}),e.jsxs("tbody",{className:"text-dark-300",children:[e.jsxs("tr",{children:[e.jsx("td",{className:"py-2 text-amber-400",children:"Affine"}),e.jsx("td",{children:e.jsx(s,{children:"(x, y)"})}),e.jsx("td",{children:"Every operation"}),e.jsx("td",{children:"Input/output only"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2 text-emerald-400",children:"Projective"}),e.jsxs("td",{children:[e.jsx(s,{children:"(X, Y, Z)"})," where ",e.jsx(s,{children:"x = X/Z"})]}),e.jsx("td",{children:"Only at the end"}),e.jsx("td",{children:"General computation"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2 text-cyan-400",children:"Jacobian"}),e.jsxs("td",{children:[e.jsx(s,{children:"(X, Y, Z)"})," where ",e.jsx(s,{children:"x = X/Z^2"})]}),e.jsx("td",{children:"Only at the end"}),e.jsx("td",{children:"Fastest for doubling"})]})]})]})}),e.jsx(t,{title:"Why Avoid Inversions?",children:e.jsxs("p",{children:["Modular inversion (finding ",e.jsxs(s,{children:["a^","{-1}"," \\mod p"]}),") is expensive— about 30-100x slower than multiplication. By using projective coordinates, we defer all inversions until the final result, doing just one inversion instead of hundreds."]})}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"Common Mistakes Checklist"}),e.jsxs("div",{className:"space-y-4",children:[e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"1. Nonce Reuse"}),e.jsxs("p",{className:"text-sm text-dark-300 mt-1",children:["Using the same ",e.jsx(s,{children:"k"})," twice reveals the private key. Always use RFC 6979 for deterministic nonces."]})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"2. Weak Random Number Generation"}),e.jsxs("p",{className:"text-sm text-dark-300 mt-1",children:["Never use ",e.jsx("code",{children:"rand()"})," or ",e.jsx("code",{children:"Math.random()"}),". Use cryptographically secure sources like ",e.jsx("code",{children:"/dev/urandom"})," or",e.jsx("code",{children:"crypto.getRandomValues()"}),"."]})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"3. Not Validating Points"}),e.jsx("p",{className:"text-sm text-dark-300 mt-1",children:"Always verify that input points are on the curve. Attackers can supply invalid points to extract information."})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"4. Timing Variations"}),e.jsx("p",{className:"text-sm text-dark-300 mt-1",children:"All operations on secret data must be constant-time. This includes comparisons, array lookups, and branches."})]}),e.jsxs("div",{className:"bg-dark-800 rounded-lg p-4",children:[e.jsx("p",{className:"text-rose-400 font-bold",children:"5. Not Clearing Sensitive Memory"}),e.jsx("p",{className:"text-sm text-dark-300 mt-1",children:'Private keys and intermediate values must be securely erased from memory after use. Optimizers may remove "dead" zeroing code.'})]})]}),e.jsx("h3",{className:"text-xl font-semibold text-dark-100 mt-8 mb-4",children:"The Solution: libsecp256k1"}),e.jsxs("p",{className:"mb-4",children:["Bitcoin Core maintains ",e.jsx("strong",{children:"libsecp256k1"}),", a highly optimized, constant-time implementation of secp256k1 operations. It's the gold standard for a reason:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 mb-6",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Constant-time:"})," All secret-dependent operations"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Extensively tested:"})," Fuzzing, formal verification, years of use"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Optimized:"})," Assembly for x86-64, ARM; 10x faster than naive implementations"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Well-audited:"})," Multiple security audits by experts"]})]}),e.jsx(i,{type:"success",title:"Best Practice",children:e.jsxs("p",{children:["Unless you're a cryptography expert doing research, ",e.jsx("strong",{children:"don't implement ECC yourself"}),". Use libsecp256k1 or bindings to it. The risk of subtle bugs is too high, and the consequences are catastrophic."]})})]})}export{j as default};
