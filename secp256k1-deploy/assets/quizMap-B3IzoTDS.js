const t=[{id:1,type:"multiple-choice",question:"What problem does public-key cryptography solve?",options:["Making data smaller for storage","Enabling secure communication without pre-shared secrets","Speeding up calculations","Generating random numbers"],correctIndex:1,difficulty:"easy",explanation:"Public-key cryptography allows Alice and Bob to communicate securely without having to meet first to exchange a secret key."},{id:2,type:"multiple-choice",question:"Why did Bitcoin choose elliptic curves over RSA?",options:["RSA was invented after Bitcoin","Elliptic curves provide equivalent security with much smaller keys","RSA cannot be used for signatures","Elliptic curves are simpler to understand"],correctIndex:1,difficulty:"medium",explanation:"A 256-bit ECC key provides roughly the same security as a 3072-bit RSA key, resulting in smaller transactions and signatures."},{id:3,type:"multiple-choice",question:'What is a "one-way function" in cryptography?',options:["A function that can only be computed once","A function easy to compute but hard to reverse","A function that always returns the same value","A function that cannot be computed by computers"],correctIndex:1,difficulty:"easy",explanation:"A one-way function is easy to compute in one direction but computationally infeasible to reverse without special knowledge."},{id:4,type:"text",question:'In secp256k1, the "256" refers to what?',correctAnswer:"256",difficulty:"easy",explanation:'The "256" in secp256k1 refers to the bit length of the prime fieldâ€”the curve operates with 256-bit numbers.'},{id:5,type:"multiple-choice",question:"What is the Elliptic Curve Discrete Logarithm Problem (ECDLP)?",options:["Finding the equation of an elliptic curve","Given $Q = dG$, finding the scalar $d$","Computing the square root of a point","Factoring the curve's prime"],correctIndex:1,difficulty:"medium",explanation:"The ECDLP is: given points $G$ and $Q = dG$, find the scalar $d$. This is believed to be computationally infeasible for large $d$."}],i=[{id:1,type:"multiple-choice",question:"What is the general form of an elliptic curve equation?",options:["$y = x^2 + ax + b$","$y^2 = x^3 + ax + b$","$y^3 = x^2 + ax + b$","$y^2 = x^2 + ax + b$"],correctIndex:1,difficulty:"easy",explanation:"Elliptic curves have the Weierstrass form $y^2 = x^3 + ax + b$, which is cubic in $x$ and quadratic in $y$."},{id:2,type:"multiple-choice",question:"How is point addition defined geometrically?",options:["Add the coordinates directly: $(x_1 + x_2, y_1 + y_2)$","Draw a line through two points, find the third intersection, reflect over x-axis","Compute the midpoint of the two points","Multiply the coordinates together"],correctIndex:1,difficulty:"medium",explanation:"To add $P + Q$: draw a line through $P$ and $Q$, find where it intersects the curve again, then reflect that point over the x-axis."},{id:3,type:"multiple-choice",question:"What is point doubling ($P + P$)?",options:["Adding $P$ to itself using the tangent line at $P$","The reflection of $P$ over the x-axis","Not defined for elliptic curves","The point $(2x, 2y)$"],correctIndex:0,difficulty:"medium",explanation:"Point doubling uses the tangent line at $P$ instead of a secant. The tangent intersects the curve at exactly one other point, which is then reflected."},{id:4,type:"text",question:"What point serves as the identity element in elliptic curve arithmetic? (Use the letter O)",correctAnswer:"O",difficulty:"easy",explanation:'The "point at infinity" $\\mathcal{O}$ is the identity element: $P + \\mathcal{O} = P$ for any point $P$.'},{id:5,type:"multiple-choice",question:"What is scalar multiplication ($nP$) on an elliptic curve?",options:["Multiplying the coordinates by $n$","Adding $P$ to itself $n$ times","Dividing the point by $n$","Finding the $n$th root of $P$"],correctIndex:1,difficulty:"easy",explanation:"Scalar multiplication $nP$ means $P + P + \\ldots + P$ ($n$ times). It's efficiently computed using the double-and-add algorithm."}],n=[{id:1,type:"multiple-choice",question:"Why can't we use real numbers for cryptography?",options:["Real numbers are too small","Real numbers require infinite precision and cause rounding errors","Real numbers don't support addition","Real numbers are not defined mathematically"],correctIndex:1,difficulty:"easy",explanation:"Cryptographic operations must be exact. Real numbers would require infinite storage and cause rounding errors that break security."},{id:2,type:"multiple-choice",question:"What is $17 \\mod 5$?",options:["$2$","$3$","$5$","$12$"],correctIndex:0,difficulty:"easy",explanation:"$17 = 3 \\cdot 5 + 2$, so the remainder is $2$. Therefore $17 \\mod 5 = 2$."},{id:3,type:"multiple-choice",question:"How do you compute division in a finite field?",options:["Regular division, then take mod","Multiply by the modular inverse","Division is not possible in finite fields","Subtract until the result is less than the divisor"],correctIndex:1,difficulty:"medium",explanation:"In a finite field, $a / b = a \\cdot b^{-1}$ where $b^{-1}$ is the multiplicative inverse: the number such that $b \\cdot b^{-1} \\equiv 1 \\pmod{p}$."},{id:4,type:"multiple-choice",question:"According to Fermat's Little Theorem, if $p$ is prime, then $a^{p-1} \\equiv$ ?",options:["$0 \\pmod{p}$","$1 \\pmod{p}$","$a \\pmod{p}$","$p \\pmod{p}$"],correctIndex:1,difficulty:"medium",explanation:"Fermat's Little Theorem states that for prime $p$ and $a \\not\\equiv 0$, we have $a^{p-1} \\equiv 1 \\pmod{p}$."},{id:5,type:"text",question:"Using Fermat's Little Theorem, $a^{-1} \\equiv a^{p-?} \\pmod{p}$. What number fills the blank?",correctAnswer:"2",difficulty:"hard",explanation:"Since $a^{p-1} \\equiv 1$, we have $a \\cdot a^{p-2} \\equiv 1$, so $a^{-1} \\equiv a^{p-2} \\pmod{p}$."}],o=[{id:1,type:"multiple-choice",question:"What are the six parameters that define secp256k1?",options:["$(x, y, z, a, b, c)$","$(p, a, b, G, n, h)$","$(d, Q, k, r, s, z)$","$(m, e, s, R, P, Q)$"],correctIndex:1,difficulty:"easy",explanation:"secp256k1 is defined by the prime $p$, curve coefficients $a$ and $b$, generator point $G$, group order $n$, and cofactor $h$."},{id:2,type:"multiple-choice",question:"What is the value of $a$ in secp256k1's equation $y^2 = x^3 + ax + b$?",options:["$1$","$7$","$0$","$256$"],correctIndex:2,difficulty:"easy",explanation:"secp256k1 uses $a = 0$, which simplifies the curve equation to $y^2 = x^3 + 7$."},{id:3,type:"multiple-choice",question:"Why is secp256k1's prime $p = 2^{256} - 2^{32} - 977$ special?",options:["It's the largest 256-bit prime","It's a pseudo-Mersenne prime allowing fast modular reduction","It was chosen randomly by the NSA","It's the product of two smaller primes"],correctIndex:1,difficulty:"medium",explanation:"The special form (close to a power of 2) allows for ~30% faster modular arithmetic compared to arbitrary primes."},{id:4,type:"text",question:"What is secp256k1's cofactor $h$?",correctAnswer:"1",difficulty:"easy",explanation:"secp256k1 has cofactor $h = 1$, the simplest case that avoids small-subgroup attacks."},{id:5,type:"multiple-choice",question:"Why is $h = 1$ considered ideal for cryptographic curves?",options:["It makes the curve larger","All non-identity points have prime order, preventing small-subgroup attacks","It allows faster computation","It was mandated by NIST"],correctIndex:1,difficulty:"medium",explanation:"With $h = 1$, every non-identity point generates the entire group, so there are no small subgroups to exploit."}],s=[{id:1,type:"multiple-choice",question:"Given private key $d$, how is the public key $Q$ computed?",options:["$Q = d / G$","$Q = d \\cdot G$ (scalar multiplication)","$Q = d + G$","$Q = H(d)$"],correctIndex:1,difficulty:"easy",explanation:"The public key is computed as $Q = d \\cdot G$, where $G$ is the generator point and $d$ is the private key scalar."},{id:2,type:"multiple-choice",question:"What algorithm efficiently computes scalar multiplication $dG$?",options:["Binary search","Double-and-add","Trial division","Euclidean algorithm"],correctIndex:1,difficulty:"medium",explanation:"Double-and-add processes each bit of $d$, doubling at each step and adding $G$ when the bit is 1. This reduces operations from $O(d)$ to $O(\\log d)$."},{id:3,type:"multiple-choice",question:"How many bytes is a compressed secp256k1 public key?",options:["32 bytes","33 bytes","64 bytes","65 bytes"],correctIndex:1,difficulty:"medium",explanation:"Compressed keys are 33 bytes: 1 byte prefix (02 or 03 for y-parity) plus 32 bytes for the x-coordinate."},{id:4,type:"multiple-choice",question:"Why can we recover $y$ from just $x$ and a parity bit?",options:["$y$ is always zero","For each $x$, there are at most two valid $y$ values (one even, one odd)","The curve equation is linear","$y$ equals $x$"],correctIndex:1,difficulty:"medium",explanation:"From $y^2 = x^3 + 7$, there are two square roots: $y$ and $-y = p - y$. One is even, one is odd, so the parity bit selects which."},{id:5,type:"text",question:"Approximately how many bits of security does a 256-bit elliptic curve key provide?",correctAnswer:"128",difficulty:"hard",explanation:"Due to Pollard's rho attack requiring $\\sqrt{n} \\approx 2^{128}$ operations, a 256-bit curve provides 128-bit security."}],a=[{id:1,type:"multiple-choice",question:"In ECDSA signing, what is the formula for $s$?",options:["$s = k + z$","$s = k^{-1}(z + rd) \\mod n$","$s = z \\cdot d$","$s = r / k$"],correctIndex:1,difficulty:"medium",explanation:"ECDSA computes $s = k^{-1}(z + rd) \\mod n$, where $k$ is the nonce, $z$ is the message hash, $r$ is the x-coordinate of $kG$, and $d$ is the private key."},{id:2,type:"multiple-choice",question:"What catastrophic vulnerability occurs if the same nonce $k$ is used twice?",options:["The signature becomes invalid","The private key can be computed by anyone","The message is revealed","Nothing happens"],correctIndex:1,difficulty:"medium",explanation:"With two signatures using the same $k$, an attacker can solve for $k$ and then compute the private key $d$."},{id:3,type:"multiple-choice",question:"RFC 6979 solves the nonce problem by:",options:["Using a hardware random number generator","Deriving $k$ deterministically from the private key and message","Requiring a trusted third party","Eliminating the nonce entirely"],correctIndex:1,difficulty:"medium",explanation:"RFC 6979 computes $k = \\text{HMAC-SHA256}(d, z)$, making it deterministic and unique per message."},{id:4,type:"multiple-choice",question:"Signature malleability means:",options:["Signatures can be forged","Both $(r, s)$ and $(r, n-s)$ are valid signatures","Signatures are too large","Signatures don't verify correctly"],correctIndex:1,difficulty:"hard",explanation:"Given valid $(r, s)$, the pair $(r, -s \\mod n)$ also verifies because negating $s$ negates the verification point, but it has the same x-coordinate."},{id:5,type:"multiple-choice",question:"BIP 62's low-s requirement says:",options:["$s$ must be 0","$s \\leq n/2$","$s$ must be prime","$s > n$"],correctIndex:1,difficulty:"medium",explanation:"Bitcoin requires $s \\leq n/2$ to eliminate signature malleability, ensuring only one valid signature exists per message."}],r=[{id:1,type:"multiple-choice",question:"How does Schnorr's signing formula differ from ECDSA?",options:["Schnorr: $s = k + ed$; ECDSA: $s = k^{-1}(z + rd)$","They are identical","Schnorr requires no nonce","ECDSA is simpler"],correctIndex:0,difficulty:"medium",explanation:"Schnorr uses $s = k + ed$ (no inverse needed), while ECDSA uses $s = k^{-1}(z + rd)$."},{id:2,type:"multiple-choice",question:"What is the main advantage of Schnorr signature aggregation (MuSig)?",options:["Signatures become smaller","Multiple signatures combine into one indistinguishable from a single signature","Private keys are no longer needed","Verification becomes slower"],correctIndex:1,difficulty:"medium",explanation:"MuSig allows multiple parties to produce a single aggregated signature that looks identical to a regular single-signer signature."},{id:3,type:"multiple-choice",question:"Schnorr verification checks that:",options:["$sG = R - eQ$","$sG = R + eQ$","$sR = G + eQ$","$eG = R + sQ$"],correctIndex:1,difficulty:"medium",explanation:"Schnorr verification checks $sG = R + eQ$, which follows from $s = k + ed$ and $R = kG$, $Q = dG$."},{id:4,type:"multiple-choice",question:"Why was Schnorr not used in Bitcoin originally?",options:["It wasn't invented yet","It was patented until 2008","It's less secure than ECDSA","It requires larger keys"],correctIndex:1,difficulty:"easy",explanation:"Claus Schnorr's patent expired in 2008, just before Bitcoin's release. ECDSA was already established and patent-free."},{id:5,type:"multiple-choice",question:"Bitcoin's Taproot upgrade (BIP 340/341/342) uses:",options:["Only ECDSA","Schnorr signatures with x-only public keys","RSA signatures","No signatures at all"],correctIndex:1,difficulty:"medium",explanation:"Taproot uses Schnorr with 32-byte x-only public keys, enabling both key-path and script-path spending."}],c=[{id:1,type:"multiple-choice",question:"Why is big integer arithmetic challenging for secp256k1?",options:["256-bit numbers fit in standard CPU registers",'256-bit numbers must be split into smaller "limbs" and operations must handle carries',"Only floating-point operations are available","The numbers are too small"],correctIndex:1,difficulty:"medium",explanation:"CPUs typically support 64-bit arithmetic natively, so 256-bit numbers must be split into multiple limbs with careful carry/borrow handling."},{id:2,type:"multiple-choice",question:"What is a timing attack?",options:["Attacking systems during maintenance windows","Extracting secrets by measuring execution time differences","Preventing systems from synchronizing clocks","A type of denial-of-service attack"],correctIndex:1,difficulty:"medium",explanation:"Timing attacks measure how long operations take; if execution time depends on secret values, attackers can learn those secrets."},{id:3,type:"multiple-choice",question:"Why are projective coordinates used instead of affine coordinates?",options:["They require smaller numbers","They avoid expensive modular inversions until the final result","They are mandated by Bitcoin","Affine coordinates don't work on elliptic curves"],correctIndex:1,difficulty:"hard",explanation:"Modular inversion is 30-100x slower than multiplication. Projective coordinates defer all inversions to one final conversion."},{id:4,type:"multiple-choice",question:"Which of these is a dangerous coding pattern for cryptography?",options:["Using constant-time comparison functions","Using conditional branches that depend on secret values","Clearing sensitive memory after use","Using cryptographically secure random number generators"],correctIndex:1,difficulty:"medium",explanation:"Conditional branches on secret data cause timing variations that can leak information to attackers."},{id:5,type:"multiple-choice",question:"What is the recommended approach for implementing secp256k1?",options:["Write your own implementation for learning","Use libsecp256k1 or bindings to it","Use standard library math functions","Implement it in JavaScript for portability"],correctIndex:1,difficulty:"easy",explanation:"libsecp256k1 is the gold standard: constant-time, extensively tested, optimized, and well-audited. Rolling your own is dangerous."}],l=[{id:1,type:"multiple-choice",question:"Ethereum uses secp256k1 but differs from Bitcoin in that:",options:["Ethereum uses a different curve equation","Ethereum addresses are derived directly from the public key hash, not via RIPEMD160","Ethereum uses RSA instead","Ethereum has no digital signatures"],correctIndex:1,difficulty:"medium",explanation:"Ethereum addresses are the last 20 bytes of keccak256(public_key), while Bitcoin adds RIPEMD160 hashing."},{id:2,type:"multiple-choice",question:"What is an adaptor signature?",options:["A signature that adapts to different message formats","An incomplete signature that requires a secret to complete","A signature that works on multiple blockchains","A signature optimized for mobile devices"],correctIndex:1,difficulty:"medium",explanation:'Adaptor signatures are "locked" with a secret; revealing the completed signature reveals the secret, enabling atomic swaps.'},{id:3,type:"multiple-choice",question:"Lightning Network uses secp256k1 for:",options:["Only channel funding","Channel funding, HTLCs, revocation keys, and onion routing","Only payment verification","Lightning doesn't use cryptography"],correctIndex:1,difficulty:"medium",explanation:"Lightning relies heavily on secp256k1 for 2-of-2 multisig channels, HTLC contracts, punishment mechanisms, and route blinding."},{id:4,type:"multiple-choice",question:"What does ECRECOVER in Ethereum do?",options:["Recovers lost private keys","Returns the signer's address given a message hash and signature","Encrypts data for recovery","Generates new key pairs"],correctIndex:1,difficulty:"medium",explanation:"ECRECOVER is a precompiled contract that extracts the signer's address from a signature, enabling on-chain verification."},{id:5,type:"multiple-choice",question:"Nostr uses secp256k1 for:",options:["Encrypting all messages","User identity (public keys as identifiers) and event signing","Only relay authentication","Nostr uses a different cryptographic system"],correctIndex:1,difficulty:"easy",explanation:"Nostr identities are secp256k1 public keys, and all events are signed with the corresponding private keys."}],d=[{id:1,type:"multiple-choice",question:"What is the fundamental security assumption underlying secp256k1?",options:["RSA problem","Elliptic Curve Discrete Logarithm Problem (ECDLP)","Factoring large primes","Collision resistance of SHA-256"],correctIndex:1,difficulty:"easy",explanation:"All secp256k1 security rests on ECDLP: given $G$ and $Q = dG$, finding $d$ is computationally infeasible."},{id:2,type:"multiple-choice",question:"How does Shor's algorithm threaten elliptic curve cryptography?",options:["It makes signing slower","It can solve ECDLP in polynomial time on a quantum computer","It only affects RSA, not ECC","It has already broken Bitcoin"],correctIndex:1,difficulty:"medium",explanation:"Shor's algorithm would reduce ECDLP from exponential to polynomial time, making secp256k1 insecure on sufficiently large quantum computers."},{id:3,type:"multiple-choice",question:'What is "harvest now, decrypt later"?',options:["A farming technique","Recording encrypted data today to decrypt when quantum computers exist","A type of signature aggregation","A Bitcoin mining strategy"],correctIndex:1,difficulty:"medium",explanation:"Adversaries may store encrypted communications now, waiting for quantum computers to break the encryption later."},{id:4,type:"multiple-choice",question:"Which post-quantum cryptography approach was standardized by NIST?",options:["secp512k1","Lattice-based (CRYSTALS-Dilithium)","Larger RSA keys","Quantum key distribution"],correctIndex:1,difficulty:"medium",explanation:"NIST selected lattice-based schemes like CRYSTALS-Dilithium and hash-based SPHINCS+ as post-quantum signature standards."},{id:5,type:"multiple-choice",question:"Why does secp256k1 remain popular despite newer curves like Ed25519?",options:["It's faster than all alternatives","Extensive auditing, no suspicious parameters, and massive network effects","It's the only curve that works with Bitcoin","NIST mandates its use"],correctIndex:1,difficulty:"medium",explanation:"secp256k1 has years of battle-testing, simple parameters with no hidden backdoors, and is the de facto standard for blockchain cryptography."}],u={0:t,1:i,2:n,3:o,4:s,5:a,6:r,7:c,8:l,9:d};function p(e){return u[e]??null}export{p as g};
