import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as r,C as i}from"./Callout-BQHVajQg.js";import{I as n,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-dwDT9AaP.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-JSsPSwPL.js";function a(){return e.jsxs(r,{sectionId:13,children:[e.jsx("h2",{children:"Inverses and One-to-One Transformations"}),e.jsxs("p",{children:["Given a function ",e.jsx(n,{children:"T"}),", our goal is to find, if possible, another function ",e.jsx(n,{children:"S"})," whose composition with"," ",e.jsx(n,{children:"T"})," is the identity transformation. Since composition is generally not commutative, we distinguish between left and right inverses."]}),e.jsx("h3",{children:"Left and Right Inverses"}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," Given ",e.jsx(n,{children:"T: V \\to W"}),":",e.jsx("br",{}),e.jsx("br",{}),"A function ",e.jsx(n,{children:"S: T(V) \\to V"})," is a ",e.jsx("strong",{children:"left inverse"})," ","of ",e.jsx(n,{children:"T"})," if ",e.jsx(n,{children:"S[T(x)] = x"})," for all"," ",e.jsx(n,{children:"x"})," in ",e.jsx(n,{children:"V"}),", i.e.,"," ",e.jsx(n,{children:"ST = I_V"}),".",e.jsx("br",{}),e.jsx("br",{}),"A function ",e.jsx(n,{children:"R: T(V) \\to V"})," is a ",e.jsx("strong",{children:"right inverse"})," ","of ",e.jsx(n,{children:"T"})," if ",e.jsx(n,{children:"T[R(y)] = y"})," for all"," ",e.jsx(n,{children:"y"})," in ",e.jsx(n,{children:"T(V)"}),", i.e.,"," ",e.jsx(n,{children:"TR = I_{T(V)}"}),"."]}),e.jsx("h3",{children:"Uniqueness of Left Inverses"}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Theorem 2.8:"})," A function ",e.jsx(n,{children:"T: V \\to W"})," can have at most one left inverse. If ",e.jsx(n,{children:"T"})," has a left inverse"," ",e.jsx(n,{children:"S"}),", then ",e.jsx(n,{children:"S"})," is also a right inverse."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Proof:"})," If ",e.jsx(n,{children:"S"})," and"," ",e.jsx(n,{children:"S'"})," are both left inverses, then for any"," ",e.jsx(n,{children:"y = T(x)"})," in ",e.jsx(n,{children:"T(V)"}),":"]}),e.jsx(s,{children:"S(y) = S[T(x)] = x = S'[T(x)] = S'(y)"}),e.jsxs("p",{children:["So ",e.jsx(n,{children:"S = S'"}),". To show ",e.jsx(n,{children:"S"})," is also a right inverse: for any ",e.jsx(n,{children:"y = T(x) \\in T(V)"}),", we have"," ",e.jsx(n,{children:"x = S[T(x)] = S(y)"}),", so"," ",e.jsx(n,{children:"T[S(y)] = T(x) = y"}),"."]}),e.jsx("h3",{children:"Characterization of Invertible Functions"}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Theorem 2.9:"})," A function ",e.jsx(n,{children:"T: V \\to W"})," has a left inverse if and only if ",e.jsx(n,{children:"T"})," is ",e.jsx("strong",{children:"one-to-one"})," ","on ",e.jsx(n,{children:"V"}),"; that is, for all ",e.jsx(n,{children:"x, y"})," in"," ",e.jsx(n,{children:"V"}),":",e.jsx(s,{children:"x \\neq y \\implies T(x) \\neq T(y)"}),"or equivalently:",e.jsx(s,{children:"T(x) = T(y) \\implies x = y"})]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," Let ",e.jsx(n,{children:"T: V \\to W"})," be one-to-one. The unique left inverse (which is also a right inverse) is denoted"," ",e.jsx(n,{children:"T^{-1}"})," and called the ",e.jsx("strong",{children:"inverse"})," of"," ",e.jsx(n,{children:"T"}),". We say ",e.jsx(n,{children:"T"})," is"," ",e.jsx("strong",{children:"invertible"}),"."]}),e.jsx("h3",{children:"One-to-One Linear Transformations"}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Theorem 2.10:"})," Let ",e.jsx(n,{children:"T: V \\to W"})," be a linear transformation. The following statements are equivalent:",e.jsx("br",{}),e.jsx("br",{}),"(a) ",e.jsx(n,{children:"T"})," is one-to-one on ",e.jsx(n,{children:"V"}),".",e.jsx("br",{}),"(b) ",e.jsx(n,{children:"T"})," is invertible and"," ",e.jsx(n,{children:"T^{-1}: T(V) \\to V"})," is linear.",e.jsx("br",{}),"(c) For all ",e.jsx(n,{children:"x"})," in ",e.jsx(n,{children:"V"}),","," ",e.jsx(n,{children:"T(x) = 0"})," implies ",e.jsx(n,{children:"x = 0"}),". That is,"," ",e.jsx(n,{children:"N(T) = \\{0\\}"}),"."]}),e.jsx("h3",{children:"Finite-Dimensional Characterizations"}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Theorem 2.11:"})," Let ",e.jsx(n,{children:"T: V \\to W"})," be linear with"," ",e.jsx(n,{children:"\\dim V = n"}),". The following are equivalent:",e.jsx("br",{}),e.jsx("br",{}),"(a) ",e.jsx(n,{children:"T"})," is one-to-one on ",e.jsx(n,{children:"V"}),".",e.jsx("br",{}),"(b) If ",e.jsx(n,{children:"e_1, \\ldots, e_p"})," are independent in"," ",e.jsx(n,{children:"V"}),", then ",e.jsx(n,{children:"T(e_1), \\ldots, T(e_p)"})," are independent in ",e.jsx(n,{children:"T(V)"}),".",e.jsx("br",{}),"(c) ",e.jsx(n,{children:"\\dim T(V) = n"}),".",e.jsx("br",{}),"(d) If ",e.jsx(n,{children:"\\{e_1, \\ldots, e_n\\}"})," is a basis for"," ",e.jsx(n,{children:"V"}),", then"," ",e.jsx(n,{children:"\\{T(e_1), \\ldots, T(e_n)\\}"})," is a basis for"," ",e.jsx(n,{children:"T(V)"}),"."]}),e.jsxs(i,{type:"success",children:[e.jsx("strong",{children:"Key Insight:"})," For linear transformations, being one-to-one is equivalent to having a trivial null space. This is a powerful result: to check if a linear transformation is invertible, we only need to verify that"," ",e.jsx(n,{children:"T(x) = 0"})," implies ",e.jsx(n,{children:"x = 0"}),". The inverse of a linear transformation is automatically linear, which is not true for general functions."]})]})}export{a as default};
