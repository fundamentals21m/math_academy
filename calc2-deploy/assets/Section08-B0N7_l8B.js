import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as i,C as r}from"./Callout-BQHVajQg.js";import{I as n,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-dwDT9AaP.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-JSsPSwPL.js";function _(){return e.jsxs(i,{sectionId:8,children:[e.jsx("h2",{children:"The Gram-Schmidt Process"}),e.jsxs("p",{children:["Every finite-dimensional linear space has a finite basis. If the space is Euclidean, we can always construct an ",e.jsx("strong",{children:"orthogonal basis"}),". The construction is called the ",e.jsx("strong",{children:"Gram-Schmidt orthogonalization process"}),", named after J. P. Gram (1850-1916) and E. Schmidt (1845-1921)."]}),e.jsx("h3",{children:"The Orthogonalization Theorem"}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Theorem 1.13 (Orthogonalization Theorem):"})," Let"," ",e.jsx(n,{children:"x_1, x_2, \\ldots"})," be a finite or infinite sequence of elements in a Euclidean space ",e.jsx(n,{children:"V"}),", and let"," ",e.jsx(n,{children:"L(x_1, \\ldots, x_k)"})," denote the subspace spanned by the first"," ",e.jsx(n,{children:"k"})," elements. Then there is a corresponding sequence"," ",e.jsx(n,{children:"y_1, y_2, \\ldots"})," with the following properties for each"," ",e.jsx(n,{children:"k"}),":",e.jsx("br",{}),e.jsx("br",{}),"(a) ",e.jsx(n,{children:"y_k"})," is orthogonal to every element in"," ",e.jsx(n,{children:"L(y_1, \\ldots, y_{k-1})"}),".",e.jsx("br",{}),"(b) ",e.jsx(n,{children:"L(y_1, \\ldots, y_k) = L(x_1, \\ldots, x_k)"}),".",e.jsx("br",{}),"(c) The sequence is unique up to scalar factors."]}),e.jsx("h3",{children:"The Gram-Schmidt Process"}),e.jsxs("p",{children:["If the elements ",e.jsx(n,{children:"x_1, \\ldots, x_k"})," are independent, then the corresponding ",e.jsx(n,{children:"y_1, \\ldots, y_k"})," are nonzero, and the construction is given by:"]}),e.jsx(s,{children:"y_1 = x_1"}),e.jsx(s,{children:"y_{r+1} = x_{r+1} - \\sum_{i=1}^r \\frac{(x_{r+1}, y_i)}{(y_i, y_i)} y_i \\quad \\text{for } r = 1, 2, \\ldots, k-1"}),e.jsxs("p",{children:["In words: to construct ",e.jsx(n,{children:"y_{r+1}"}),", we subtract from"," ",e.jsx(n,{children:"x_{r+1}"})," the projection of"," ",e.jsx(n,{children:"x_{r+1}"})," along each of the earlier elements"," ",e.jsx(n,{children:"y_1, \\ldots, y_r"}),"."]}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," If ",e.jsx(n,{children:"x"})," and"," ",e.jsx(n,{children:"y"})," are elements in a Euclidean space with"," ",e.jsx(n,{children:"y \\neq 0"}),", the element:",e.jsx(s,{children:"\\frac{(x, y)}{(y, y)} y"}),"is called the ",e.jsxs("strong",{children:["projection of ",e.jsx(n,{children:"x"})," along"," ",e.jsx(n,{children:"y"})]}),"."]}),e.jsxs(r,{type:"info",children:[e.jsx("strong",{children:"Theorem 1.14:"})," Every finite-dimensional Euclidean space has an orthonormal basis."]}),e.jsxs("p",{children:["To obtain an orthonormal basis, simply normalize each element"," ",e.jsx(n,{children:"y_i"})," by dividing it by its norm."]}),e.jsxs("h3",{children:["Example 1: Orthonormal Basis in ",e.jsx(n,{children:"V_4"})]}),e.jsxs("p",{children:["Find an orthonormal basis for the subspace of ",e.jsx(n,{children:"V_4"})," spanned by:"]}),e.jsx(s,{children:"x_1 = (1, -1, 1, -1), \\quad x_2 = (5, 1, 1, 1), \\quad x_3 = (-3, -3, 1, -3)"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Solution:"})," Applying the Gram-Schmidt process:"]}),e.jsx(s,{children:"y_1 = x_1 = (1, -1, 1, -1)"}),e.jsx(s,{children:"y_2 = x_2 - \\frac{(x_2, y_1)}{(y_1, y_1)} y_1 = (5, 1, 1, 1) - 0 = (4, 2, 0, 2)"}),e.jsx(s,{children:"y_3 = x_3 - \\frac{(x_3, y_1)}{(y_1, y_1)} y_1 - \\frac{(x_3, y_2)}{(y_2, y_2)} y_2 = (0, 0, 0, 0)"}),e.jsxs("p",{children:["Since ",e.jsx(n,{children:"y_3 = 0"}),", the vectors"," ",e.jsx(n,{children:"x_1, x_2, x_3"})," are dependent. The subspace has dimension 2, and ",e.jsx(n,{children:"\\{y_1, y_2\\}"})," is an orthogonal basis. Normalizing:"]}),e.jsx(s,{children:"\\frac{y_1}{\\|y_1\\|} = \\frac{1}{2}(1, -1, 1, -1), \\quad \\frac{y_2}{\\|y_2\\|} = \\frac{1}{\\sqrt{6}}(2, 1, 0, 1)"}),e.jsx("h3",{children:"Example 2: The Legendre Polynomials"}),e.jsxs("p",{children:["In the linear space of all polynomials with inner product"," ",e.jsx(n,{children:"(x, y) = \\int_{-1}^1 x(t)y(t)\\, dt"}),", apply the Gram-Schmidt process to ",e.jsx(n,{children:"x_n(t) = t^n"})," for"," ",e.jsx(n,{children:"n = 0, 1, 2, \\ldots"})]}),e.jsx("p",{children:"The first few polynomials are:"}),e.jsx(s,{children:"y_0(t) = 1"}),e.jsx(s,{children:"y_1(t) = t"}),e.jsx(s,{children:"y_2(t) = t^2 - \\frac{1}{3}"}),e.jsx(s,{children:"y_3(t) = t^3 - \\frac{3}{5}t"}),e.jsx(s,{children:"y_4(t) = t^4 - \\frac{6}{7}t^2 + \\frac{3}{35}"}),e.jsxs("p",{children:["The polynomials ",e.jsx(n,{children:"P_n"})," given by normalizing these are known as the ",e.jsx("strong",{children:"Legendre polynomials"}),":"]}),e.jsx(s,{children:"P_n(t) = \\frac{1}{2^n n!} \\frac{d^n}{dt^n} (t^2 - 1)^n"}),e.jsxs("p",{children:["The normalized Legendre polynomials ",e.jsx(n,{children:"\\varphi_n = y_n/\\|y_n\\|"})," are:"]}),e.jsx(s,{children:"\\varphi_0(t) = \\sqrt{\\frac{1}{2}}, \\quad \\varphi_1(t) = \\sqrt{\\frac{3}{2}}t, \\quad \\varphi_2(t) = \\frac{1}{2}\\sqrt{\\frac{5}{2}} (3t^2 - 1)"}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Key Insight:"})," The Gram-Schmidt process is a fundamental algorithm that converts any basis into an orthogonal (or orthonormal) basis. This is essential for numerical computations, approximation theory, and the study of Fourier series. The process can detect linear dependence: if ",e.jsx(n,{children:"y_k = 0"})," at some step, the original elements ",e.jsx(n,{children:"x_1, \\ldots, x_k"})," are dependent."]})]})}export{_ as default};
