import{j as s}from"./vendor-animation-0o8UKZ_1.js";import{L as n,b as t,c as a,C as r,a as i}from"./Card-C_-Ky_5l.js";import{I as e,M as o}from"./MathBlock-_bBfq7Jh.js";import"./vendor-react-Drj8qL0h.js";import{S as c,ab as l}from"./SectionQuiz-C0q-nnJy.js";import"./index-B15ugEG0.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";function u(){return s.jsxs(n,{sectionId:63,children:[s.jsx("h2",{className:"text-2xl font-semibold mb-4",children:"Functors"}),s.jsxs("p",{className:"text-dark-200 mb-6 text-lg leading-relaxed",children:["Just as we study structure-preserving functions between sets, we study"," ",s.jsx("strong",{children:"structure-preserving mappings between categories"}),". These mappings are called ",s.jsx("strong",{children:"functors"}),", and they reveal deep connections between different mathematical structures."]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Definition of a Functor"}),s.jsxs(t,{variant:"success",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"F"}),title:"Definition: Functor"}),s.jsxs("p",{className:"text-dark-300 mb-3",children:["If ",s.jsx(e,{math:"\\\\mathbf{A}"})," and ",s.jsx(e,{math:"\\\\mathbf{B}"})," are two categories, a ",s.jsx("strong",{children:"functor"})," ",s.jsx(e,{math:"F"})," from"," ",s.jsx(e,{math:"\\\\mathbf{A}"})," to ",s.jsx(e,{math:"\\\\mathbf{B}"})," is a mapping that sends objects of ",s.jsx(e,{math:"\\\\mathbf{A}"})," to objects of ",s.jsx(e,{math:"\\\\mathbf{B}"})," and arrows of ",s.jsx(e,{math:"\\\\mathbf{A}"})," to arrows of ",s.jsx(e,{math:"\\\\mathbf{B}"}),", such that:"]}),s.jsxs("ol",{className:"list-decimal list-inside text-dark-300 space-y-2",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"Preserves source and target:"})," If ",s.jsx(e,{math:"g"})," is an arrow with source ",s.jsx(e,{math:"a"})," and target ",s.jsx(e,{math:"a'"}),", then ",s.jsx(e,{math:"F(g)"})," has source ",s.jsx(e,{math:"F(a)"})," and target ",s.jsx(e,{math:"F(a')"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Preserves identities:"})," ",s.jsx(e,{math:"F(1_a) = 1_{F(a)}"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Preserves composition:"})," ",s.jsx(e,{math:"F(g \\\\circ h) = F(g) \\\\circ F(h)"})]})]})]}),s.jsx(r,{type:"info",title:"Structure Preservation",children:s.jsx("p",{children:"A functor preserves all the categorical structure: sources and targets of arrows, identity arrows, and composition. This is analogous to how a homomorphism preserves algebraic structure."})})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Example 33.1: Functions as Functors"}),s.jsxs(t,{variant:"info",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"1"}),title:"Sets to Sets"}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Suppose ",s.jsx(e,{math:"A"})," and ",s.jsx(e,{math:"B"})," are sets, each viewed as a discrete category (Example 32.1). Let ",s.jsx(e,{math:"F"})," be any function from ",s.jsx(e,{math:"A"})," to ",s.jsx(e,{math:"B"}),"."]}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Since each element ",s.jsx(e,{math:"a"})," is both an object and arrow ",s.jsx(e,{math:"1_a"}),", and ",s.jsx(e,{math:"F(a)"})," is both ",s.jsx(e,{math:"F(a)"})," and ",s.jsx(e,{math:"1_{F(a)}"}),", we have:"]}),s.jsx(o,{math:"F(1_a) = F(a) = 1_{F(a)}"}),s.jsxs("p",{className:"text-dark-300 mt-2 text-sm italic",children:["Hence ",s.jsx("strong",{children:"every function between sets is automatically a functor"})," ","between the corresponding discrete categories."]})]})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Example 33.2: Monoid Homomorphisms as Functors"}),s.jsxs(t,{variant:"warning",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"M"}),title:"Monoids to Monoids"}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Suppose ",s.jsx(e,{math:"A"})," and ",s.jsx(e,{math:"B"})," are monoids, each viewed as a one-object category (Example 32.2). Let ",s.jsx(e,{math:"F"})," be a monoid homomorphism from ",s.jsx(e,{math:"A"})," to ",s.jsx(e,{math:"B"}),"."]}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Since ",s.jsx(e,{math:"F"})," is a homomorphism:"]}),s.jsxs("ul",{className:"list-disc list-inside text-dark-300 space-y-1",children:[s.jsxs("li",{children:[s.jsx(e,{math:"F(1_*) = 1_{F(*)}"})," (identity maps to identity)"]}),s.jsx("li",{children:s.jsx(e,{math:"F(a \\\\circ a') = F(a \\\\cdot a') = F(a) \\\\cdot F(a') = F(a) \\\\circ F(a')"})})]}),s.jsxs("p",{className:"text-dark-300 mt-2 text-sm italic",children:["Hence ",s.jsx("strong",{children:"every monoid homomorphism is a functor"})," between the corresponding one-object categories."]})]})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Example 33.3: Monotone Mappings as Functors"}),s.jsxs(t,{variant:"info",children:[s.jsx(a,{icon:s.jsx(e,{math:"\\\\leq"}),title:"Pre-ordered Sets"}),s.jsxs("p",{className:"text-dark-300",children:["A ",s.jsx("strong",{children:"monotone mapping"})," between pre-ordered sets may be viewed as a functor between the corresponding categories. The verification follows the same pattern as the previous examples."]})]}),s.jsx(r,{type:"info",title:"Unified Perspective",children:s.jsxs("p",{children:["In Chapter 32, we saw that sets, monoids, and pre-ordered sets can all be viewed as categories. Now we see that the natural structure-preserving maps between them (functions, homomorphisms, monotone mappings) are all examples of ",s.jsx("strong",{children:"functors"}),"."]})})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Example 33.4: A Set as a Functor"}),s.jsxs(t,{children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"S"}),title:"Set as Functor"}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["A set ",s.jsx(e,{math:"S"})," can be viewed as a functor! Let"," ",s.jsx(e,{math:"\\\\mathbf{A}"})," be the discrete one-element category and ",s.jsx(e,{math:"\\\\mathbf{B}"})," the category of sets."]}),s.jsxs("p",{className:"text-dark-300",children:["For any set ",s.jsx(e,{math:"S"}),", there is a unique functor"," ",s.jsx(e,{math:"F : \\\\mathbf{A} \\\\to \\\\mathbf{B}"})," such that ",s.jsx(e,{math:"F(1_{\\\\mathbf{A}})"})," is the identity function on"," ",s.jsx(e,{math:"S"}),". This functor ",s.jsx("em",{children:"is"})," the set ",s.jsx(e,{math:"S"}),"."]})]})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Example 33.5: A Graph as a Functor"}),s.jsxs(t,{variant:"info",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"G"}),title:"Graph as Functor"}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Let ",s.jsx(e,{math:"\\\\mathbf{A}"})," be a category with two objects ",s.jsx(e,{math:"\\\\mathbf{a}"})," and ",s.jsx(e,{math:"\\\\mathbf{o}"}),", and four arrows: ",s.jsx(e,{math:"1_{\\\\mathbf{a}}"}),","," ",s.jsx(e,{math:"1_{\\\\mathbf{o}}"}),","," ",s.jsx(e,{math:"s : \\\\mathbf{a} \\\\to \\\\mathbf{o}"}),", and"," ",s.jsx(e,{math:"t : \\\\mathbf{a} \\\\to \\\\mathbf{o}"}),"."]}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["Suppose ",s.jsx(e,{math:"F"})," maps ",s.jsx(e,{math:"\\\\mathbf{a}"})," to a set ",s.jsx(e,{math:"X"})," and ",s.jsx(e,{math:"\\\\mathbf{o}"})," to a set ",s.jsx(e,{math:"Y"}),", with ",s.jsx(e,{math:"F(s)"})," and"," ",s.jsx(e,{math:"F(t)"})," as functions from ",s.jsx(e,{math:"X"})," to"," ",s.jsx(e,{math:"Y"}),"."]}),s.jsxs("p",{className:"text-dark-300 text-sm italic",children:["Then ",s.jsx(e,{math:"F"})," is a functor, and we can think of it as a"," ",s.jsx("strong",{children:"graph"})," with objects ",s.jsx(e,{math:"Y"}),", arrows ",s.jsx(e,{math:"X"}),", source mapping ",s.jsx(e,{math:"F(s)"}),", and target mapping ",s.jsx(e,{math:"F(t)"}),"."]})]})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Small Categories and Cat"}),s.jsxs(t,{variant:"success",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"C"}),title:"The Category Cat"}),s.jsxs("p",{className:"text-dark-300 mb-2",children:["A category is called ",s.jsx("strong",{children:"small"})," if both its class of objects and its class of arrows are ",s.jsx("em",{children:"sets"})," (as opposed to proper classes)."]}),s.jsxs("p",{className:"text-dark-300 mb-2",children:[s.jsx("strong",{children:"Cat"})," is the category whose:"]}),s.jsxs("ul",{className:"list-disc list-inside text-dark-300 space-y-1",children:[s.jsx("li",{children:"Objects are small categories"}),s.jsx("li",{children:"Arrows are functors from one small category to another"})]})]}),s.jsx(r,{type:"info",title:"Categories All the Way Down",children:s.jsxs("p",{children:["The fact that small categories themselves form a category again illustrates the slogan: ",s.jsx("em",{children:'"interesting objects congregate in categories"'}),"."]})})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Key Insights"}),s.jsxs(i,{columns:2,children:[s.jsxs(t,{variant:"success",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"U"}),title:"Unification"}),s.jsx("p",{className:"text-dark-300 text-sm",children:"Functors unify different kinds of structure-preserving maps: functions, homomorphisms, and monotone mappings are all functors."})]}),s.jsxs(t,{variant:"success",children:[s.jsx(a,{icon:s.jsx("span",{className:"text-2xl",children:"V"}),title:"Viewpoint"}),s.jsxs("p",{className:"text-dark-300 text-sm",children:["Mathematical entities (sets, graphs, M-sets) can often be ",s.jsx("em",{children:"viewed as functors"}),", providing a powerful categorical perspective."]})]})]})]}),s.jsxs("section",{className:"mb-8",children:[s.jsx("h3",{className:"text-xl font-semibold mb-4",children:"Summary"}),s.jsx(t,{children:s.jsxs("ul",{className:"space-y-2 text-dark-200",children:[s.jsxs("li",{children:[s.jsx("strong",{children:"Functor:"})," A mapping between categories preserving objects, arrows, identities, and composition"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Three conditions:"})," ",s.jsx(e,{math:"F(g): F(a) \\\\to F(a')"}),","," ",s.jsx(e,{math:"F(1_a) = 1_{F(a)}"}),","," ",s.jsx(e,{math:"F(g \\\\circ h) = F(g) \\\\circ F(h)"})]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Functions as functors:"})," Every function between sets is a functor between discrete categories"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Homomorphisms as functors:"})," Monoid homomorphisms are functors between one-object categories"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Monotone maps as functors:"})," Order-preserving maps are functors between pre-order categories"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Entities as functors:"})," Sets, graphs, and M-sets can be viewed as functors"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Small category:"})," Objects and arrows form sets, not proper classes"]}),s.jsxs("li",{children:[s.jsx("strong",{children:"Cat:"})," The category of small categories with functors as arrows"]})]})})]}),s.jsx(c,{sectionId:63,questions:l})]})}export{u as default};
