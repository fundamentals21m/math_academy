import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,T as n,E as t,C as r}from"./Callout-DA0JknRv.js";import{I as s,M as i}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function f(){return e.jsxs(h,{sectionId:33,children:[e.jsx("p",{children:"MDS codes have a remarkable property: their weight distribution is completely determined by their parameters. In this section, we derive the unique weight distribution formula for MDS codes and explore its consequences."}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Message Symbol Flexibility"}),e.jsx(n,{title:"Message Symbol Positions",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"i_1, i_2, \\ldots, i_k"})," be the chosen ",e.jsx(s,{children:"k"})," positions. Let ",e.jsx(s,{children:"mathbf{G}"})," be a generator matrix of ",e.jsx(s,{children:"mathcal{C}"}),". Since ",e.jsx(s,{children:"mathcal{C}"})," is MDS, every ",e.jsx(s,{children:"k"})," columns of"," ",e.jsx(s,{children:"mathbf{G}"})," are linearly independent."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{children:"\bar{'{'}mathbf{G}{'}'} = (mathbf{G}_{i_1} ; mathbf{G}_{i_2} ; cdots ; mathbf{G}_{i_k})"}),"where ",e.jsx(s,{children:"mathbf{G}_1, mathbf{G}_2, ldots, mathbf{G}_n"})," are the columns of"," ",e.jsx(s,{children:"mathbf{G}"}),". Then ",e.jsx(s,{children:"\bar{'{'}mathbf{G}{'}'}"})," is invertible."]}),e.jsxs("p",{className:"mt-2",children:["Set ",e.jsx(s,{children:"mathbf{G}' = \bar{'{'}mathbf{G}{'}'}^\\{-1\\}mathbf{G}"}),". This is also a generator matrix of ",e.jsx(s,{children:"mathcal{C}"}),". Given message ",e.jsx(s,{children:"mathbf{a} = (a_1, ldots, a_k)"}),", let"," ",e.jsx(s,{children:"mathbf{a}' = mathbf{a}\bar{'{'}mathbf{G}{'}'}^\\{-1\\}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The code word ",e.jsx(s,{children:"mathbf{a}mathbf{G}' = mathbf{a}'mathbf{G}"})," has entries ",e.jsx(s,{children:"a_1, a_2, \\ldots, a_k"})," in positions"," ",e.jsx(s,{children:"i_1, i_2, \\ldots, i_k"})," respectively."]})]}),children:e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathcal{C}"})," be an ",e.jsx(s,{children:"[n, k, d]"})," MDS code. Then any ",e.jsx(s,{children:"k"})," symbols of the code words may be taken as message symbols."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Characterization by Minimum Weight Codewords"}),e.jsx(n,{title:"Minimum Distance Codewords in Any Position",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Necessity:"})," Let ",e.jsx(s,{children:"mathcal{C}"})," be MDS. By the previous theorem, any ",e.jsx(s,{children:"k"})," coordinates can be taken as message symbol positions. Given ",e.jsx(s,{children:"d = n - k + 1"})," coordinate positions, take one of them (say the ",e.jsx(s,{children:"i"}),"th) and the complementary"," ",e.jsx(s,{children:"k - 1"})," coordinates as message positions."]}),e.jsxs("p",{className:"mt-2",children:["Consider the message word with 1 in the position corresponding to the"," ",e.jsx(s,{children:"i"}),"th code position and 0 elsewhere. The corresponding code word has a non-zero entry in the ",e.jsx(s,{children:"i"}),"th position and 0 in the"," ",e.jsx(s,{children:"k - 1"})," complementary positions. Since it has weight"," ",e.jsx(s,{children:"n - k + 1"}),", each of the remaining ",e.jsx(s,{children:"n - k"})," positions must have a non-zero entry."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Sufficiency:"})," Suppose ",e.jsx(s,{children:"mathcal{C}"})," has a code word of weight ",e.jsx(s,{children:"d"})," in any ",e.jsx(s,{children:"d"})," coordinate positions. If ",e.jsx(s,{children:"d \\leq n - k"}),", choosing a generator matrix in standard form and a code word with non-zero entries only in the last ",e.jsx(s,{children:"d"})," positions leads to a contradiction (the message must be zero). Hence ",e.jsx(s,{children:"d = n - k + 1"}),"."]})]}),children:e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathcal{C}"})," be an ",e.jsx(s,{children:"[n, k, d]"})," code over"," ",e.jsx(s,{children:"	ext{GF}(q)"}),". Then ",e.jsx(s,{children:"mathcal{C}"})," is an MDS code if and only if ",e.jsx(s,{children:"mathcal{C}"})," has a minimum distance code word with non-zero entries in any ",e.jsx(s,{children:"d"})," coordinates."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Counting Minimum Weight Codewords"}),e.jsxs(n,{title:"Number of Minimum Weight Codewords",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"n - k + 1"})," coordinate positions be given and let"," ",e.jsx(s,{children:"mathbf{b} = (b_1, b_2, ldots, b_n)"})," be a code word of weight"," ",e.jsx(s,{children:"n - k + 1"})," with non-zero entries at the given positions."]}),e.jsxs("p",{className:"mt-2",children:["Every non-zero scalar multiple of ",e.jsx(s,{children:"mathbf{b}"})," gives a distinct code word of weight ",e.jsx(s,{children:"n - k + 1"})," with non-zero entries at the same positions, yielding ",e.jsx(s,{children:"q - 1"})," such code words."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"mathbf{c} = (c_1, ldots, c_n)"})," is another code word of weight ",e.jsx(s,{children:"n - k + 1"})," with non-zero entries at the given positions and ",e.jsx(s,{children:`mathbf{c} 
otin {'{'}alphamathbf{b} : alpha 
eq 0{'}'}`}),", then for some ",e.jsx(s,{children:"i"}),", we have"," ",e.jsx(s,{children:`0 
eq c_i 
otin {'{'}alpha b_i : alpha 
eq 0{'}'}`}),"."]}),e.jsxs("p",{className:"mt-2",children:["But ",e.jsx(s,{children:"|{'{'}c_i{'}'} cup {'{'}alpha b_i{'}'}{'}| = q"})," and all elements are non-zeroâ€”a contradiction. Hence ",e.jsx(s,{children:"mathbf{c}"})," is a scalar multiple of ",e.jsx(s,{children:"mathbf{b}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since there are ",e.jsx(s,{children:"\binom{'{n}{n-k+1}'}"})," ways to choose the positions, the total count is ",e.jsx(s,{children:"(q-1)\binom{'{n}{n-k+1}'}"}),"."]})]}),children:[e.jsxs("p",{children:["The number of code words of weight ",e.jsx(s,{children:"n - k + 1"})," in an"," ",e.jsx(s,{children:"[n, k, d]"})," MDS code over ",e.jsx(s,{children:"	ext{GF}(q)"})," is:"]}),e.jsx(i,{children:`
          (q - 1)\\binom{'{n}{n - k + 1}'}
        `})]}),e.jsxs(t,{title:"Weight Distribution of a [3,2,2] MDS Code",children:[e.jsxs("p",{children:["Consider the ",e.jsx(s,{children:"[4, 2, -]"})," code over ",e.jsx(s,{children:"	ext{GF}(3)"})," ","generated by:"]}),e.jsx(i,{children:`
          \\mathbf{G} = \\begin{pmatrix} 1 & 0 & 1 & 1 \\\\ 0 & 1 & -1 & 1 \\end{pmatrix}
        `}),e.jsx("p",{className:"mt-2",children:"The code words are:"}),e.jsxs("div",{className:"font-mono text-sm mt-2 p-4 bg-dark-800 rounded-lg",children:["0000, 1011, -101-1, 01-11, 0-11-1,",e.jsx("br",{}),"110-1, -1110, 1-1-10, -1-101"]}),e.jsx("p",{className:"mt-2",children:"The number of minimum weight codewords (weight 3) is:"}),e.jsx(i,{children:`
          (3-1)\\binom{'{4}{4-2+1}'} = 2 \\cdot \\binom{'{4}{3}'} = 2 \\cdot 4 = 8
        `}),e.jsxs("p",{className:"mt-2",children:["The weight enumerator is ",e.jsx(s,{children:"W_\\mathcal{C}(x,y) = x^4 + 8xy^3"}),"."]})]}),e.jsxs(t,{title:"Self-Dual MDS Code",children:[e.jsxs("p",{children:["For the code in the previous example, the dual"," ",e.jsx(s,{children:"\\mathcal{C}^perp"})," is generated by:"]}),e.jsx(i,{children:`
          \\mathbf{H} = \\begin{pmatrix} -1 & 1 & 1 & 0 \\\\ -1 & -1 & 0 & 1 \\end{pmatrix}
        `}),e.jsxs("p",{className:"mt-2",children:["Computing the code words of ",e.jsx(s,{children:"\\mathcal{C}^perp"}),":"]}),e.jsxs("div",{className:"font-mono text-sm mt-2 p-4 bg-dark-800 rounded-lg",children:["0000, -1110, 1-1-10, -1-101, 1101,",e.jsx("br",{}),"1011, 01-11, 0-11-1, -10-1-1"]}),e.jsxs("p",{className:"mt-2",children:["We observe that ",e.jsx(s,{children:"\\mathcal{C}^perp = \\mathcal{C}"}),", so this code is ",e.jsx("strong",{children:"self-dual"}),"."]})]}),e.jsxs(r,{type:"info",title:"General Weight Formula",children:[e.jsxs("p",{children:["For an ",e.jsx(s,{children:"[n, k]"})," MDS code over ",e.jsx(s,{children:"	ext{GF}(q)"}),", the number ",e.jsx(s,{children:"A_w"})," of codewords of weight ",e.jsx(s,{children:"w"})," is given by:"]}),e.jsx(i,{children:`
          A_w = \\binom{'{n}{w}'} \\sum_\\{j=0\\}^\\{w-d\\} (-1)^j \\binom{'{w}{j}'} (q^\\{w-d+1-j\\} - 1)
        `}),e.jsxs("p",{className:"mt-2",children:["for ",e.jsx(s,{children:"d \\leq w \\leq n"}),", where ",e.jsx(s,{children:"d = n - k + 1"}),"."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Examples of Weight Enumerators"}),e.jsxs(t,{title:"Weight Enumerator of [3,1,3] Code",children:[e.jsxs("p",{children:["Consider the ",e.jsx(s,{children:"[3, 1, 3]"})," code over ",e.jsx(s,{children:"	ext{GF}(3)"}),":"]}),e.jsx(i,{children:`
          \\mathcal{C} = \\{{000, 111, 222}\\}}
        `}),e.jsxs("p",{className:"mt-2",children:["There are ",e.jsx(s,{children:"(3-1)\binom{'{3}{3}'} = 2"})," codewords of weight 3. The weight enumerator is:"]}),e.jsx(i,{children:`
          W_\\mathcal{C}(x,y) = x^3 + 2y^3
        `}),e.jsx("p",{className:"mt-2",children:"The dual is generated by rows of the matrix:"}),e.jsx(i,{children:`
          \\mathbf{H} = \\begin{pmatrix} 1 & -1 & 1 \\end{pmatrix}
        `}),e.jsxs("p",{className:"mt-2",children:["Code words of ",e.jsx(s,{children:"\\mathcal{C}^perp"}),": 000, 1-11, -11-1. So ",e.jsx(s,{children:"W_{'{mathcal{C}^perp}'}(x,y) = x^3 + 2y^3"}),"."]})]}),e.jsxs(r,{type:"note",title:"Uniqueness of Weight Distribution",children:["A remarkable property of MDS codes is that their weight distribution depends only on the parameters ",e.jsx(s,{children:"n"}),", ",e.jsx(s,{children:"k"}),", and ",e.jsx(s,{children:"q"}),". All MDS codes with the same parameters have the same weight enumerator."]})]})}export{f as default};
