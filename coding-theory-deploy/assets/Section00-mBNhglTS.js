import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as t,C as d,D as n,E as c,T as r}from"./Callout-BFDudfNm.js";import{I as i,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function p(){return e.jsxs(t,{sectionId:0,children:[e.jsx("h2",{children:"Chapter 1: Group Codes"}),e.jsx("h3",{children:"1.1 Elementary Properties"}),e.jsxs("p",{children:["Coding theory emerged in the late 1940s to address engineering problems in reliable communication. The field developed by using sophisticated mathematical techniques, and the aspect using algebraic methods became known as ",e.jsx("strong",{children:"Algebraic Coding Theory"}),". The subject is concerned with devising efficient encoding and decoding procedures."]}),e.jsxs(d,{type:"info",children:[e.jsx("strong",{children:"The Communication Problem:"})," When a message is transmitted through a noisy channel, errors may occur. Coding theory provides methods to detect and correct these errors by adding redundancy to the message in a structured way."]}),e.jsx("h3",{children:"Algebraic Foundations"}),e.jsxs(n,{title:"Group",children:[e.jsxs("p",{children:["A non-empty set ",e.jsx(i,{children:"G"})," with a binary composition is called a ",e.jsx("strong",{children:"group"})," if the following hold:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Associativity:"})," ",e.jsx(i,{children:"(ab)c = a(bc)"})," for all ",e.jsx(i,{children:"a, b, c \\in G"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Identity:"})," There exists an element ",e.jsx(i,{children:"e \\in G"})," such that ",e.jsx(i,{children:"ea = ae = a"})," for all ",e.jsx(i,{children:"a \\in G"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Inverse:"})," For every ",e.jsx(i,{children:"a \\in G"}),", there exists ",e.jsx(i,{children:"b \\in G"})," such that ",e.jsx(i,{children:"ab = ba = e"})]})]}),e.jsxs("p",{className:"mt-2",children:["The element ",e.jsx(i,{children:"e"})," is called the ",e.jsx("strong",{children:"identity"})," of ",e.jsx(i,{children:"G"}),", and ",e.jsx(i,{children:"b"})," is called the ",e.jsx("strong",{children:"inverse"})," of ",e.jsx(i,{children:"a"}),", denoted ",e.jsx(i,{children:"a^{-1}"}),"."]})]}),e.jsx(n,{title:"Abelian Group",children:e.jsxs("p",{children:["A group ",e.jsx(i,{children:"G"})," is called ",e.jsx("strong",{children:"Abelian"})," (or commutative) if ",e.jsx(i,{children:"ab = ba"})," for all ",e.jsx(i,{children:"a, b \\in G"}),"."]})}),e.jsxs(n,{title:"Ring",children:[e.jsxs("p",{children:["A non-empty set ",e.jsx(i,{children:"R"})," with two binary compositions (addition and multiplication) is called a ",e.jsx("strong",{children:"ring"})," if:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx(i,{children:"R"})," is an Abelian group with respect to addition"]}),e.jsxs("li",{children:["Multiplication is associative: ",e.jsx(i,{children:"(ab)c = a(bc)"})," for all ",e.jsx(i,{children:"a, b, c \\in R"})]}),e.jsxs("li",{children:["The distributive laws hold: ",e.jsx(i,{children:"a(b + c) = ab + ac"})," and ",e.jsx(i,{children:"(a + b)c = ac + bc"})]})]}),e.jsxs("p",{className:"mt-2",children:["A ring is ",e.jsx("strong",{children:"commutative"})," if ",e.jsx(i,{children:"ab = ba"})," for all ",e.jsx(i,{children:"a, b \\in R"}),". A ring with an element ",e.jsx(i,{children:"1 \\in R"})," such that ",e.jsx(i,{children:"1a = a = a1"})," for all ",e.jsx(i,{children:"a \\in R"})," is called a ",e.jsx("strong",{children:"ring with identity"}),"."]})]}),e.jsxs(n,{title:"Field",children:[e.jsxs("p",{children:["A set ",e.jsx(i,{children:"F"})," having at least two elements with two compositions (addition and multiplication) is called a ",e.jsx("strong",{children:"field"})," if:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx(i,{children:"F"})," is a commutative ring with identity"]}),e.jsxs("li",{children:["Every non-zero element of ",e.jsx(i,{children:"F"})," is invertible with respect to multiplication"]})]}),e.jsxs("p",{className:"mt-2",children:["The set ",e.jsx(i,{children:"F^*"})," of all non-zero elements of ",e.jsx(i,{children:"F"})," forms an Abelian group under multiplication."]})]}),e.jsx("h3",{children:"The Binary Field"}),e.jsxs("p",{children:["Of special importance in coding theory is the ",e.jsx("strong",{children:"binary field"}),", denoted ",e.jsx(i,{children:"\\mathbb{B}"})," or ",e.jsx(i,{children:"\\mathbb{F}_2"}),"."]}),e.jsxs(n,{title:"Binary Field",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"binary field"})," ",e.jsx(i,{children:"\\mathbb{B} = \\{0, 1\\}"})," has addition and multiplication defined modulo 2:"]}),e.jsxs("div",{className:"grid grid-cols-2 gap-4 mt-4",children:[e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{className:"font-semibold text-primary-400 mb-2",children:"Addition"}),e.jsx(s,{children:"\\begin{array}{c|cc} + & 0 & 1 \\\\ \\hline 0 & 0 & 1 \\\\ 1 & 1 & 0 \\end{array}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{className:"font-semibold text-primary-400 mb-2",children:"Multiplication"}),e.jsx(s,{children:"\\begin{array}{c|cc} \\times & 0 & 1 \\\\ \\hline 0 & 0 & 0 \\\\ 1 & 0 & 1 \\end{array}"})]})]}),e.jsxs("p",{className:"mt-2",children:["Note that ",e.jsx(i,{children:"1 + 1 = 0"})," in this field, so every element is its own additive inverse."]})]}),e.jsxs("p",{children:["Let ",e.jsx(i,{children:"\\mathbb{B}^n"})," denote the set of all ordered ",e.jsx(i,{children:"n"}),"-tuples (or sequences of length ",e.jsx(i,{children:"n"}),") with entries in ",e.jsx(i,{children:"\\mathbb{B}"}),". We define addition component-wise: if ",e.jsx(i,{children:"a = a_1a_2\\cdots a_n"})," and ",e.jsx(i,{children:"b = b_1b_2\\cdots b_n"}),", then:"]}),e.jsx(s,{children:"a + b = c_1c_2\\cdots c_n \\text{ where } c_i = a_i + b_i"}),e.jsxs("p",{children:["With this composition, ",e.jsx(i,{children:"\\mathbb{B}^n"})," becomes an Abelian group. The zero sequence is the identity, and every element is its own inverse."]}),e.jsx("h3",{children:"Block Codes and Code Words"}),e.jsxs(n,{title:"Binary Block Code",children:[e.jsxs("p",{children:["A ",e.jsxs("strong",{children:["binary block ",e.jsx(i,{children:"(m, n)"}),"-code"]})," consists of:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["An ",e.jsx("strong",{children:"encoding function"})," ",e.jsx(i,{children:"E: \\mathbb{B}^m \\to \\mathbb{B}^n"})]}),e.jsxs("li",{children:["A ",e.jsx("strong",{children:"decoding function"})," ",e.jsx(i,{children:"D: \\mathbb{B}^n \\to \\mathbb{B}^m"})]})]}),e.jsxs("p",{className:"mt-2",children:["The elements of ",e.jsx(i,{children:"\\text{Im}(E)"})," (the image of ",e.jsx(i,{children:"E"}),") are called ",e.jsx("strong",{children:"code words"}),"."]})]}),e.jsx("h3",{children:"Distance and Weight Functions"}),e.jsxs(n,{title:"Hamming Distance",children:[e.jsxs("p",{children:["For ",e.jsx(i,{children:"a, b \\in \\mathbb{B}^n"}),", the ",e.jsx("strong",{children:"distance"})," ",e.jsx(i,{children:"d(a, b)"})," between ",e.jsx(i,{children:"a"})," and ",e.jsx(i,{children:"b"})," is defined as:"]}),e.jsx(s,{children:"d(a, b) = \\sum_{i=1}^{n} x_i \\quad \\text{where } x_i = \\begin{cases} 0 & \\text{if } a_i = b_i \\\\ 1 & \\text{if } a_i \\neq b_i \\end{cases}"}),e.jsxs("p",{className:"mt-2",children:["In other words, ",e.jsx(i,{children:"d(a, b)"})," counts the number of positions where ",e.jsx(i,{children:"a"})," and ",e.jsx(i,{children:"b"})," differ."]})]}),e.jsxs(c,{title:"Computing Hamming Distance",children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"a = 10011011"})," and ",e.jsx(i,{children:"b = 11001101"}),"."]}),e.jsx("p",{className:"mt-2",children:"Comparing position by position:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Position 1: ",e.jsx(i,{children:"a_1 = 1 = b_1"})," (same)"]}),e.jsxs("li",{children:["Position 2: ",e.jsx(i,{children:"a_2 = 0 \\neq 1 = b_2"})," (different)"]}),e.jsxs("li",{children:["Position 3: ",e.jsx(i,{children:"a_3 = 0 = b_3"})," (same)"]}),e.jsxs("li",{children:["Position 4: ",e.jsx(i,{children:"a_4 = 1 \\neq 0 = b_4"})," (different)"]}),e.jsxs("li",{children:["Position 5: ",e.jsx(i,{children:"a_5 = 1 = b_5"})," (same)"]}),e.jsxs("li",{children:["Position 6: ",e.jsx(i,{children:"a_6 = 0 \\neq 1 = b_6"})," (different)"]}),e.jsxs("li",{children:["Position 7: ",e.jsx(i,{children:"a_7 = 1 \\neq 0 = b_7"})," (different)"]}),e.jsxs("li",{children:["Position 8: ",e.jsx(i,{children:"a_8 = 1 = b_8"})," (same)"]})]}),e.jsxs("p",{className:"mt-2 text-emerald-400",children:["Therefore, ",e.jsx(i,{children:"d(a, b) = 4"}),"."]})]}),e.jsx(n,{title:"Weight Function",children:e.jsxs("p",{children:["For ",e.jsx(i,{children:"a \\in \\mathbb{B}^n"}),", the ",e.jsx("strong",{children:"weight"})," ",e.jsx(i,{children:"\\text{wt}(a)"})," of ",e.jsx(i,{children:"a"})," is the number of non-zero components in the sequence."]})}),e.jsxs(r,{title:"Distance-Weight Relationship",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"a = a_1a_2\\cdots a_n"})," and ",e.jsx(i,{children:"b = b_1b_2\\cdots b_n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For any ",e.jsx(i,{children:"i"})," with ",e.jsx(i,{children:"1 \\leq i \\leq n"}),":"]}),e.jsx(s,{children:"a_i + b_i = 1 \\iff a_i \\neq b_i"}),e.jsxs("p",{className:"mt-2",children:["Hence the pair ",e.jsx(i,{children:"(a_i, b_i)"})," contributes 1 to ",e.jsx(i,{children:"\\text{wt}(a + b)"})," if and only if it contributes 1 to ",e.jsx(i,{children:"d(a, b)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Therefore, ",e.jsx(i,{children:"d(a, b) = \\text{wt}(a + b)"}),"."]})]}),children:[e.jsxs("p",{children:["For ",e.jsx(i,{children:"a, b \\in \\mathbb{B}^n"}),":"]}),e.jsx(s,{children:"d(a, b) = \\text{wt}(a + b)"})]}),e.jsxs(r,{title:"Triangle Inequality",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"a = a_1\\cdots a_n"}),", ",e.jsx(i,{children:"b = b_1\\cdots b_n"}),", and ",e.jsx(i,{children:"c = c_1\\cdots c_n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For any ",e.jsx(i,{children:"i"}),", define ",e.jsx(i,{children:"d(a_i, b_i) = 1"})," if ",e.jsx(i,{children:"a_i \\neq b_i"})," and 0 otherwise. Similarly for ",e.jsx(i,{children:"d(a_i, c_i)"})," and ",e.jsx(i,{children:"d(b_i, c_i)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(i,{children:"a_i = b_i"}),", then ",e.jsx(i,{children:"d(a_i, b_i) = 0 \\leq d(a_i, c_i) + d(b_i, c_i)"})," trivially."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(i,{children:"a_i \\neq b_i"}),", then ",e.jsx(i,{children:"d(a_i, b_i) = 1"}),". If ",e.jsx(i,{children:"a_i = c_i"}),", then ",e.jsx(i,{children:"b_i \\neq c_i"}),", so ",e.jsx(i,{children:"d(b_i, c_i) = 1"}),". Similarly, if ",e.jsx(i,{children:"b_i = c_i"}),", then ",e.jsx(i,{children:"d(a_i, c_i) = 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["In either case, ",e.jsx(i,{children:"d(a_i, b_i) \\leq d(a_i, c_i) + d(b_i, c_i)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Summing over all ",e.jsx(i,{children:"i"})," gives the result."]})]}),children:[e.jsxs("p",{children:["For ",e.jsx(i,{children:"a, b, c \\in \\mathbb{B}^n"}),":"]}),e.jsx(s,{children:"d(a, b) \\leq d(a, c) + d(b, c)"})]}),e.jsx("h3",{children:"Error Detection and Correction"}),e.jsxs(n,{title:"Nearest-Neighbor Decoding",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"nearest-neighbor decoding principle"})," states:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["If a received word ",e.jsx(i,{children:"r"})," is a code word, decode it as ",e.jsx(i,{children:"D(r) = r"})]}),e.jsxs("li",{children:["If ",e.jsx(i,{children:"r"})," is not a code word, find the code word ",e.jsx(i,{children:"a"})," with minimum ",e.jsx(i,{children:"d(a, r)"})]}),e.jsxs("li",{children:["If this code word is unique, decode ",e.jsx(i,{children:"D(r) = a"})]}),e.jsxs("li",{children:["If multiple code words achieve the minimum distance, declare a ",e.jsx("strong",{children:"decoding failure"})]})]})]}),e.jsx(r,{title:"Error Detection Criterion",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"C"})," be the set of all code words of length ",e.jsx(i,{children:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Sufficiency:"})," Suppose ",e.jsx(i,{children:"d(b, b') \\geq k + 1"})," for all ",e.jsx(i,{children:"b, b' \\in C"}),". Let ",e.jsx(i,{children:"b \\in C"})," be transmitted and an error word ",e.jsx(i,{children:"e"})," with ",e.jsx(i,{children:"\\text{wt}(e) \\leq k"})," is added."]}),e.jsxs("p",{className:"mt-2",children:["The received word is ",e.jsx(i,{children:"b + e"}),", and:"]}),e.jsx(s,{children:"d(b + e, b) = \\text{wt}(e) \\leq k"}),e.jsxs("p",{className:"mt-2",children:["Since the minimum distance is at least ",e.jsx(i,{children:"k + 1"}),", ",e.jsx(i,{children:"b + e"})," cannot be a code word. Thus the error is detected."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Necessity:"})," Suppose the code detects all sets of ",e.jsx(i,{children:"k"})," or fewer errors. If ",e.jsx(i,{children:"d(b, b') \\leq k"})," for some ",e.jsx(i,{children:"b, b' \\in C"}),", let ",e.jsx(i,{children:"e = b + b'"}),". Then ",e.jsx(i,{children:"\\text{wt}(e) \\leq k"})," and ",e.jsx(i,{children:"b + e = b'"})," is a code word, so the error goes undetected. Contradiction."]})]}),children:e.jsxs("p",{children:["For a code to detect all sets of ",e.jsx(i,{children:"k"})," or fewer errors, it is necessary and sufficient that the minimum distance between any two code words be at least ",e.jsx(i,{children:"k + 1"}),"."]})}),e.jsx(r,{title:"Error Correction Criterion",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Suppose ",e.jsx(i,{children:"d(a, b) \\leq 2k"})," for code words ",e.jsx(i,{children:"a"})," and ",e.jsx(i,{children:"b"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(i,{children:"\\text{wt}(a + b) = l \\leq 2k"}),". We can find words ",e.jsx(i,{children:"e, e'"})," with",e.jsx(i,{children:"\\text{wt}(e) \\leq k"}),", ",e.jsx(i,{children:"\\text{wt}(e') \\leq k"}),", and ",e.jsx(i,{children:"a + b = e + e'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(i,{children:"a + e = b + e'"}),". If ",e.jsx(i,{children:"b"})," is transmitted with error ",e.jsx(i,{children:"e'"}),":"]}),e.jsx(s,{children:"d(b + e', a) = d(a + e, a) \\leq d(b + e', b)"}),e.jsxs("p",{className:"mt-2",children:["By nearest-neighbor decoding, ",e.jsx(i,{children:"b + e'"})," may be decoded incorrectly."]}),e.jsxs("p",{className:"mt-2",children:["Conversely, if the minimum distance is at least ",e.jsx(i,{children:"2k + 1"})," and ",e.jsx(i,{children:"\\text{wt}(e) \\leq k"}),", for any code word ",e.jsx(i,{children:"b^* \\neq b"}),":"]}),e.jsx(s,{children:"d(b + e, b^*) = \\text{wt}(b + b^* + e) \\geq k + 1 > k \\geq d(b + e, b)"}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(i,{children:"b"})," is uniquely the nearest code word to ",e.jsx(i,{children:"b + e"}),"."]})]}),children:e.jsxs("p",{children:["For a code to correct all sets of ",e.jsx(i,{children:"k"})," or fewer errors, it is necessary and sufficient that the minimum distance between code words be at least ",e.jsx(i,{children:"2k + 1"}),"."]})}),e.jsxs(c,{title:"(2, 3) Parity Check Code",children:[e.jsx("p",{children:"Consider the encoding function:"}),e.jsx(s,{children:"00 \\to 000, \\quad 01 \\to 011, \\quad 10 \\to 101, \\quad 11 \\to 110"}),e.jsxs("p",{className:"mt-2",children:["The code words are ",e.jsx(i,{children:"C = \\{000, 011, 101, 110\\}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The three possible error vectors of weight 1 are: ",e.jsx(i,{children:"001, 010, 100"}),". Adding any one of these to any code word does not yield a code word."]}),e.jsx("p",{className:"mt-2 text-emerald-400",children:"Thus, every single error is detected by this code."}),e.jsxs("p",{className:"mt-2",children:["However, if ",e.jsx(i,{children:"011"})," is transmitted and error ",e.jsx(i,{children:"100"})," is added, the received word is ",e.jsx(i,{children:"111"}),". This is equidistant from three code words, so this single error cannot be corrected."]})]}),e.jsxs(n,{title:"Triple Repetition Code",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"(m, 3m) triple repetition code"})," has encoding function ",e.jsx(i,{children:"E: \\mathbb{B}^m \\to \\mathbb{B}^{3m}"})," defined by:"]}),e.jsx(s,{children:"E(a_1a_2\\cdots a_m) = a_1a_2\\cdots a_m a_1a_2\\cdots a_m a_1a_2\\cdots a_m"}),e.jsxs("p",{className:"mt-2",children:["Each message word is repeated three times. If ",e.jsx(i,{children:"a \\neq b"}),", then ",e.jsx(i,{children:"d(a, b) \\geq 1"}),", so ",e.jsx(i,{children:"d(E(a), E(b)) \\geq 3"}),"."]}),e.jsx("p",{className:"mt-2 text-emerald-400",children:"Thus, the triple repetition code can detect any two errors and correct any single error."})]}),e.jsxs(d,{type:"success",children:[e.jsx("strong",{children:"Section Summary:"})," We have established the algebraic foundations of coding theory, including groups, rings, and fields. The binary field ",e.jsx(i,{children:"\\mathbb{B}"})," is fundamental for binary codes. The Hamming distance measures how different two words are, and the minimum distance of a code determines its error-detecting and error-correcting capabilities. A code with minimum distance ",e.jsx(i,{children:"d"})," can detect ",e.jsx(i,{children:"d - 1"})," errors and correct ",e.jsx(i,{children:"\\lfloor (d-1)/2 \\rfloor"})," errors."]})]})}export{p as default};
