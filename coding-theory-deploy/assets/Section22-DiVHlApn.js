import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as d,D as n,T as l,C as r,E as c}from"./Callout-DA0JknRv.js";import{I as s,M as i}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function g(){return e.jsxs(d,{sectionId:22,children:[e.jsx("p",{children:"In this section, we study binary cyclic codes that are equal to their duals. These self-dual codes have special properties and are important in both theory and applications, including connections to lattices and cryptography."}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Self-Dual Codes"}),e.jsxs(n,{title:"Self-Dual Code",children:[e.jsxs("p",{children:["A linear code ",e.jsx(s,{children:"mathscr{C}"})," is ",e.jsx("strong",{children:"self-dual"})," if ",e.jsx(s,{children:"mathscr{C} = mathscr{C}^perp"}),", where ",e.jsx(s,{children:"mathscr{C}^perp"})," is the dual code."]}),e.jsxs("p",{className:"mt-2",children:["A code is ",e.jsx("strong",{children:"self-orthogonal"})," if ",e.jsx(s,{children:"mathscr{C} subseteq mathscr{C}^perp"}),"."]})]}),e.jsx(l,{title:"Dimension of Self-Dual Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["For any linear code ",e.jsx(s,{children:"mathscr{C}"})," of length ",e.jsx(s,{children:"n"})," and dimension ",e.jsx(s,{children:"k"}),", the dual ",e.jsx(s,{children:"mathscr{C}^perp"})," has dimension ",e.jsx(s,{children:"n - k"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"mathscr{C} = mathscr{C}^perp"}),", then ",e.jsx(s,{children:"k = n - k"}),", which implies ",e.jsx(s,{children:"k = n/2"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Therefore ",e.jsx(s,{children:"n"})," must be even, and ",e.jsx(s,{children:"mathscr{C}"})," is an ",e.jsx(s,{children:"[n, n/2]"})," code."]})]}),children:e.jsxs("p",{children:["If ",e.jsx(s,{children:"mathscr{C}"})," is a self-dual code of length ",e.jsx(s,{children:"n"}),", then ",e.jsx(s,{children:"n"})," must be even, and ",e.jsx(s,{children:"mathscr{C}"})," has dimension ",e.jsx(s,{children:"n/2"}),"."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Conditions for Self-Dual Cyclic Codes"}),e.jsxs(n,{title:"Reciprocal Polynomial",children:[e.jsxs("p",{children:["For a polynomial ",e.jsx(s,{children:"f(X) = a_0 + a_1 X + \\cdots + a_r X^r"})," of degree ",e.jsx(s,{children:"r"}),", the ",e.jsx("strong",{children:"reciprocal polynomial"})," is:"]}),e.jsx(i,{children:"f^*(X) = X^r f(X^{-1}) = a_r + a_{r-1}X + \\cdots + a_0 X^r"}),e.jsxs("p",{className:"mt-2",children:["A polynomial is ",e.jsx("strong",{children:"self-reciprocal"})," if ",e.jsx(s,{children:"f(X) = f^*(X)"}),"."]})]}),e.jsxs(l,{title:"Dual of a Cyclic Code",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathscr{C}"})," be a cyclic code of length ",e.jsx(s,{children:"n"})," with generator polynomial ",e.jsx(s,{children:"g(X)"})," of degree ",e.jsx(s,{children:"r"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The check polynomial is ",e.jsx(s,{children:"h(X) = (X^n - 1)/g(X)"})," of degree ",e.jsx(s,{children:"n - r"}),"."]}),e.jsxs("p",{className:"mt-2",children:["A codeword ",e.jsx(s,{children:"c(X) in mathscr{C}"})," can be written as ",e.jsx(s,{children:"c(X) = m(X)g(X)"}),". For any polynomial ",e.jsx(s,{children:"a(X)"}),", we have ",e.jsx(s,{children:"\\langle a, c \\rangle = 0"})," for all ",e.jsx(s,{children:"c in mathscr{C}"})," if and only if ",e.jsx(s,{children:"a(X) cdot c(X) equiv 0 pmod{X^n - 1}"})," gives zero constant term for all choices of ",e.jsx(s,{children:"m(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This happens precisely when ",e.jsx(s,{children:"h^*(X) | a(X)"}),", where ",e.jsx(s,{children:"h^*(X)"})," is the reciprocal of ",e.jsx(s,{children:"h(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Thus the dual code ",e.jsx(s,{children:"mathscr{C}^perp"})," has generator polynomial:"]}),e.jsx(i,{children:"g^\\perp(X) = \\frac{h^*(X)}{h^*(0)} = X^{n-r} h(X^{-1}) / h(0)"}),e.jsx("p",{className:"mt-2",children:"made monic by dividing by the leading coefficient."})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathscr{C}"})," be a cyclic code of length ",e.jsx(s,{children:"n"})," with generator polynomial ",e.jsx(s,{children:"g(X)"})," and check polynomial ",e.jsx(s,{children:"h(X) = (X^n - 1)/g(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The dual code ",e.jsx(s,{children:"mathscr{C}^perp"})," is cyclic with generator polynomial:"]}),e.jsx(i,{children:"g^\\perp(X) = \\frac{X^{\\deg h} h(X^{-1})}{h(0)}"}),e.jsx("p",{className:"mt-2",children:"which is the monic reciprocal of the check polynomial."})]}),e.jsxs(l,{title:"Condition for Self-Dual Binary Cyclic Code",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"mathscr{C} = mathscr{C}^perp"}),", we need ",e.jsx(s,{children:"g(X) = g^\\perp(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["By the previous theorem, ",e.jsx(s,{children:"g^\\perp(X)"})," is the monic reciprocal of ",e.jsx(s,{children:"h(X)"}),". So we need ",e.jsx(s,{children:"g(X)"})," to equal ",e.jsx(s,{children:"h^*(X)"})," up to a scalar."]}),e.jsxs("p",{className:"mt-2",children:["From ",e.jsx(s,{children:"g(X) h(X) = X^n - 1"}),", taking reciprocals:"]}),e.jsx(i,{children:"g^*(X) h^*(X) = X^n (X^{-n} - 1) = 1 - X^n = -(X^n - 1)"}),e.jsxs("p",{className:"mt-2",children:["Over the binary field, ",e.jsx(s,{children:"-1 = 1"}),", so ",e.jsx(s,{children:"g^*(X) h^*(X) = X^n - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{children:"g(X) = h^*(X)"})," (up to a scalar), we need ",e.jsx(s,{children:"g^*(X) = g(X)"})," and ",e.jsx(s,{children:"h(X) = h^*(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Actually, for self-duality we need ",e.jsx(s,{children:"g(X) \\cdot g^*(X) = X^n - 1"}),". This means ",e.jsx(s,{children:"g(X)"})," and ",e.jsx(s,{children:"g^*(X)"})," together account for all factors of ",e.jsx(s,{children:"X^n - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The dimension condition ",e.jsx(s,{children:"\\deg g = n/2"})," follows from self-duality."]})]}),children:[e.jsxs("p",{children:["A binary cyclic code ",e.jsx(s,{children:"mathscr{C}"})," with generator polynomial ",e.jsx(s,{children:"g(X)"})," is self-dual if and only if:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx(s,{children:"n"})," is even"]}),e.jsx("li",{children:e.jsx(s,{children:"\\deg g(X) = n/2"})}),e.jsxs("li",{children:[e.jsx(s,{children:"g(X) \\cdot g^*(X) = X^n - 1"})," (where ",e.jsx(s,{children:"g^*(X)"})," is the reciprocal)"]})]})]}),e.jsxs(r,{type:"info",title:"Factorization Constraints",children:[e.jsxs("p",{children:["For a self-dual binary cyclic code to exist, the factorization of ",e.jsx(s,{children:"X^n - 1"})," must have a special structure. Each irreducible factor ",e.jsx(s,{children:"f(X)"})," either:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Is self-reciprocal: ",e.jsx(s,{children:"f(X) = f^*(X)"}),", and appears with even multiplicity in ",e.jsx(s,{children:"g(X)"}),", or"]}),e.jsxs("li",{children:["Pairs with its reciprocal ",e.jsx(s,{children:"f^*(X) \\neq f(X)"}),", and exactly one of ",e.jsx(s,{children:"f, f^*"})," divides ",e.jsx(s,{children:"g(X)"})]})]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Examples of Self-Dual Binary Cyclic Codes"}),e.jsxs(c,{title:"Non-existence for Small Lengths",children:[e.jsx("p",{children:"Let us check whether self-dual binary cyclic codes exist for small even lengths."}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Length 2:"})," ",e.jsx(s,{children:"X^2 - 1 = (X - 1)(X + 1) = (X + 1)^2"})," over ",e.jsx(s,{children:"mathbb{B}"}),". For a self-dual code, we need ",e.jsx(s,{children:"\\deg g = 1"}),". The only option is ",e.jsx(s,{children:"g(X) = X + 1"}),", but ",e.jsx(s,{children:"g^*(X) = X + 1 = g(X)"})," and ",e.jsx(s,{children:"g(X)^2 \\neq X^2 + 1"}),". No self-dual code exists."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Length 4:"})," ",e.jsx(s,{children:"X^4 - 1 = (X + 1)^4"})," over ",e.jsx(s,{children:"mathbb{B}"}),". For ",e.jsx(s,{children:"\\deg g = 2"}),", we'd need ",e.jsx(s,{children:"g(X) = (X + 1)^2 = X^2 + 1"}),". Then ",e.jsx(s,{children:"g^*(X) = X^2 + 1 = g(X)"}),", and ",e.jsx(s,{children:"g(X)^2 = (X + 1)^4 = X^4 + 1"}),". This works. The code has generator ",e.jsx(s,{children:"g(X) = X^2 + 1"}),"."]})]}),e.jsxs(c,{title:"Self-Dual Code of Length 8",children:[e.jsxs("p",{children:["Over ",e.jsx(s,{children:"mathbb{B}"}),", we have:"]}),e.jsx(i,{children:"X^8 - 1 = (X + 1)^8"}),e.jsxs("p",{className:"mt-2",children:["For a self-dual code, we need ",e.jsx(s,{children:"\\deg g = 4"}),". Taking ",e.jsx(s,{children:"g(X) = (X + 1)^4 = X^4 + 1"}),":"]}),e.jsx(i,{children:"g^*(X) = X^4 \\cdot (X^{-4} + 1) = 1 + X^4 = g(X)"}),e.jsxs("p",{className:"mt-2",children:["And ",e.jsx(s,{children:"g(X) \\cdot g^*(X) = (X^4 + 1)^2 = X^8 + 1"}),". So this is a self-dual [8, 4] binary cyclic code."]}),e.jsxs("p",{className:"mt-2",children:["The codewords are all polynomials divisible by ",e.jsx(s,{children:"X^4 + 1 = (X + 1)^4"}),". This is the extended Hamming code."]})]}),e.jsx(l,{title:"Existence Criterion",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The key observation is that ",e.jsx(s,{children:"X^n - 1"})," over ",e.jsx(s,{children:"mathbb{B}"})," factors as:"]}),e.jsx(i,{children:"X^n - 1 = \\prod_{d | n} \\Phi_d(X)"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"\\Phi_d(X)"})," is the ",e.jsx(s,{children:"d"}),"-th cyclotomic polynomial."]}),e.jsxs("p",{className:"mt-2",children:["An irreducible factor ",e.jsx(s,{children:"f(X)"})," of ",e.jsx(s,{children:"\\Phi_d(X)"})," over ",e.jsx(s,{children:"mathbb{B}"})," is self-reciprocal if and only if ",e.jsx(s,{children:"-1"})," is in the same cyclotomic coset modulo ",e.jsx(s,{children:"d"})," as 1, i.e., ",e.jsx(s,{children:"2^k equiv -1 pmod{d}"})," for some ",e.jsx(s,{children:"k"}),"."]}),e.jsxs("p",{className:"mt-2",children:["When ",e.jsx(s,{children:"n = 2^m"}),", all irreducible factors of ",e.jsx(s,{children:"X^n - 1 = (X + 1)^n"})," are just ",e.jsx(s,{children:"X + 1"})," with multiplicity ",e.jsx(s,{children:"n"}),". Taking ",e.jsx(s,{children:"g(X) = (X + 1)^{n/2}"})," gives a self-dual code."]})]}),children:e.jsxs("p",{children:["A self-dual binary cyclic code of length ",e.jsx(s,{children:"n"})," exists if ",e.jsx(s,{children:"n"})," is a power of 2. In this case, ",e.jsx(s,{children:"X^n - 1 = (X + 1)^n"})," over ",e.jsx(s,{children:"mathbb{B}"}),", and ",e.jsx(s,{children:"g(X) = (X + 1)^{n/2}"})," generates the self-dual code."]})}),e.jsxs(c,{title:"Self-Dual Code of Length 16",children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"n = 16 = 2^4"}),", we have ",e.jsx(s,{children:"X^{16} - 1 = (X + 1)^{16}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The self-dual code has generator ",e.jsx(s,{children:"g(X) = (X + 1)^8"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Expanding: ",e.jsx(s,{children:"(X + 1)^8 = X^8 + 1"})," over ",e.jsx(s,{children:"mathbb{B}"})," (using the fact that ",e.jsx(s,{children:"\binom{8}{k}"})," is even for ",e.jsxs(s,{children:["0 ","<"," k ","<"," 8"]}),")."]}),e.jsx("p",{className:"mt-2",children:"This [16, 8] self-dual code is the second-order Reed-Muller code RM(1, 4)."})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Properties of Self-Dual Cyclic Codes"}),e.jsxs(l,{title:"Weight Properties",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["For a self-dual code ",e.jsx(s,{children:"mathscr{C}"}),", every codeword ",e.jsx(s,{children:"c"})," satisfies ",e.jsx(s,{children:"\\langle c, c \\rangle = 0"}),", which means ",e.jsx(s,{children:"sum_{i=0}^{n-1} c_i^2 = 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Over ",e.jsx(s,{children:"mathbb{B}"}),", we have ",e.jsx(s,{children:"c_i^2 = c_i"}),", so ",e.jsx(s,{children:"\\sum c_i = 0"}),", meaning the Hamming weight ",e.jsx(s,{children:"w(c)"})," is even."]}),e.jsxs("p",{className:"mt-2",children:["In a cyclic code, the all-ones vector ",e.jsx(s,{children:"mathbf{1}"})," is a codeword if and only if ",e.jsx(s,{children:"g(X)"})," divides ",e.jsx(s,{children:"1 + X + cdots + X^{n-1} = (X^n - 1)/(X - 1)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For self-dual codes with ",e.jsx(s,{children:"g(X) = (X + 1)^{n/2}"}),", we have ",e.jsx(s,{children:"mathbf{1} in mathscr{C}"})," when ",e.jsx(s,{children:"n/2 \\leq n - 1"}),", which is always true for ",e.jsx(s,{children:"n \\geq 2"}),"."]})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathscr{C}"})," be a binary self-dual cyclic code. Then:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsx("li",{children:"Every codeword has even Hamming weight"}),e.jsxs("li",{children:["The all-ones vector ",e.jsx(s,{children:"mathbf{1} = (1, 1, ldots, 1)"})," is in ",e.jsx(s,{children:"mathscr{C}"})]})]})]}),e.jsxs(n,{title:"Type I and Type II Codes",children:[e.jsx("p",{children:"A binary self-dual code is called:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Type I"})," (or singly even): if all codewords have even weight"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Type II"})," (or doubly even): if all codewords have weight divisible by 4"]})]}),e.jsxs("p",{className:"mt-2",children:["Type II codes exist only when ",e.jsx(s,{children:"n equiv 0 pmod{8}"}),"."]})]}),e.jsxs(c,{title:"Type II Self-Dual Cyclic Code",children:[e.jsxs("p",{children:["The [8, 4] self-dual binary cyclic code with ",e.jsx(s,{children:"g(X) = X^4 + 1 = (X + 1)^4"})," has codewords with weights 0, 4, and 8 only."]}),e.jsxs("p",{className:"mt-2",children:["To verify: the code consists of all multiples of ",e.jsx(s,{children:"X^4 + 1"}),". The non-zero codewords of minimum weight come from:"]}),e.jsx("ul",{className:"list-disc list-inside mt-2 space-y-1",children:e.jsxs("li",{children:[e.jsx(s,{children:"1 \\cdot (X^4 + 1) = X^4 + 1 \\to (1, 0, 0, 0, 1, 0, 0, 0)"}),", weight 2"]})}),e.jsxs("p",{className:"mt-2",children:["Wait, this gives weight 2, not 4. Let me recalculate. Actually, for cyclic codes, we need to check all scalar multiples in ",e.jsx(s,{children:"R_n"}),":"]}),e.jsx(i,{children:`\\begin{aligned}
&(X^4 + 1) \\cdot 1 = X^4 + 1 \\\\
&(X^4 + 1) \\cdot X = X^5 + X \\\\
&(X^4 + 1) \\cdot X^2 = X^6 + X^2 \\\\
&(X^4 + 1) \\cdot X^3 = X^7 + X^3
\\end{aligned}`}),e.jsxs("p",{className:"mt-2",children:["Each of these has weight 2. However, sums like ",e.jsx(s,{children:"(X^4 + 1)(1 + X + X^2 + X^3)"})," give weight 8 (the all-ones codeword). The code is Type I, not Type II."]})]}),e.jsxs(r,{type:"note",title:"Rarity of Self-Dual Cyclic Codes",children:[e.jsxs("p",{children:["Self-dual binary cyclic codes are relatively rare. The main family consists of codes of length ",e.jsx(s,{children:"n = 2^m"})," with generator ",e.jsx(s,{children:"(X + 1)^{2^{m-1}}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For other lengths, the existence of self-dual cyclic codes depends on delicate number-theoretic conditions involving the factorization of ",e.jsx(s,{children:"X^n - 1"})," and the structure of cyclotomic cosets."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Idempotent Characterization"}),e.jsx(l,{title:"Idempotent of Self-Dual Code",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"e(X)"})," be the idempotent generating ",e.jsx(s,{children:"mathscr{C}"}),". The idempotent of ",e.jsx(s,{children:"mathscr{C}^perp"})," is ",e.jsx(s,{children:"e^perp(X) = X^{n-1}(1 - e(X^{-1}))"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{children:"mathscr{C} = mathscr{C}^perp"}),", we need ",e.jsx(s,{children:"e(X) = e^\\perp(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"e(X)"})," is self-reciprocal (i.e., ",e.jsx(s,{children:"e(X) = X^{n-1}e(X^{-1})"}),"), then ",e.jsx(s,{children:"e^\\perp(X) = 1 - e(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The condition ",e.jsx(s,{children:"e(X) = 1 - e(X)"})," gives ",e.jsx(s,{children:"2e(X) = 1"}),". Over ",e.jsx(s,{children:"mathbb{B}"}),", this means ",e.jsx(s,{children:"0 = 1"}),", a contradiction unless we interpret it differently."]}),e.jsx("p",{className:"mt-2",children:"The resolution is that for self-dual codes, the idempotent structure reflects a symmetric pairing of primitive idempotents under the reciprocal map."})]}),children:e.jsxs("p",{children:["Let ",e.jsx(s,{children:"mathscr{C}"})," be a binary cyclic code with idempotent ",e.jsx(s,{children:"e(X)"}),". Then ",e.jsx(s,{children:"mathscr{C}"})," is self-dual if and only if the primitive idempotents summing to ",e.jsx(s,{children:"e(X)"})," are paired symmetrically under the reciprocal operation: for each primitive idempotent ",e.jsx(s,{children:"e_i(X)"})," in the sum, its reciprocal ",e.jsx(s,{children:"e_i^*(X)"})," is not in the sum."]})}),e.jsxs(c,{title:"Complete Classification for Length 8",children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"n = 8"}),", we have ",e.jsx(s,{children:"X^8 - 1 = (X + 1)^8"}),". There is only one primitive idempotent (corresponding to the unique irreducible factor ",e.jsx(s,{children:"X + 1"}),"), which is self-reciprocal."]}),e.jsxs("p",{className:"mt-2",children:["The cyclic codes of length 8 are generated by ",e.jsx(s,{children:"(X + 1)^k"})," for ",e.jsx(s,{children:"k = 0, 1, \\ldots, 8"}),". The self-dual code corresponds to ",e.jsx(s,{children:"k = 4"}),", giving:"]}),e.jsx(i,{children:"g(X) = (X + 1)^4 = X^4 + 1"}),e.jsx("p",{className:"mt-2",children:"This [8, 4] code has generator matrix (in systematic form after row operations):"}),e.jsx(i,{children:`\\mathbf{G} = \\begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 \\\\
0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\\\
0 & 0 & 1 & 0 & 0 & 1 & 1 & 0 \\\\
0 & 0 & 0 & 1 & 0 & 0 & 1 & 1
\\end{pmatrix}`})]}),e.jsx(r,{type:"success",title:"Applications of Self-Dual Codes",children:e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Lattices:"})," Self-dual codes give rise to integral lattices via Construction A, with applications in sphere packing."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Modular forms:"})," Weight enumerators of self-dual codes are connected to modular forms, providing bounds on minimum distance."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Quantum codes:"})," Self-dual classical codes can be used to construct quantum error-correcting codes."]})]})})]})}export{g as default};
