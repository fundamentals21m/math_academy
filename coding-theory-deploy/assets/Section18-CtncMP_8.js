import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as h,D as r,C as s,E as c,T as t}from"./Callout-BFDudfNm.js";import{I as n,M as i}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function p(){return e.jsxs(h,{sectionId:18,children:[e.jsxs("p",{children:["So far we have focused primarily on binary Hamming codes. However, Hamming codes can be defined over any finite field ",e.jsx(n,{children:"	ext{GF}(q)"}),". In this section, we extend the theory to non-binary alphabets."]}),e.jsx(r,{title:"Non-binary Hamming Code",children:e.jsxs("p",{children:["A Hamming code of length ",e.jsx(n,{children:"n = (q^m - 1)/(q - 1)"})," over ",e.jsx(n,{children:"	ext{GF}(q)"})," is defined to be the code given by an ",e.jsx(n,{children:"m \\times n"})," parity check matrix ",e.jsx(n,{children:"mathbf{H}"}),", the columns of which are all non-zero ",e.jsx(n,{children:"m"}),"-tuples over ",e.jsx(n,{children:"	ext{GF}(q)"})," with the ",e.jsx("strong",{children:"first non-zero entry in each column equal to 1"}),"."]})}),e.jsx(s,{type:"info",title:"Why Normalize Columns?",children:e.jsxs("p",{children:["The condition that the first non-zero entry in each column equals 1 ensures that no column is a scalar multiple of another. In the binary case, this condition is automatic since the only non-zero scalar is 1. For ",e.jsx(n,{children:"q {'>'} 2"}),", this normalization prevents redundancy and ensures single error correction."]})}),e.jsxs("p",{className:"mt-4",children:["There are ",e.jsx(n,{children:"m"})," columns in the parity check matrix ",e.jsx(n,{children:"mathbf{H}"})," that form the identity matrix ",e.jsx(n,{children:"mathbf{I}_m"})," (after a suitable permutation). It follows that the Hamming code given by ",e.jsx(n,{children:"mathbf{H}"})," is a vector space of dimension ",e.jsx(n,{children:"n - m"})," over ",e.jsx(n,{children:"	ext{GF}(q)"}),"."]}),e.jsxs(c,{title:"Ternary Hamming Code of Length 4",children:[e.jsxs("p",{children:["As ",e.jsx(n,{children:"4 = (3^2 - 1)/(3 - 1)"}),", the parity check matrix is a ",e.jsx(n,{children:"2 \\times 4"})," matrix given by:"]}),e.jsx(i,{children:"\\mathbf{H} = \\begin{pmatrix} 0 & 1 & 1 & 1 \\\\ 1 & 0 & 1 & 2 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["The columns represent the normalized non-zero 2-tuples over ",e.jsx(n,{children:"	ext{GF}(3)"}),"."]}),e.jsx("p",{className:"mt-2",children:"Applying a permutation to obtain canonical form and computing the corresponding generator matrix, we get:"}),e.jsx(i,{children:"\\mathbf{G} = \\begin{pmatrix} 1 & 1 & 1 & 0 \\\\ 2 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["All code words of this ",e.jsx(n,{children:"(2, 4)"})," ternary Hamming code are:"]}),e.jsx("div",{className:"my-4 font-mono text-sm bg-dark-800/50 p-4 rounded-lg",children:e.jsxs("table",{className:"w-full",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-600",children:[e.jsx("th",{className:"text-left py-1",children:"Message"}),e.jsx("th",{className:"text-left py-1",children:"Code word"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{children:"0 0"}),e.jsx("td",{children:"0 0 0 0"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"0 1"}),e.jsx("td",{children:"2 1 0 1"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"0 2"}),e.jsx("td",{children:"1 2 0 2"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"1 0"}),e.jsx("td",{children:"1 1 1 0"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"1 1"}),e.jsx("td",{children:"0 2 1 1"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"1 2"}),e.jsx("td",{children:"2 0 1 2"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"2 0"}),e.jsx("td",{children:"2 2 2 0"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"2 1"}),e.jsx("td",{children:"1 0 2 1"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"2 2"}),e.jsx("td",{children:"0 1 2 2"})]})]})]})}),e.jsx("p",{children:"The minimum distance of the code is 3."})]}),e.jsxs(c,{title:"Ternary Hamming Code of Length 13",children:[e.jsxs("p",{children:["As ",e.jsx(n,{children:"13 = (3^3 - 1)/(3 - 1)"}),", the parity check matrix is a ",e.jsx(n,{children:"3 \\times 13"})," matrix. The columns consist of all normalized non-zero 3-tuples over ",e.jsx(n,{children:"	ext{GF}(3)"}),":"]}),e.jsx(i,{children:"\\mathbf{H} = \\begin{pmatrix} 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 1 & 2 & 2 & 2 \\\\ 1 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 & 0 & 1 & 2 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["This gives a ",e.jsx(n,{children:"(10, 13)"})," ternary Hamming code with dimension ",e.jsx(n,{children:"13 - 3 = 10"}),"."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Syndrome Decoding for Non-binary Codes"}),e.jsxs("p",{children:["When working with non-binary codes, the syndrome decoding procedure with parity check matrix ",e.jsx(n,{children:"mathbf{H}"})," needs modification. Let ",e.jsx(n,{children:"r = r_1 \\cdots r_n"})," be the received word and ",e.jsx(n,{children:"mathbf{s} = mathbf{H}mathbf{r}^t"})," be the syndrome."]}),e.jsx(r,{title:"Syndrome Decoding (Non-binary)",children:e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-3",children:[e.jsxs("li",{children:["If ",e.jsx(n,{children:"mathbf{s}"})," equals a constant multiple of a unique column of ",e.jsx(n,{children:"mathbf{H}"}),", say the ",e.jsx(n,{children:"i"}),"-th column, i.e.,",e.jsx(i,{children:"\\mathbf{s} = \\lambda \\mathbf{H}_i \\quad \\text{where } 0 \\neq \\lambda \\in \\text{GF}(q)"}),"then we assume an error occurred in the ",e.jsx(n,{children:"i"}),"-th position and decode to:",e.jsx(i,{children:"c = r_1 \\cdots r_{i-1} (r_i - \\lambda) r_{i+1} \\cdots r_n"})]}),e.jsxs("li",{children:["If ",e.jsx(n,{children:"mathbf{s}"})," is not a multiple of any column of ",e.jsx(n,{children:"mathbf{H}"}),", then at least two errors occurred."]}),e.jsxs("li",{children:["If ",e.jsx(n,{children:"mathbf{s}"})," equals a multiple of ",e.jsx(n,{children:"mathbf{H}_i"})," and also of ",e.jsx(n,{children:"mathbf{H}_j"})," with ",e.jsx(n,{children:"i \\neq j"}),", there is decoding failure."]})]})}),e.jsx(t,{title:"Single Error Correction",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Suppose the code can correct all single errors. If two columns ",e.jsx(n,{children:"mathbf{H}_i"})," and ",e.jsx(n,{children:"mathbf{H}_j"})," are linearly dependent, then ",e.jsx(n,{children:"mathbf{H}_i = lambda mathbf{H}_j"})," for some ",e.jsx(n,{children:"\\lambda \\neq 0"}),". Then the error pattern ",e.jsx(n,{children:"mathbf{e}"})," with 1 in position ",e.jsx(n,{children:"i"})," and 0 elsewhere has syndrome ",e.jsx(n,{children:"mathbf{H}_i = lambda mathbf{H}_j"}),", which is also the syndrome of the error pattern with ",e.jsx(n,{children:"\\lambda"})," in position ",e.jsx(n,{children:"j"}),". This leads to decoding ambiguity, contradiction."]}),e.jsxs("p",{className:"mt-2",children:["Conversely, if every two columns are linearly independent, then for any single error in position ",e.jsx(n,{children:"i"})," with error value ",e.jsx(n,{children:"\\lambda"}),", the syndrome ",e.jsx(n,{children:"lambda mathbf{H}_i"})," uniquely determines both ",e.jsx(n,{children:"i"})," and ",e.jsx(n,{children:"\\lambda"}),"."]})]}),children:e.jsxs("p",{children:["Let ",e.jsx(n,{children:"mathscr{C}"})," be a linear code over ",e.jsx(n,{children:"	ext{GF}(q)"})," with an ",e.jsx(n,{children:"(n - m) \\times n"})," parity check matrix ",e.jsx(n,{children:"mathbf{H}"}),". The code is capable of correcting all single errors if and only if every two columns of ",e.jsx(n,{children:"mathbf{H}"})," are linearly independent."]})}),e.jsx(s,{type:"success",title:"Hamming Codes are Single Error Correcting",children:e.jsxs("p",{children:["As the first non-zero entry in every column of the parity check matrix ",e.jsx(n,{children:"mathbf{H}"})," of the Hamming code over ",e.jsx(n,{children:"	ext{GF}(q)"}),", ",e.jsx(n,{children:"q \\geq 2"}),", is 1, it follows that no column of ",e.jsx(n,{children:"mathbf{H}"})," is a scalar multiple of any other column. Therefore, Hamming codes over ",e.jsx(n,{children:"	ext{GF}(q)"})," are single error correcting."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Minimum Distance and Perfect Codes"}),e.jsx(t,{title:"Minimum Distance Criterion",proof:e.jsx(e.Fragment,{children:e.jsxs("p",{children:["The minimum distance of a code equals the minimum number of columns of ",e.jsx(n,{children:"mathbf{H}"})," that are linearly dependent. If every ",e.jsx(n,{children:"k"})," columns are linearly independent, then at least ",e.jsx(n,{children:"k + 1"})," columns are needed for a linear dependence, hence minimum distance is at least ",e.jsx(n,{children:"k + 1"}),"."]})}),children:e.jsxs("p",{children:["The minimum distance of a code over ",e.jsx(n,{children:"	ext{GF}(q)"})," with parity check matrix ",e.jsx(n,{children:"mathbf{H}"})," is at least ",e.jsx(n,{children:"k + 1"})," if and only if every set of ",e.jsx(n,{children:"k"})," columns of ",e.jsx(n,{children:"mathbf{H}"})," is linearly independent."]})}),e.jsxs(r,{title:"Spheres and Perfect Codes",children:[e.jsxs("p",{children:["Let ",e.jsx(n,{children:"F"})," be a field of order ",e.jsx(n,{children:"q"}),". For a positive integer ",e.jsx(n,{children:"n"})," and ",e.jsx(n,{children:"\rho {'>'} 0"}),", the ",e.jsx("strong",{children:"sphere"})," in ",e.jsx(n,{children:"V(n, q)"})," of radius ",e.jsx(n,{children:"\\rho"})," centered at ",e.jsx(n,{children:"mathbf{x}"})," is:"]}),e.jsx(i,{children:"S_\\rho(\\mathbf{x}) = \\{\\mathbf{y} \\in V(n, q) \\mid d(\\mathbf{x}, \\mathbf{y}) \\leq \\rho\\}"}),e.jsxs("p",{className:"mt-2",children:["An ",e.jsx(n,{children:"e"}),"-error-correcting code ",e.jsx(n,{children:"mathscr{C}"})," of length ",e.jsx(n,{children:"n"})," over ",e.jsx(n,{children:"	ext{GF}(q)"})," is called ",e.jsx("strong",{children:"perfect"})," if:"]}),e.jsx(i,{children:"\\bigcup_{\\mathbf{x} \\in \\mathscr{C}} S_e(\\mathbf{x}) = V(n, q)"})]}),e.jsxs("p",{className:"mt-4",children:["Note that the sphere ",e.jsx(n,{children:"S_1(mathbf{x})"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["in ",e.jsx(n,{children:"mathbb{B}^n"})," contains exactly ",e.jsx(n,{children:"n + 1"})," elements"]}),e.jsxs("li",{children:["in ",e.jsx(n,{children:"V(n, 3)"})," contains exactly ",e.jsx(n,{children:"2n + 1"})," elements"]}),e.jsxs("li",{children:["in ",e.jsx(n,{children:"V(n, q)"})," contains exactly ",e.jsx(n,{children:"n(q - 1) + 1"})," elements"]})]}),e.jsx(t,{title:"Hamming Codes are Perfect",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We know that Hamming codes are single error correcting. Let ",e.jsx(n,{children:"mathscr{C}"})," be a Hamming code of length ",e.jsx(n,{children:"n = (q^r - 1)/(q - 1)"})," over ",e.jsx(n,{children:"	ext{GF}(q)"}),". The parity check matrix is an ",e.jsx(n,{children:"r \\times n"})," matrix, so the dimension is ",e.jsx(n,{children:"n - r"})," and the number of code words is ",e.jsx(n,{children:"q^{n-r}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The minimum distance being at least 3, every sphere ",e.jsx(n,{children:"S_1(mathbf{x})"}),", ",e.jsx(n,{children:"mathbf{x} in mathscr{C}"}),", contains exactly one code word (namely ",e.jsx(n,{children:"mathbf{x}"})," itself). Also, for ",e.jsx(n,{children:"mathbf{x}, mathbf{y} in mathscr{C}"})," with ",e.jsx(n,{children:`mathbf{x} 
eq mathbf{y}`}),", the spheres ",e.jsx(n,{children:"S_1(mathbf{x})"})," and ",e.jsx(n,{children:"S_1(mathbf{y})"})," are disjoint."]}),e.jsx("p",{className:"mt-2",children:"Therefore:"}),e.jsx(i,{children:"\\left| \\bigcup_{\\mathbf{x} \\in \\mathscr{C}} S_1(\\mathbf{x}) \\right| = (n(q-1) + 1) \\cdot q^{n-r}"}),e.jsxs("p",{className:"mt-2",children:["Substituting ",e.jsx(n,{children:"n = (q^r - 1)/(q - 1)"}),":"]}),e.jsx(i,{children:"= \\left( \\frac{q^r - 1}{q - 1} \\cdot (q - 1) + 1 \\right) q^{n-r} = q^r \\cdot q^{n-r} = q^n = |V(n, q)|"}),e.jsxs("p",{className:"mt-2",children:["Hence ",e.jsx(n,{children:"\bigcup S_1(mathbf{x}) = V(n, q)"}),"."]})]}),children:e.jsxs("p",{children:["Hamming codes over ",e.jsx(n,{children:"	ext{GF}(q)"})," are single error correcting perfect codes."]})}),e.jsx(s,{type:"note",title:"Sphere-Packing Interpretation",children:e.jsx("p",{children:"Perfectness means that the spheres of radius 1 around all code words exactly partition the ambient space. Every received word either is a code word or is within distance 1 of exactly one code word. This is the optimal situation for single error correction -- no redundancy is wasted."})})]})}export{p as default};
