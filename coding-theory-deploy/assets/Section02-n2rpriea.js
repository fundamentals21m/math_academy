import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as n,E as i,D as s,C as h,T as a}from"./Callout-BFDudfNm.js";import{M as r,I as t}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function j(){return e.jsxs(n,{sectionId:2,children:[e.jsx("h2",{children:"1.3 Generator and Parity Check Matrices"}),e.jsx("p",{children:"We now explore the relationship between generator matrices and parity check matrices, which provides powerful tools for both encoding and decoding in matrix codes."}),e.jsx("h3",{children:"From Generator Matrix to Parity Check Equations"}),e.jsxs(i,{title:"Deriving Parity Check Equations",children:[e.jsx("p",{children:"Consider the matrix code given by the generator matrix:"}),e.jsx(r,{children:"\\mathbf{G} = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(t,{children:"a_1a_2a_3a_4a_5a_6"})," is the code word corresponding to message word ",e.jsx(t,{children:"a_1a_2a_3"}),", then:"]}),e.jsx(r,{children:"(a_1 \\; a_2 \\; a_3 \\; a_4 \\; a_5 \\; a_6) = (a_1 \\; a_2 \\; a_3)\\mathbf{G}"}),e.jsx("p",{className:"mt-2",children:"This gives us:"}),e.jsx(r,{children:"a_4 = a_1 + a_3, \\quad a_5 = a_1 + a_2 + a_3, \\quad a_6 = a_2 + a_3"}),e.jsxs("p",{className:"mt-2",children:["Rewriting these as ",e.jsx("strong",{children:"parity check equations"}),":"]}),e.jsx(r,{children:"a_1 + a_3 + a_4 = 0"}),e.jsx(r,{children:"a_1 + a_2 + a_3 + a_5 = 0"}),e.jsx(r,{children:"a_2 + a_3 + a_6 = 0"})]}),e.jsx("h3",{children:"The Parity Check Matrix"}),e.jsx("p",{children:"The parity check equations from the previous example can be written in matrix form as:"}),e.jsx(r,{children:"\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\\\ a_5 \\\\ a_6 \\end{pmatrix} = \\mathbf{0}"}),e.jsx(s,{title:"Parity Check Matrix",children:e.jsxs("p",{children:["If ",e.jsx(t,{children:"m < n"}),", then any ",e.jsx(t,{children:"(n-m) \\times n"})," matrix ",e.jsx(t,{children:"\\mathbf{H}"})," whose last ",e.jsx(t,{children:"n - m"})," columns form the identity matrix ",e.jsx(t,{children:"\\mathbf{I}_{n-m}"})," is called a ",e.jsx("strong",{children:"parity check matrix"}),"."]})}),e.jsx("h3",{children:"Standard Form Matrices"}),e.jsxs(h,{type:"info",children:[e.jsx("strong",{children:"Standard Form:"})," A generator matrix in ",e.jsx("strong",{children:"standard form"})," has the structure:",e.jsx(r,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"}),"where ",e.jsx(t,{children:"\\mathbf{I}_m"})," is the ",e.jsx(t,{children:"m \\times m"})," identity matrix and ",e.jsx(t,{children:"\\mathbf{A}"})," is an ",e.jsx(t,{children:"m \\times (n-m)"})," matrix.",e.jsx("p",{className:"mt-2",children:"The corresponding parity check matrix is:"}),e.jsx(r,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"}),"where ",e.jsx(t,{children:"\\mathbf{A}^t"})," denotes the transpose of ",e.jsx(t,{children:"\\mathbf{A}"}),"."]}),e.jsxs(i,{title:"Generator and Parity Check Matrix Relationship",children:[e.jsx("p",{children:"For the generator matrix:"}),e.jsx(r,{children:"\\mathbf{G} = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix} = (\\mathbf{I}_3 \\;|\\; \\mathbf{A})"}),e.jsx("p",{className:"mt-2",children:"where:"}),e.jsx(r,{children:"\\mathbf{A} = \\begin{pmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"The parity check matrix is:"}),e.jsx(r,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_3) = \\begin{pmatrix} 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix}"})]}),e.jsx("h3",{children:"The Syndrome"}),e.jsxs(s,{title:"Syndrome",children:[e.jsxs("p",{children:["For a received word ",e.jsx(t,{children:"\\mathbf{r} \\in \\mathbb{B}^n"}),", the ",e.jsx("strong",{children:"syndrome"})," is defined as:"]}),e.jsx(r,{children:"\\mathbf{s} = \\mathbf{H}\\mathbf{r}^t"}),e.jsx("p",{className:"mt-2",children:"The syndrome of a code word is always the zero vector. If the syndrome is non-zero, an error has been detected."})]}),e.jsx("h3",{children:"Syndrome Decoding Procedure"}),e.jsxs(h,{type:"info",children:[e.jsx("strong",{children:"Syndrome (Parity Check) Decoding:"}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(t,{children:"\\mathbf{r} = r_1\\cdots r_m r_{m+1}\\cdots r_n"})," be the received word and ",e.jsx(t,{children:"\\mathbf{s} = \\mathbf{H}\\mathbf{r}^t"})," be its syndrome."]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:["If ",e.jsx(t,{children:"\\mathbf{s} = \\mathbf{0}"}),", assume ",e.jsx(t,{children:"\\mathbf{r}"})," is the transmitted code word. The original message is ",e.jsx(t,{children:"r_1\\cdots r_m"}),"."]}),e.jsxs("li",{children:["If ",e.jsx(t,{children:"\\mathbf{s}"})," matches the ",e.jsx(t,{children:"i"}),"-th column of ",e.jsx(t,{children:"\\mathbf{H}"}),", assume an error occurred in position ",e.jsx(t,{children:"i"}),". Flip the ",e.jsx(t,{children:"i"}),"-th bit to get the corrected code word."]}),e.jsxs("li",{children:["If ",e.jsx(t,{children:"\\mathbf{s}"})," is neither zero nor a column of ",e.jsx(t,{children:"\\mathbf{H}"}),", at least two errors occurred."]})]})]}),e.jsx(a,{title:"Single Error Correction Criterion",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇒)"})," Suppose the ",e.jsx(t,{children:"i"}),"-th column of ",e.jsx(t,{children:"\\mathbf{H}"})," is zero. Let ",e.jsx(t,{children:"\\mathbf{e}"})," be the error word with 1 in position ",e.jsx(t,{children:"i"})," and 0 elsewhere."]}),e.jsxs("p",{className:"mt-2",children:["For any code word ",e.jsx(t,{children:"\\mathbf{b}"}),":"]}),e.jsx(r,{children:"\\mathbf{H}(\\mathbf{b} + \\mathbf{e})^t = \\mathbf{H}\\mathbf{b}^t + \\mathbf{H}\\mathbf{e}^t = 0 + 0 = 0"}),e.jsxs("p",{className:"mt-2",children:["So ",e.jsx(t,{children:"\\mathbf{b} + \\mathbf{e}"})," is decoded as a code word, and the error goes undetected."]}),e.jsxs("p",{className:"mt-2",children:["If columns ",e.jsx(t,{children:"i"})," and ",e.jsx(t,{children:"j"})," are identical, let ",e.jsx(t,{children:"\\mathbf{e}^i"})," and ",e.jsx(t,{children:"\\mathbf{e}^j"})," be error words with 1 in positions ",e.jsx(t,{children:"i"})," and ",e.jsx(t,{children:"j"})," respectively."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(t,{children:"\\mathbf{H}(\\mathbf{b} + \\mathbf{e}^i)^t = \\mathbf{H}(\\mathbf{b} + \\mathbf{e}^j)^t"}),", so we cannot distinguish between errors in positions ",e.jsx(t,{children:"i"})," and ",e.jsx(t,{children:"j"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐)"})," If columns are non-zero and distinct, then for any single error ",e.jsx(t,{children:"\\mathbf{e}"})," in position ",e.jsx(t,{children:"i"}),":"]}),e.jsx(r,{children:"\\mathbf{H}(\\mathbf{b} + \\mathbf{e})^t = \\mathbf{H}\\mathbf{e}^t = i\\text{-th column of } \\mathbf{H}"}),e.jsx("p",{className:"mt-2",children:"This uniquely identifies the error position, allowing correction."})]}),children:e.jsxs("p",{children:["An ",e.jsx(t,{children:"(n-m) \\times n"})," parity check matrix ",e.jsx(t,{children:"\\mathbf{H}"})," will decode all single errors correctly if and only if the columns of ",e.jsx(t,{children:"\\mathbf{H}"})," are non-zero and distinct."]})}),e.jsx(a,{title:"Correspondence Between Generator and Parity Check Matrices",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(t,{children:"\\mathbf{a} \\in \\mathbb{B}^m"})," and ",e.jsx(t,{children:"\\mathbf{b}"})," be the code word in the code generated by ",e.jsx(t,{children:"\\mathbf{G}"}),". Then ",e.jsx(t,{children:"\\mathbf{b} = \\mathbf{a}\\mathbf{G}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since the first ",e.jsx(t,{children:"m"})," columns of ",e.jsx(t,{children:"\\mathbf{G}"})," form ",e.jsx(t,{children:"\\mathbf{I}_m"}),", we have ",e.jsx(t,{children:"\\mathbf{b} = (\\mathbf{a} \\;|\\; \\bar{\\mathbf{b}})"})," where ",e.jsx(t,{children:"\\bar{\\mathbf{b}} = \\mathbf{a}\\mathbf{A}"}),"."]}),e.jsx("p",{className:"mt-2",children:"Now:"}),e.jsx(r,{children:"\\mathbf{H}\\mathbf{b}^t = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})(\\mathbf{a}\\mathbf{G})^t = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})\\mathbf{G}^t\\mathbf{a}^t"}),e.jsx(r,{children:"= (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})\\begin{pmatrix} \\mathbf{I}_m \\\\ \\mathbf{A}^t \\end{pmatrix}\\mathbf{a}^t"}),e.jsx(r,{children:"= (\\mathbf{A}^t + \\mathbf{A}^t)\\mathbf{a}^t = \\mathbf{0}"}),e.jsxs("p",{className:"mt-2",children:["Thus every code word satisfies ",e.jsx(t,{children:"\\mathbf{H}\\mathbf{b}^t = \\mathbf{0}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Uniqueness: The structure ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"})," uniquely determines ",e.jsx(t,{children:"\\mathbf{A}"}),", hence ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"}),"."]})]}),children:e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:["If ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"})," is an ",e.jsx(t,{children:"m \\times n"})," generator matrix, then ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"})," is the unique parity check matrix for the same code."]}),e.jsxs("li",{children:["If ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{B} \\;|\\; \\mathbf{I}_{n-m})"})," is an ",e.jsx(t,{children:"(n-m) \\times n"})," parity check matrix, then ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{B}^t)"})," is the unique generator matrix for the same code."]})]})}),e.jsx("h3",{children:"Conditions for Single Error Correction"}),e.jsx(a,{title:"Generator Matrix Single Error Correction Criterion",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The parity check matrix of the code with generator ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"})," is ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx(t,{children:"\\mathbf{H}"})," decodes all single errors correctly if and only if all columns of ",e.jsx(t,{children:"\\mathbf{H}"})," are non-zero and distinct."]}),e.jsxs("p",{className:"mt-2",children:["The columns of ",e.jsx(t,{children:"\\mathbf{A}^t"})," are the rows of ",e.jsx(t,{children:"\\mathbf{A}"}),". The last ",e.jsx(t,{children:"n - m"})," columns of ",e.jsx(t,{children:"\\mathbf{H}"})," are automatically non-zero and distinct (they form ",e.jsx(t,{children:"\\mathbf{I}_{n-m}"}),")."]}),e.jsxs("p",{className:"mt-2",children:["For the first ",e.jsx(t,{children:"m"})," columns (rows of ",e.jsx(t,{children:"\\mathbf{A}"}),") to be non-zero and distinct from each other and from columns of ",e.jsx(t,{children:"\\mathbf{I}_{n-m}"}),", each row of ",e.jsx(t,{children:"\\mathbf{A}"})," must have weight at least 2 and all rows must be distinct."]})]}),children:e.jsxs("p",{children:["An ",e.jsx(t,{children:"(m, n)"}),"-code with generator matrix ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"})," will decode all single errors correctly if and only if all the rows of ",e.jsx(t,{children:"\\mathbf{A}"})," are distinct and each has weight at least 2."]})}),e.jsx("h3",{children:"The Dual Code"}),e.jsxs(s,{title:"Dual Code",children:[e.jsxs("p",{children:["Let ",e.jsx(t,{children:"C"})," be the ",e.jsx(t,{children:"(m, n)"}),"-code with generator matrix ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"dual code"})," ",e.jsx(t,{children:"C^\\perp"})," is the ",e.jsx(t,{children:"(n-m, n)"}),"-code with generator matrix ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Equivalently, ",e.jsx(t,{children:"C^\\perp"})," is the code with parity check matrix ",e.jsx(t,{children:"\\mathbf{G}"}),"."]})]}),e.jsxs(i,{title:"A Code and Its Dual",children:[e.jsx("p",{children:"Consider the code with generator matrix:"}),e.jsx(r,{children:"\\mathbf{G} = \\begin{pmatrix} 1 & 0 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"The code words are:"}),e.jsx("div",{className:"bg-dark-800/50 p-3 rounded-lg font-mono text-sm mt-2",children:"00000, 10111, 01101, 11010"}),e.jsx("p",{className:"mt-2",children:"The minimum distance is 3, so this code can detect 2 errors and correct 1 error."}),e.jsx("p",{className:"mt-4",children:"The dual code has generator matrix:"}),e.jsx(r,{children:"\\mathbf{G}_1 = (\\mathbf{I}_3 \\;|\\; \\mathbf{A}^t) = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 1 & 0 \\\\ 0 & 0 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"The dual code words are:"}),e.jsx("div",{className:"bg-dark-800/50 p-3 rounded-lg font-mono text-sm mt-2",children:"00000, 00101, 01010, 10011, 01111, 10110, 11001, 11100"}),e.jsx("p",{className:"mt-2 text-amber-400",children:"The minimum distance of the dual is only 2, so it can only detect single errors. The dual of a single-error-correcting code need not be single-error-correcting!"})]}),e.jsx(a,{title:"Same Syndrome Implies Same Coset",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx(t,{children:"\\mathbf{x}, \\mathbf{y}"})," are in the same coset if and only if ",e.jsx(t,{children:"\\mathbf{y} = \\mathbf{x} + \\mathbf{c}"})," for some code word ",e.jsx(t,{children:"\\mathbf{c} \\in C"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This is equivalent to ",e.jsx(t,{children:"\\mathbf{x} + \\mathbf{y} = \\mathbf{c} \\in C"}),"."]}),e.jsx("p",{className:"mt-2",children:"Now:"}),e.jsx(r,{children:"\\mathbf{x} + \\mathbf{y} \\in C \\iff \\mathbf{H}(\\mathbf{x} + \\mathbf{y})^t = 0"}),e.jsx(r,{children:"\\iff \\mathbf{H}\\mathbf{x}^t + \\mathbf{H}\\mathbf{y}^t = 0"}),e.jsx(r,{children:"\\iff \\mathbf{H}\\mathbf{x}^t = \\mathbf{H}\\mathbf{y}^t"})]}),children:e.jsxs("p",{children:["Let ",e.jsx(t,{children:"\\mathbf{H}"})," be a parity check matrix and ",e.jsx(t,{children:"C"})," be the code defined by ",e.jsx(t,{children:"\\mathbf{H}"}),". Words ",e.jsx(t,{children:"\\mathbf{x}, \\mathbf{y} \\in \\mathbb{B}^n"})," are in the same coset of ",e.jsx(t,{children:"C"})," if and only if they have the same syndrome."]})}),e.jsxs(h,{type:"success",children:[e.jsx("strong",{children:"Section Summary:"})," Generator matrices in standard form ",e.jsx(t,{children:"\\mathbf{G} = (\\mathbf{I}_m \\;|\\; \\mathbf{A})"})," have corresponding parity check matrices ",e.jsx(t,{children:"\\mathbf{H} = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_{n-m})"}),". The syndrome ",e.jsx(t,{children:"\\mathbf{s} = \\mathbf{H}\\mathbf{r}^t"})," of a received word enables error detection and correction. For single-error correction, the columns of ",e.jsx(t,{children:"\\mathbf{H}"})," must be non-zero and distinct. The dual code provides another perspective on the code structure."]})]})}export{j as default};
