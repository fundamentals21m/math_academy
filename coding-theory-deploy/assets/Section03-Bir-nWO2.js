import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a,D as i,T as r,C as l,E as d}from"./Callout-DA0JknRv.js";import{I as s,M as n}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function y(){return e.jsxs(a,{sectionId:3,children:[e.jsx("h2",{children:"Chapter 2: Polynomial Codes"}),e.jsx("h3",{children:"2.1 Definition of Vector Space and Polynomial Ring"}),e.jsxs("p",{children:["We now introduce another important algebraic technique for studying codes: ",e.jsx("strong",{children:"polynomial multiplication"}),". The codes obtained through this method are called polynomial codes, and many of the most important codes studied today fall into this category."]}),e.jsx("h3",{children:"Vector Spaces"}),e.jsxs(i,{title:"Vector Space",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"F"})," be a field. A non-empty set ",e.jsx(s,{children:"V"})," is called a ",e.jsxs("strong",{children:["vector space over ",e.jsx(s,{children:"F"})]})," if:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:["There is defined an addition in ",e.jsx(s,{children:"V"})," with respect to which ",e.jsx(s,{children:"V"})," is an Abelian group."]}),e.jsxs("li",{children:["For every ",e.jsx(s,{children:"a \\in F"})," and ",e.jsx(s,{children:"v \\in V"}),", there is defined a unique element ",e.jsx(s,{children:"av \\in V"})," (scalar multiplication) satisfying:",e.jsxs("ul",{className:"list-disc list-inside ml-4 mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(s,{children:"a(v_1 + v_2) = av_1 + av_2"})}),e.jsx("li",{children:e.jsx(s,{children:"(a + b)v = av + bv"})}),e.jsx("li",{children:e.jsx(s,{children:"(ab)v = a(bv)"})}),e.jsxs("li",{children:[e.jsx(s,{children:"1 \\cdot v = v"})," (where 1 is the identity of ",e.jsx(s,{children:"F"}),")"]})]})]})]})]}),e.jsxs(i,{title:"Linear Independence and Basis",children:[e.jsxs("p",{children:["A set ",e.jsx(s,{children:"\\{v_1, v_2, \\ldots, v_n\\}"})," of elements of ",e.jsx(s,{children:"V"})," is called ",e.jsx("strong",{children:"linearly independent"})," if whenever:"]}),e.jsx(n,{children:"a_1v_1 + a_2v_2 + \\cdots + a_nv_n = 0"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"a_1, a_2, \\ldots, a_n \\in F"}),", then ",e.jsx(s,{children:"a_1 = a_2 = \\cdots = a_n = 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If the elements ",e.jsx(s,{children:"v_1, \\ldots, v_n"})," are linearly independent over ",e.jsx(s,{children:"F"})," and every element of ",e.jsx(s,{children:"V"})," can be expressed as a linear combination ",e.jsx(s,{children:"a_1v_1 + \\cdots + a_nv_n"}),", then ",e.jsx(s,{children:"\\{v_1, \\ldots, v_n\\}"})," is called a ",e.jsx("strong",{children:"basis"})," of ",e.jsx(s,{children:"V"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"dimension"})," of ",e.jsx(s,{children:"V"})," is ",e.jsx(s,{children:"n"}),", written ",e.jsx(s,{children:"\\dim V = n"}),"."]})]}),e.jsxs(i,{title:"Isomorphism of Vector Spaces",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"V"})," and ",e.jsx(s,{children:"W"})," be vector spaces over the same field ",e.jsx(s,{children:"F"}),". A map ",e.jsx(s,{children:"f: V \\to W"})," is called an ",e.jsx("strong",{children:"isomorphism"})," if ",e.jsx(s,{children:"f"})," is one-to-one and onto, and for all ",e.jsx(s,{children:"v, v_1, v_2 \\in V"})," and ",e.jsx(s,{children:"a \\in F"}),":"]}),e.jsx(n,{children:"f(v_1 + v_2) = f(v_1) + f(v_2) \\quad \\text{and} \\quad f(av) = af(v)"})]}),e.jsx(r,{title:"Isomorphism of Equal-Dimensional Vector Spaces",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"\\{x_1, \\ldots, x_n\\}"})," be a basis of ",e.jsx(s,{children:"V"})," and ",e.jsx(s,{children:"\\{y_1, \\ldots, y_n\\}"})," be a basis of ",e.jsx(s,{children:"W"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since every element of ",e.jsx(s,{children:"V"})," can be uniquely written as ",e.jsx(s,{children:"a_1x_1 + \\cdots + a_nx_n"}),", define ",e.jsx(s,{children:"\\theta: V \\to W"})," by:"]}),e.jsx(n,{children:"\\theta(a_1x_1 + \\cdots + a_nx_n) = a_1y_1 + \\cdots + a_ny_n"}),e.jsx("p",{className:"mt-2",children:"This map is well-defined and is straightforward to verify as a homomorphism."}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"\\theta(a_1x_1 + \\cdots + a_nx_n) = 0"}),", then ",e.jsx(s,{children:"a_1y_1 + \\cdots + a_ny_n = 0"}),", which implies ",e.jsx(s,{children:"a_1 = \\cdots = a_n = 0"})," since ",e.jsx(s,{children:"y_1, \\ldots, y_n"})," are linearly independent. Thus ",e.jsx(s,{children:"\\theta"})," is one-to-one."]}),e.jsxs("p",{className:"mt-2",children:["Every element of ",e.jsx(s,{children:"W"})," is of the form ",e.jsx(s,{children:"a_1y_1 + \\cdots + a_ny_n = \\theta(a_1x_1 + \\cdots + a_nx_n)"}),", so ",e.jsx(s,{children:"\\theta"})," is onto."]})]}),children:e.jsxs("p",{children:["If ",e.jsx(s,{children:"V"})," and ",e.jsx(s,{children:"W"})," are vector spaces of equal finite dimension over the same field ",e.jsx(s,{children:"F"}),", then ",e.jsx(s,{children:"V"})," and ",e.jsx(s,{children:"W"})," are isomorphic."]})}),e.jsx("h3",{children:"Polynomial Rings"}),e.jsxs(i,{title:"Polynomial Ring",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"F"})," be a field and ",e.jsx(s,{children:"X"})," be a variable. Let ",e.jsx(s,{children:"F[X]"})," denote the set of all polynomials in ",e.jsx(s,{children:"X"})," over ",e.jsx(s,{children:"F"}),":"]}),e.jsx(n,{children:"F[X] = \\{a_0 + a_1X + \\cdots + a_nX^n : a_i \\in F, n \\geq 0\\}"}),e.jsx("p",{className:"mt-2",children:"For polynomials:"}),e.jsx(n,{children:"a(X) = a_0 + a_1X + \\cdots + a_mX^m"}),e.jsx(n,{children:"b(X) = b_0 + b_1X + \\cdots + b_nX^n"}),e.jsx("p",{className:"mt-2",children:"Addition is defined as:"}),e.jsx(n,{children:"a(X) + b(X) = c_0 + c_1X + c_2X^2 + \\cdots \\quad \\text{where } c_i = a_i + b_i"}),e.jsx("p",{className:"mt-2",children:"Multiplication is defined as:"}),e.jsx(n,{children:"a(X)b(X) = d_0 + d_1X + \\cdots + d_{m+n}X^{m+n}"}),e.jsx("p",{className:"mt-2",children:"where:"}),e.jsx(n,{children:"d_j = a_0b_j + a_1b_{j-1} + \\cdots + a_jb_0 = \\sum_{i=0}^{j} a_ib_{j-i}"}),e.jsxs("p",{className:"mt-2",children:["(with ",e.jsx(s,{children:"a_i = 0"})," for ",e.jsx(s,{children:"i > m"})," and ",e.jsx(s,{children:"b_i = 0"})," for ",e.jsx(s,{children:"i > n"}),")"]})]}),e.jsxs(i,{title:"Degree of a Polynomial",children:[e.jsxs("p",{children:["For a polynomial ",e.jsx(s,{children:"a(X) = a_0 + a_1X + \\cdots + a_mX^m"})," with ",e.jsx(s,{children:"a_m \\neq 0"}),", the ",e.jsx("strong",{children:"degree"})," of ",e.jsx(s,{children:"a(X)"})," is ",e.jsx(s,{children:"m"}),", written ",e.jsx(s,{children:"\\deg a(X) = m"}),"."]}),e.jsxs("p",{className:"mt-2",children:["A key property: for non-zero polynomials ",e.jsx(s,{children:"a(X), b(X) \\in F[X]"}),":"]}),e.jsx(n,{children:"\\deg(a(X)b(X)) = \\deg a(X) + \\deg b(X)"})]}),e.jsxs(l,{type:"info",children:[e.jsx("strong",{children:"Integral Domain:"})," A commutative ring ",e.jsx(s,{children:"R"})," in which ",e.jsx(s,{children:"ab = 0"})," implies ",e.jsx(s,{children:"a = 0"})," or ",e.jsx(s,{children:"b = 0"})," is called an ",e.jsx("strong",{children:"integral domain"}),". The polynomial ring ",e.jsx(s,{children:"F[X]"})," over a field ",e.jsx(s,{children:"F"})," is always an integral domain."]}),e.jsx("h3",{children:"Correspondence Between Polynomials and Words"}),e.jsxs("p",{children:["Let ",e.jsx(s,{children:"n"})," be a positive integer. With a polynomial of degree at most ",e.jsx(s,{children:"n - 1"}),":"]}),e.jsx(n,{children:"a(X) = a_0 + a_1X + \\cdots + a_{n-1}X^{n-1}"}),e.jsxs("p",{children:["we can associate an ordered ",e.jsx(s,{children:"n"}),"-tuple (word):"]}),e.jsx(n,{children:"a = (a_0, a_1, \\ldots, a_{n-1})"}),e.jsxs("p",{children:["and conversely, with every word ",e.jsx(s,{children:"a = (a_0, a_1, \\ldots, a_{n-1})"})," we can associate a polynomial of degree at most ",e.jsx(s,{children:"n - 1"}),"."]}),e.jsxs(i,{title:"Space of Bounded-Degree Polynomials",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"\\mathcal{P}_n(X)"})," denote the set of all polynomials in ",e.jsx(s,{children:"F[X]"})," of degree at most ",e.jsx(s,{children:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["With addition and scalar multiplication, ",e.jsx(s,{children:"\\mathcal{P}_n(X)"})," is a vector space over ",e.jsx(s,{children:"F"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The elements ",e.jsx(s,{children:"1, X, X^2, \\ldots, X^n"})," form a basis, so ",e.jsx(s,{children:"\\dim \\mathcal{P}_n(X) = n + 1"}),"."]})]}),e.jsxs(r,{title:"Isomorphism Between Polynomials and Words",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Both ",e.jsx(s,{children:"\\mathcal{P}_{n-1}(X)"})," and ",e.jsx(s,{children:"F^{(n)}"})," are vector spaces of dimension ",e.jsx(s,{children:"n"})," over ",e.jsx(s,{children:"F"}),"."]}),e.jsx("p",{className:"mt-2",children:"By the previous theorem, they are isomorphic."}),e.jsxs("p",{className:"mt-2",children:["The explicit isomorphism maps ",e.jsx(s,{children:"a(X) = a_0 + a_1X + \\cdots + a_{n-1}X^{n-1}"})," to the word ",e.jsx(s,{children:"(a_0, a_1, \\ldots, a_{n-1})"}),"."]})]}),children:[e.jsxs("p",{children:["The vector spaces ",e.jsx(s,{children:"\\mathcal{P}_{n-1}(X)"})," (polynomials of degree at most ",e.jsx(s,{children:"n - 1"}),") and ",e.jsx(s,{children:"F^{(n)}"})," (words of length ",e.jsx(s,{children:"n"}),") are isomorphic, with the element:"]}),e.jsx(n,{children:"a(X) = a_0 + a_1X + \\cdots + a_{n-1}X^{n-1}"}),e.jsx("p",{children:"corresponding to:"}),e.jsx(n,{children:"a = (a_0, a_1, \\ldots, a_{n-1})"})]}),e.jsxs(l,{type:"info",children:[e.jsx("strong",{children:"Notation Convention:"})," In view of the isomorphism between polynomials and words, we will use:",e.jsx(n,{children:"a(X) = a_0 + a_1X + \\cdots + a_{n-1}X^{n-1}"}),"and",e.jsx(n,{children:"a = (a_0, a_1, \\ldots, a_{n-1})"}),e.jsx("p",{className:"mt-2",children:"interchangeably throughout this chapter."})]}),e.jsxs(d,{title:"Polynomial-Word Correspondence",children:[e.jsxs("p",{children:["Over the binary field ",e.jsx(s,{children:"\\mathbb{B}"}),":"]}),e.jsxs("div",{className:"grid grid-cols-2 gap-4 mt-2",children:[e.jsxs("div",{className:"bg-dark-800/50 p-3 rounded-lg",children:[e.jsx("p",{className:"text-primary-400 font-semibold mb-2",children:"Polynomial"}),e.jsx("p",{children:e.jsx(s,{children:"1 + X + X^3"})}),e.jsx("p",{children:e.jsx(s,{children:"X^2 + X^4"})}),e.jsx("p",{children:e.jsx(s,{children:"1 + X^2 + X^5"})})]}),e.jsxs("div",{className:"bg-dark-800/50 p-3 rounded-lg",children:[e.jsx("p",{className:"text-primary-400 font-semibold mb-2",children:"Word (length 6)"}),e.jsx("p",{children:e.jsx(s,{children:"(1, 1, 0, 1, 0, 0)"})}),e.jsx("p",{children:e.jsx(s,{children:"(0, 0, 1, 0, 1, 0)"})}),e.jsx("p",{children:e.jsx(s,{children:"(1, 0, 1, 0, 0, 1)"})})]})]})]}),e.jsx("h3",{children:"Properties of the Binary Polynomial Ring"}),e.jsxs("p",{children:["Working in the binary polynomial ring ",e.jsx(s,{children:"\\mathbb{B}[X]"})," has special properties due to the characteristic of the field."]}),e.jsxs(l,{type:"warning",children:[e.jsx("strong",{children:"Characteristic 2 Property:"})," In ",e.jsx(s,{children:"\\mathbb{B}[X]"}),", since ",e.jsx(s,{children:"1 + 1 = 0"})," in ",e.jsx(s,{children:"\\mathbb{B}"}),":",e.jsx(n,{children:"a(X) + a(X) = 0 \\quad \\text{for all } a(X) \\in \\mathbb{B}[X]"}),e.jsxs("p",{className:"mt-2",children:["This means every polynomial is its own additive inverse: ",e.jsx(s,{children:"-a(X) = a(X)"}),"."]})]}),e.jsxs(l,{type:"success",children:[e.jsx("strong",{children:"Section Summary:"})," Vector spaces provide the algebraic framework for studying codes as subspaces. The polynomial ring ",e.jsx(s,{children:"F[X]"})," and its subspace of bounded-degree polynomials is isomorphic to the space of words. This correspondence allows us to represent code words as polynomials and use polynomial operations for encoding. In the next section, we will use polynomial multiplication to define polynomial codes."]})]})}export{y as default};
