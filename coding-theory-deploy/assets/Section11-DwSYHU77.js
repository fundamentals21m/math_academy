import{j as a}from"./vendor-animation-0o8UKZ_1.js";import{L as n,D as s,C as h,T as m,E as i}from"./Callout-BFDudfNm.js";import{I as t,M as e}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function b(){return a.jsxs(n,{sectionId:11,children:[a.jsx("h2",{children:"Generator and Parity Check Matrices"}),a.jsx("p",{children:"Linear codes generalize the concept of group codes to codes over any finite field. In this section, we study linear codes as vector subspaces and develop their matrix representations."}),a.jsx("h3",{children:"Linear Codes as Vector Spaces"}),a.jsxs("p",{children:["Let ",a.jsx(t,{math:"F = GF(q)"}),", where ",a.jsx(t,{math:"q"})," is a prime power, be a field of ",a.jsx(t,{math:"q"})," elements. Let ",a.jsx(t,{math:"V(n, q)"})," denote the set of all vectors or sequences of length ",a.jsx(t,{math:"n"})," over ",a.jsx(t,{math:"F"}),". Then ",a.jsx(t,{math:"V(n, q)"})," is a vector space of dimension ",a.jsx(t,{math:"n"})," over ",a.jsx(t,{math:"F"}),"."]}),a.jsxs(s,{title:"Linear Code",children:["A subspace ",a.jsx(t,{math:"\\\\mathcal{C}"})," of ",a.jsx(t,{math:"V(n, q)"})," is called a ",a.jsx("strong",{children:"linear code"}),"of length ",a.jsx(t,{math:"n"})," over ",a.jsx(t,{math:"F"}),"."]}),a.jsx(h,{type:"info",children:"A vector space is first of all an Abelian group with respect to addition. Therefore, a linear code is always a group code."}),a.jsxs(m,{title:"Minimum Distance of Linear Codes",proof:a.jsxs(a.Fragment,{children:[a.jsxs("p",{children:["Since ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a group code, for any two code words ",a.jsx(t,{math:"u, v \\\\in \\\\mathcal{C}"}),", we have ",a.jsx(t,{math:"u - v \\\\in \\\\mathcal{C}"}),"."]}),a.jsxs("p",{className:"mt-2",children:["The Hamming distance ",a.jsx(t,{math:"d(u, v)"})," equals the number of positions where ",a.jsx(t,{math:"u"})," and",a.jsx(t,{math:"v"})," differ, which equals ",a.jsx(t,{math:"\\\\text{wt}(u - v)"}),"."]}),a.jsx("p",{className:"mt-2",children:"Therefore:"}),a.jsx(e,{math:"d = \\\\min_{u \\\\neq v} d(u, v) = \\\\min_{u \\\\neq v} \\\\text{wt}(u - v) = \\\\min_{c \\\\neq 0} \\\\text{wt}(c)"})]}),children:["The minimum distance ",a.jsx(t,{math:"d"})," of a linear code ",a.jsx(t,{math:"\\\\mathcal{C}"})," equals the minimum among the weights of non-zero code words."]}),a.jsx("h3",{children:"Generator Matrices"}),a.jsxs("p",{children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}"})," be a linear code of length ",a.jsx(t,{math:"n"})," over ",a.jsx(t,{math:"F"}),". Let ",a.jsx(t,{math:"k \\\\leq n"})," be the dimension of ",a.jsx(t,{math:"\\\\mathcal{C}"})," over ",a.jsx(t,{math:"F"})," and choose a basis ",a.jsx(t,{math:"X^{(1)}, X^{(2)}, \\\\ldots, X^{(k)}"})," of ",a.jsx(t,{math:"\\\\mathcal{C}"})," over ",a.jsx(t,{math:"F"}),"."]}),a.jsxs("p",{children:["Then any element of ",a.jsx(t,{math:"\\\\mathcal{C}"})," is of the form:"]}),a.jsx(e,{math:"a_1 X^{(1)} + a_2 X^{(2)} + \\\\cdots + a_k X^{(k)} = (a_1 \\\\, a_2 \\\\, \\\\cdots \\\\, a_k) \\\\mathbf{G}"}),a.jsx("p",{children:"where:"}),a.jsx(e,{math:"\\\\mathbf{G} = \\\\begin{pmatrix} X^{(1)} \\\\\\\\ X^{(2)} \\\\\\\\ \\\\vdots \\\\\\\\ X^{(k)} \\\\end{pmatrix}"}),a.jsxs(s,{title:"Generator Matrix",children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}"})," be an ",a.jsx(t,{math:"(m, n)"}),"-code. If there exists an ",a.jsx(t,{math:"m \\\\times n"})," matrix",a.jsx(t,{math:"\\\\mathbf{G}"})," of rank ",a.jsx(t,{math:"m"})," such that ",a.jsx(t,{math:"\\\\mathcal{C} = \\\\{\\\\mathbf{aG} \\\\mid \\\\mathbf{a} \\\\in \\\\mathbb{B}^m\\\\}"}),", then ",a.jsx(t,{math:"\\\\mathbf{G}"})," is called a ",a.jsx("strong",{children:"generator matrix"})," of the code ",a.jsx(t,{math:"\\\\mathcal{C}"}),"."]}),a.jsxs(m,{title:"Generator Matrix Equivalence",proof:a.jsxs(a.Fragment,{children:[a.jsx("p",{children:"We know that:"}),a.jsx(e,{math:"\\\\text{rank}(\\\\mathbf{AG}) \\\\leq \\\\min\\\\{\\\\text{rank}(\\\\mathbf{A}), \\\\text{rank}(\\\\mathbf{G})\\\\} \\\\leq \\\\text{rank}(\\\\mathbf{G}) = k"}),a.jsx("p",{className:"mt-2",children:"Again:"}),a.jsx(e,{math:"k = \\\\text{rank}(\\\\mathbf{G}) = \\\\text{rank}(\\\\mathbf{A}^{-1}\\\\mathbf{AG}) \\\\leq \\\\min\\\\{\\\\text{rank}(\\\\mathbf{A}^{-1}), \\\\text{rank}(\\\\mathbf{AG})\\\\} \\\\leq \\\\text{rank}(\\\\mathbf{AG})"}),a.jsxs("p",{className:"mt-2",children:["Hence ",a.jsx(t,{math:"\\\\text{rank}(\\\\mathbf{AG}) = \\\\text{rank}(\\\\mathbf{G}) = k"})," and the rows of",a.jsx(t,{math:"\\\\mathbf{AG}"})," are linearly independent."]}),a.jsxs("p",{className:"mt-2",children:["The rows of ",a.jsx(t,{math:"\\\\mathbf{AG}"})," generate a subspace of dimension ",a.jsx(t,{math:"k"})," of",a.jsx(t,{math:"\\\\mathcal{C}"}),", which itself has dimension ",a.jsx(t,{math:"k"}),". Hence any element of",a.jsx(t,{math:"\\\\mathcal{C}"})," is of the form ",a.jsx(t,{math:"\\\\mathbf{a}(\\\\mathbf{AG})"})," for some",a.jsx(t,{math:"\\\\mathbf{a} \\\\in V(k, q)"}),"."]})]}),children:["If ",a.jsx(t,{math:"\\\\mathbf{A}"})," is a non-singular square matrix of order ",a.jsx(t,{math:"k"})," over ",a.jsx(t,{math:"F"}),", then ",a.jsx(t,{math:"\\\\mathbf{AG}"})," is also a generator matrix of ",a.jsx(t,{math:"\\\\mathcal{C}"}),"."]}),a.jsx("h3",{children:"Code Parameters"}),a.jsxs(s,{title:"Linear [n, k, d] Code",children:["If ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a linear code of length ",a.jsx(t,{math:"n"}),", dimension ",a.jsx(t,{math:"k"}),", and minimum distance ",a.jsx(t,{math:"d"}),", we say ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a ",a.jsx("strong",{children:"linear [n, k, d] code"}),"over ",a.jsx(t,{math:"F"}),"."]}),a.jsxs(s,{title:"Equivalent Codes",children:["Two codes ",a.jsx(t,{math:"\\\\mathcal{C}"})," and ",a.jsx(t,{math:"\\\\mathcal{C}'"})," of length ",a.jsx(t,{math:"n"})," are said to be ",a.jsx("strong",{children:"equivalent"})," if there exists a permutation ",a.jsx(t,{math:"\\\\sigma"})," of the",a.jsx(t,{math:"n"}),"-symbols ",a.jsx(t,{math:"\\\\{1, 2, \\\\ldots, n\\\\}"})," such that ",a.jsx(t,{math:"c' \\\\in \\\\mathcal{C}'"}),"iff ",a.jsx(t,{math:"c' = \\\\sigma(c)"})," for some ",a.jsx(t,{math:"c \\\\in \\\\mathcal{C}"}),", where:",a.jsx(e,{math:"\\\\sigma(c) = \\\\sigma(c_1, \\\\ldots, c_n) = (c_{\\\\sigma(1)}, c_{\\\\sigma(2)}, \\\\ldots, c_{\\\\sigma(n)})"})]}),a.jsxs(h,{type:"info",children:[a.jsx("strong",{children:"Key Property:"})," Equivalent codes have the same minimum distance and therefore the same error detection/correction capability."]}),a.jsxs(s,{title:"Permutation Matrix",children:["A ",a.jsx("strong",{children:"permutation matrix"})," is a square matrix ",a.jsx(t,{math:"\\\\mathbf{P}"})," of order ",a.jsx(t,{math:"n"})," with exactly one non-zero entry (which is 1) in every row and column. For a permutation ",a.jsx(t,{math:"\\\\sigma"})," of",a.jsx(t,{math:"\\\\{1, 2, \\\\ldots, n\\\\}"}),", the corresponding permutation matrix has ",a.jsx(t,{math:"(i_j, j)"})," entry equal to 1 for each ",a.jsx(t,{math:"j"}),", where ",a.jsx(t,{math:"\\\\sigma(j) = i_j"}),"."]}),a.jsxs(m,{title:"Characterization of Equivalent Codes",proof:a.jsxs(a.Fragment,{children:[a.jsxs("p",{children:["Let ",a.jsx(t,{math:"\\\\sigma"})," be a permutation with ",a.jsx(t,{math:"\\\\sigma(j) = i_j"}),". Let ",a.jsx(t,{math:"\\\\mathbf{P} = (p_{ij})"})," be the corresponding permutation matrix."]}),a.jsxs("p",{className:"mt-2",children:["For any vector ",a.jsx(t,{math:"\\\\mathbf{c} = (c_1 \\\\cdots c_n)"}),", the ",a.jsx(t,{math:"j"}),"-th entry of",a.jsx(t,{math:"\\\\mathbf{cP}"})," is:"]}),a.jsx(e,{math:"c_1 p_{1j} + c_2 p_{2j} + \\\\cdots + c_n p_{nj} = c_{i_j}"}),a.jsxs("p",{className:"mt-2",children:["since ",a.jsx(t,{math:"p_{kj} = 0"})," for ",a.jsx(t,{math:"k \\\\neq i_j"}),". Therefore:"]}),a.jsx(e,{math:"\\\\mathbf{cP} = (c_{i_1} \\\\, c_{i_2} \\\\, \\\\cdots \\\\, c_{i_n}) = \\\\sigma(\\\\mathbf{c})"}),a.jsx("p",{className:"mt-2",children:"The converse follows similarly."})]}),children:["Two codes ",a.jsx(t,{math:"\\\\mathcal{C}"})," and ",a.jsx(t,{math:"\\\\mathcal{C}'"})," of length ",a.jsx(t,{math:"n"})," are equivalent if and only if there exists a permutation matrix ",a.jsx(t,{math:"\\\\mathbf{P}"})," of order ",a.jsx(t,{math:"n"})," such that ",a.jsx(t,{math:"\\\\mathcal{C}' = \\\\{\\\\mathbf{cP} \\\\mid \\\\mathbf{c} \\\\in \\\\mathcal{C}\\\\}"}),"."]}),a.jsx("h3",{children:"Systematic Form"}),a.jsxs(m,{title:"Systematic Generator Matrix",proof:a.jsxs(a.Fragment,{children:[a.jsxs("p",{children:["Let ",a.jsx(t,{math:"\\\\mathbf{G}"})," be a generator matrix of ",a.jsx(t,{math:"\\\\mathcal{C}"}),". Let ",a.jsx(t,{math:"\\\\mathbf{G}_1, \\\\ldots, \\\\mathbf{G}_n"})," denote the columns of ",a.jsx(t,{math:"\\\\mathbf{G}"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Suppose ",a.jsx(t,{math:"\\\\mathbf{G}_{i_1}, \\\\ldots, \\\\mathbf{G}_{i_k}"})," for",a.jsx(t,{math:"1 \\\\leq i_1 < \\\\cdots < i_k \\\\leq n"})," are linearly independent."]}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\sigma"})," be a permutation with ",a.jsx(t,{math:"\\\\sigma(j) = i_j"})," for",a.jsx(t,{math:"1 \\\\leq j \\\\leq k"}),". Let ",a.jsx(t,{math:"\\\\mathbf{P}"})," be the corresponding permutation matrix."]}),a.jsxs("p",{className:"mt-2",children:["In the matrix ",a.jsx(t,{math:"\\\\mathbf{M} = \\\\mathbf{GP}"}),", the first ",a.jsx(t,{math:"k"})," columns are linearly independent. Let ",a.jsx(t,{math:"\\\\mathcal{C}'"})," be the code with ",a.jsx(t,{math:"\\\\mathbf{M}"})," as generator matrix."]}),a.jsxs("p",{className:"mt-2",children:["Then ",a.jsx(t,{math:"\\\\mathcal{C}' = \\\\{\\\\mathbf{cP} \\\\mid \\\\mathbf{c} \\\\in \\\\mathcal{C}\\\\}"}),", so",a.jsx(t,{math:"\\\\mathcal{C}'"})," is equivalent to ",a.jsx(t,{math:"\\\\mathcal{C}"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\mathbf{A} = (\\\\mathbf{G}_{i_1} \\\\cdots \\\\mathbf{G}_{i_k})"}),". Since",a.jsx(t,{math:"\\\\mathbf{A}"})," is non-singular:"]}),a.jsx(e,{math:"\\\\mathbf{A}^{-1}\\\\mathbf{M} = (\\\\mathbf{I}_k \\\\quad \\\\mathbf{A}^{-1}\\\\mathbf{B})"}),a.jsxs("p",{className:"mt-2",children:["where ",a.jsx(t,{math:"\\\\mathbf{B}"})," is a ",a.jsx(t,{math:"k \\\\times (n-k)"})," matrix."]})]}),children:["Given a linear ",a.jsx(t,{math:"[n, k, d]"})," code ",a.jsx(t,{math:"\\\\mathcal{C}"})," over ",a.jsx(t,{math:"F"}),", there exists an equivalent code ",a.jsx(t,{math:"\\\\mathcal{C}'"})," having a generator matrix whose first ",a.jsx(t,{math:"k"})," columns form the identity matrix ",a.jsx(t,{math:"\\\\mathbf{I}_k"}),"."]}),a.jsx("h3",{children:"Parity Check Matrices"}),a.jsxs(s,{title:"Parity Check Matrix",children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}"})," be an ",a.jsx(t,{math:"(m, n)"}),"-code. If there exists an",a.jsx(t,{math:"(n-m) \\\\times n"})," matrix ",a.jsx(t,{math:"\\\\mathbf{H}"})," of rank ",a.jsx(t,{math:"n - m"})," such that",a.jsx(t,{math:"\\\\mathbf{Hb}^t = 0"})," for all ",a.jsx(t,{math:"\\\\mathbf{b} \\\\in \\\\mathcal{C}"}),", then ",a.jsx(t,{math:"\\\\mathbf{H}"})," is called a ",a.jsx("strong",{children:"parity check matrix"})," of ",a.jsx(t,{math:"\\\\mathcal{C}"}),"."]}),a.jsxs(m,{title:"Singleton Bound",proof:a.jsxs(a.Fragment,{children:[a.jsxs("p",{children:["Since equivalent codes have the same minimum distance, assume ",a.jsx(t,{math:"\\\\mathcal{C}"})," has a generator matrix ",a.jsx(t,{math:"\\\\mathbf{G}"})," where the first ",a.jsx(t,{math:"k"})," columns form ",a.jsx(t,{math:"\\\\mathbf{I}_k"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\mathbf{e}_i"})," be a message word with 1 in position ",a.jsx(t,{math:"i"})," and zeros elsewhere. The corresponding code word ",a.jsx(t,{math:"\\\\mathbf{e}_i\\\\mathbf{G}"})," is the ",a.jsx(t,{math:"i"}),"-th row of",a.jsx(t,{math:"\\\\mathbf{G}"}),", which has at least ",a.jsx(t,{math:"k - 1"})," zero entries."]}),a.jsxs("p",{className:"mt-2",children:["So the weight of this non-zero code word is at most ",a.jsx(t,{math:"n - (k - 1) = n - k + 1"}),"."]})]}),children:["If ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a linear ",a.jsx(t,{math:"[n, k, d]"})," code over ",a.jsx(t,{math:"F"}),", then ",a.jsx(t,{math:"d \\\\leq n - k + 1"}),"."]}),a.jsxs(m,{title:"Generator-Parity Check Relationship",proof:a.jsxs(a.Fragment,{children:[a.jsxs("p",{children:["Let ",a.jsx(t,{math:"\\\\mathbf{u} = (\\\\mathbf{v} \\\\, \\\\mathbf{w})"})," be the code word corresponding to message word ",a.jsx(t,{math:"\\\\mathbf{a}"}),", where ",a.jsx(t,{math:"\\\\mathbf{v}"})," is ",a.jsx(t,{math:"1 \\\\times k"})," and",a.jsx(t,{math:"\\\\mathbf{w}"})," is ",a.jsx(t,{math:"1 \\\\times (n-k)"}),"."]}),a.jsxs("p",{className:"mt-2",children:["From ",a.jsx(t,{math:"\\\\mathbf{Hu}^t = 0"}),", we have ",a.jsx(t,{math:"\\\\mathbf{v} = \\\\mathbf{a}"})," and:"]}),a.jsx(e,{math:"(\\\\mathbf{A} \\\\quad \\\\mathbf{I}_{n-k}) \\\\begin{pmatrix} \\\\mathbf{a}^t \\\\\\\\ \\\\mathbf{w}^t \\\\end{pmatrix} = 0"}),a.jsxs("p",{className:"mt-2",children:["which gives ",a.jsx(t,{math:"\\\\mathbf{Aa}^t + \\\\mathbf{w}^t = 0"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Thus ",a.jsx(t,{math:"\\\\mathbf{w} = -\\\\mathbf{aA}^t"})," and:"]}),a.jsx(e,{math:"\\\\mathbf{u} = \\\\mathbf{a}(\\\\mathbf{I}_k \\\\quad -\\\\mathbf{A}^t)"}),a.jsxs("p",{className:"mt-2",children:["Conversely, for a code word ",a.jsx(t,{math:"\\\\mathbf{u} = \\\\mathbf{aG} = (\\\\mathbf{a} \\\\, -\\\\mathbf{aA}^t)"}),":"]}),a.jsx(e,{math:"\\\\mathbf{Hu}^t = (\\\\mathbf{A} \\\\quad \\\\mathbf{I}_{n-k}) \\\\begin{pmatrix} \\\\mathbf{a}^t \\\\\\\\ -\\\\mathbf{A}\\\\mathbf{a}^t \\\\end{pmatrix} = \\\\mathbf{Aa}^t - \\\\mathbf{Aa}^t = 0"})]}),children:["If ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a linear ",a.jsx(t,{math:"[n, k, d]"})," code over ",a.jsx(t,{math:"F"})," with parity check matrix ",a.jsx(t,{math:"\\\\mathbf{H} = (\\\\mathbf{A} \\\\quad \\\\mathbf{I}_{n-k})"})," where ",a.jsx(t,{math:"\\\\mathbf{A}"})," is an ",a.jsx(t,{math:"(n-k) \\\\times k"})," matrix, then a generator matrix of ",a.jsx(t,{math:"\\\\mathcal{C}"})," is given by ",a.jsx(t,{math:"\\\\mathbf{G} = (\\\\mathbf{I}_k \\\\quad -\\\\mathbf{A}^t)"}),"."]}),a.jsx("h3",{children:"Examples"}),a.jsxs(i,{title:"Linear Codes",children:[a.jsx("p",{children:"Consider the following examples of linear codes:"}),a.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-2",children:[a.jsx("li",{children:"Every binary group code is a linear code"}),a.jsx("li",{children:"Every polynomial code and every matrix code is a linear code"}),a.jsx("li",{children:"BCH codes are linear codes, as are Hamming codes"}),a.jsx("li",{children:"Every group code over a field of 3 elements (ternary code) is a linear code"})]})]}),a.jsxs(i,{title:"Generator Matrix Examples",children:[a.jsx("p",{children:"The following binary codes are linear codes:"}),a.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[a.jsx("p",{className:"mb-2",children:a.jsx("strong",{children:"(a) Generator matrix:"})}),a.jsx(e,{math:"\\\\mathbf{A} = \\\\begin{pmatrix} 1 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 1 & 1 \\\\\\\\ 1 & 0 & 1 & 0 \\\\end{pmatrix}"}),a.jsx("p",{className:"mt-4 mb-2",children:a.jsx("strong",{children:"(b) Generator matrix:"})}),a.jsx(e,{math:"\\\\mathbf{B} = \\\\begin{pmatrix} 1 & 1 & 0 & 0 \\\\\\\\ 1 & 0 & 1 & 1 \\\\\\\\ 0 & 1 & 1 & 0 \\\\end{pmatrix}"})]}),a.jsxs("p",{className:"mt-2",children:["The codes generated by ",a.jsx(t,{math:"\\\\mathbf{A}"})," and ",a.jsx(t,{math:"\\\\mathbf{B}"})," are equivalent since ",a.jsx(t,{math:"\\\\mathbf{B} = \\\\mathbf{AP}"})," for a suitable permutation matrix ",a.jsx(t,{math:"\\\\mathbf{P}"}),"."]})]}),a.jsxs(h,{type:"success",children:[a.jsx("strong",{children:"Summary:"})," A linear ",a.jsx(t,{math:"[n, k, d]"})," code can be characterized by either:",a.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[a.jsxs("li",{children:["A ",a.jsx(t,{math:"k \\\\times n"})," generator matrix ",a.jsx(t,{math:"\\\\mathbf{G}"})," of rank ",a.jsx(t,{math:"k"})]}),a.jsxs("li",{children:["An ",a.jsx(t,{math:"(n-k) \\\\times n"})," parity check matrix ",a.jsx(t,{math:"\\\\mathbf{H}"})," of rank ",a.jsx(t,{math:"n-k"})]})]}),"In systematic form: ",a.jsx(t,{math:"\\\\mathbf{G} = (\\\\mathbf{I}_k \\\\, | \\\\, \\\\mathbf{P})"})," and",a.jsx(t,{math:"\\\\mathbf{H} = (-\\\\mathbf{P}^t \\\\, | \\\\, \\\\mathbf{I}_{n-k})"}),"."]})]})}export{b as default};
