import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a,D as r,C as t,T as n,E as d}from"./Callout-DA0JknRv.js";import{I as s,M as i}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function y(){return e.jsxs(a,{sectionId:39,children:[e.jsxs("p",{children:["Hadamard matrices are special square matrices with entries from"," ",e.jsx(s,{children:"{'{-1, +1}'}"})," that have remarkable orthogonality properties. These matrices play a fundamental role in combinatorics, signal processing, and coding theory. In this section, we study their construction and key properties."]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Definition and Basic Properties"}),e.jsxs(r,{title:"Hadamard Matrix",children:[e.jsxs("p",{children:["A ",e.jsx("strong",{children:"Hadamard matrix"})," of order ",e.jsx(s,{children:"n"})," is an"," ",e.jsx(s,{children:"n \\times n"})," matrix ",e.jsx(s,{children:"H"})," with entries"," ",e.jsx(s,{children:"\\pm 1"})," satisfying:"]}),e.jsx(i,{children:"HH^T = nI_n"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"I_n"})," is the identity matrix of order ",e.jsx(s,{children:"n"}),"."]})]}),e.jsx(t,{type:"info",title:"Orthogonality Interpretation",children:e.jsxs("p",{children:["The condition ",e.jsx(s,{children:"HH^T = nI_n"})," means that any two distinct rows of"," ",e.jsx(s,{children:"H"})," are orthogonal. Since each row has ",e.jsx(s,{children:"n"}),"entries each equal to ",e.jsx(s,{children:"\\pm 1"}),", the inner product of a row with itself is ",e.jsx(s,{children:"n"}),", while the inner product of any two distinct rows is 0."]})}),e.jsx(n,{title:"Necessary Condition for Existence",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["If ",e.jsx(s,{children:"n = 1"}),", then ",e.jsx(s,{children:"H = (1)"})," or"," ",e.jsx(s,{children:"H = (-1)"})," works."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"n = 2"}),", we can take:"]}),e.jsx(i,{children:`
              H = \begin\\{pmatrix\\} 1 & 1 \\ 1 & -1 end\\{pmatrix\\}
            `}),e.jsxs("p",{className:"mt-2",children:["Now suppose ",e.jsx(s,{children:"n {'>'} 2"})," and ",e.jsx(s,{children:"H"})," is a Hadamard matrix of order ",e.jsx(s,{children:"n"}),". By permuting rows and multiplying rows by ",e.jsx(s,{children:"-1"}),", we may assume the first row and first column consist entirely of ",e.jsx(s,{children:"+1"}),"'s."]}),e.jsxs("p",{className:"mt-2",children:["Consider rows 2 and 3. Row 1 has all ",e.jsx(s,{children:"+1"}),"'s. The orthogonality conditions give us:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Row 2 has ",e.jsx(s,{children:"n/2"})," entries equal to ",e.jsx(s,{children:"+1"})," and ",e.jsx(s,{children:"n/2"})," equal to ",e.jsx(s,{children:"-1"})]}),e.jsxs("li",{children:["Row 3 has ",e.jsx(s,{children:"n/2"})," entries equal to ",e.jsx(s,{children:"+1"})," and ",e.jsx(s,{children:"n/2"})," equal to ",e.jsx(s,{children:"-1"})]})]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{children:"a"})," be the number of positions where both rows 2 and 3 have ",e.jsx(s,{children:"+1"}),". By orthogonality of rows 2 and 3 with row 1, each row has exactly ",e.jsx(s,{children:"n/2"})," plus signs. By orthogonality of rows 2 and 3 with each other, the number of agreements minus disagreements is 0, giving ",e.jsx(s,{children:"a = n/4"}),". Hence ",e.jsx(s,{children:"n"})," is divisible by 4."]})]}),children:e.jsxs("p",{children:["If a Hadamard matrix of order ",e.jsx(s,{children:"n"})," exists, then either"," ",e.jsx(s,{children:"n = 1"}),", ",e.jsx(s,{children:"n = 2"}),", or"," ",e.jsx(s,{children:"n \\equiv 0 \\pmod 4"}),"."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"The Sylvester Construction"}),e.jsxs(r,{title:"Sylvester (Kronecker) Construction",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"Sylvester construction"})," produces Hadamard matrices of order"," ",e.jsx(s,{children:"2^k"})," recursively. Define ",e.jsx(s,{children:"H_1 = (1)"})," and:"]}),e.jsx(i,{children:`
          H_{'{'}{2^k}{'}'} = H_2 otimes H_{'{'}{2^\\{k-1\\}}{'}'} = \begin\\{pmatrix\\} H_{'{'}{2^\\{k-1\\}}{'}'} & H_{'{'}{2^\\{k-1\\}}{'}'} \\ H_{'{'}{2^\\{k-1\\}}{'}'} & -H_{'{'}{2^\\{k-1\\}}{'}'} end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"\\otimes"})," denotes the Kronecker (tensor) product."]})]}),e.jsx(n,{title:"Sylvester Matrices are Hadamard",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We prove by induction that ",e.jsx(s,{children:"H_{'{'}{2^k}{'}'}H_{'{'}{2^k}{'}'}^T = 2^k I_{'{'}{2^k}{'}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Base case: ",e.jsx(s,{children:"H_1 H_1^T = (1)(1) = 1 \\cdot I_1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Inductive step: Assume ",e.jsx(s,{children:"H_{'{'}{2^\\{k-1\\}}{'}'}H_{'{'}{2^\\{k-1\\}}{'}'}^T = 2^\\{k-1\\} I_{'{'}{2^\\{k-1\\}}{'}'}"}),". Then:"]}),e.jsx(i,{children:`
              H_{'{'}{2^k}{'}'}H_{'{'}{2^k}{'}'}^T = \begin\\{pmatrix\\} H_{'{'}{2^\\{k-1\\}}{'}'} & H_{'{'}{2^\\{k-1\\}}{'}'} \\ H_{'{'}{2^\\{k-1\\}}{'}'} & -H_{'{'}{2^\\{k-1\\}}{'}'} end\\{pmatrix\\} \begin\\{pmatrix\\} H_{'{'}{2^\\{k-1\\}}{'}'}^T & H_{'{'}{2^\\{k-1\\}}{'}'}^T \\ H_{'{'}{2^\\{k-1\\}}{'}'}^T & -H_{'{'}{2^\\{k-1\\}}{'}'}^T end\\{pmatrix\\}
            `}),e.jsx("p",{className:"mt-2",children:"Computing the product:"}),e.jsx(i,{children:`
              = \begin\\{pmatrix\\} 2H_{'{'}{2^\\{k-1\\}}{'}'}H_{'{'}{2^\\{k-1\\}}{'}'}^T & 0 \\ 0 & 2H_{'{'}{2^\\{k-1\\}}{'}'}H_{'{'}{2^\\{k-1\\}}{'}'}^T end\\{pmatrix\\} = 2 cdot 2^\\{k-1\\} I_{'{'}{2^k}{'}'} = 2^k I_{'{'}{2^k}{'}'}
            `})]}),children:e.jsxs("p",{children:["For all ",e.jsx(s,{children:"k \\geq 0"}),", the matrix ",e.jsx(s,{children:"H_{'{'}{2^k}{'}'}"}),"produced by the Sylvester construction is a Hadamard matrix of order ",e.jsx(s,{children:"2^k"}),"."]})}),e.jsxs(d,{title:"Sylvester Matrices of Small Orders",children:[e.jsx("p",{children:"The first few Sylvester-Hadamard matrices are:"}),e.jsx(i,{children:`
          H_1 = (1), quad H_2 = \begin\\{pmatrix\\} 1 & 1 \\ 1 & -1 end\\{pmatrix\\}
        `}),e.jsx(i,{children:`
          H_4 = \begin\\{pmatrix\\} 1 & 1 & 1 & 1 \\ 1 & -1 & 1 & -1 \\ 1 & 1 & -1 & -1 \\ 1 & -1 & -1 & 1 end\\{pmatrix\\}
        `}),e.jsx(i,{children:`
          H_8 = \begin\\{pmatrix\\} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ 1 & -1 & 1 & -1 & 1 & -1 & 1 & -1 \\ 1 & 1 & -1 & -1 & 1 & 1 & -1 & -1 \\ 1 & -1 & -1 & 1 & 1 & -1 & -1 & 1 \\ 1 & 1 & 1 & 1 & -1 & -1 & -1 & -1 \\ 1 & -1 & 1 & -1 & -1 & 1 & -1 & 1 \\ 1 & 1 & -1 & -1 & -1 & -1 & 1 & 1 \\ 1 & -1 & -1 & 1 & -1 & 1 & 1 & -1 end\\{pmatrix\\}
        `})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"The Paley Construction"}),e.jsxs(r,{title:"Quadratic Residue",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"p"})," be an odd prime. An integer ",e.jsx(s,{children:"a"}),"not divisible by ",e.jsx(s,{children:"p"})," is a ",e.jsx("strong",{children:"quadratic residue"}),"modulo ",e.jsx(s,{children:"p"})," if there exists ",e.jsx(s,{children:"x"})," such that"," ",e.jsx(s,{children:"x^2 \\equiv a \\pmod p"}),". Otherwise, ",e.jsx(s,{children:"a"}),"is a ",e.jsx("strong",{children:"quadratic non-residue"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"Legendre symbol"})," is defined as:"]}),e.jsx(i,{children:`
          left(\frac{'{a}{p}'}\right) = \begin\\{cases\\} 1 & \\text{if } a \\text{ is a quadratic residue mod } p \\ -1 & \\text{if } a \\text{ is a quadratic non-residue mod } p \\ 0 & \\text{if } p mid a end\\{cases\\}
        `})]}),e.jsxs(r,{title:"Paley Construction (Type I)",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"p"})," be an odd prime with"," ",e.jsx(s,{children:"p \\equiv 3 \\pmod 4"}),". Define the"," ",e.jsx(s,{children:"p \\times p"})," matrix ",e.jsx(s,{children:"Q"})," by:"]}),e.jsx(i,{children:"Q_\\{ij\\} = left(\frac{'{j - i}{p}'}\right)"}),e.jsxs("p",{className:"mt-2",children:["for ",e.jsx(s,{children:"0 \\leq i, j \\leq p-1"}),". The Paley Type I Hadamard matrix of order ",e.jsx(s,{children:"p + 1"})," is:"]}),e.jsx(i,{children:`
          H = \begin\\{pmatrix\\} 1 & \\mathbf{1}^T \\ -\\mathbf{1} & Q - I_p end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{children:"\\mathbf{1}"})," is the all-ones column vector of length"," ",e.jsx(s,{children:"p"}),"."]})]}),e.jsx(n,{title:"Paley Type I Construction is Valid",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"p \\equiv 3 \\pmod 4"}),", we have"," ",e.jsx(s,{children:"(-1/p) = -1"}),", which means ",e.jsx(s,{children:"-1"})," is a quadratic non-residue."]}),e.jsxs("p",{className:"mt-2",children:["The matrix ",e.jsx(s,{children:"Q"})," is skew-symmetric:"," ",e.jsx(s,{children:"Q^T = -Q"}),". This is because"," ",e.jsx(s,{children:"Q_\\{ji\\} = ((i-j)/p) = ((-1)/p)((j-i)/p) = -Q_\\{ij\\}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The key identity is ",e.jsx(s,{children:"QQ^T = pI_p - J_p"}),", where"," ",e.jsx(s,{children:"J_p"})," is the all-ones matrix."]}),e.jsxs("p",{className:"mt-2",children:["One can verify that ",e.jsx(s,{children:"HH^T = (p+1)I_\\{p+1\\}"})," by direct computation using these properties."]})]}),children:e.jsxs("p",{children:["If ",e.jsx(s,{children:"p"})," is an odd prime with"," ",e.jsx(s,{children:"p \\equiv 3 \\pmod 4"}),", then the Paley Type I construction yields a Hadamard matrix of order ",e.jsx(s,{children:"p + 1"}),"."]})}),e.jsxs(d,{title:"Paley Construction for p = 3",children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"p = 3"}),", the quadratic residues mod 3 are"," ",e.jsx(s,{children:"{'{1}'}"}),", so ",e.jsx(s,{children:"(1/3) = 1"})," and"," ",e.jsx(s,{children:"(2/3) = -1"}),"."]}),e.jsx(i,{children:`
          Q = \begin\\{pmatrix\\} 0 & 1 & -1 \\ -1 & 0 & 1 \\ 1 & -1 & 0 end\\{pmatrix\\}, quad Q - I_3 = \begin\\{pmatrix\\} -1 & 1 & -1 \\ -1 & -1 & 1 \\ 1 & -1 & -1 end\\{pmatrix\\}
        `}),e.jsx(i,{children:`
          H_4 = \begin\\{pmatrix\\} 1 & 1 & 1 & 1 \\ -1 & -1 & 1 & -1 \\ -1 & -1 & -1 & 1 \\ -1 & 1 & -1 & -1 end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["One can verify ",e.jsx(s,{children:"H_4 H_4^T = 4I_4"}),"."]})]}),e.jsxs(d,{title:"Paley Construction for p = 7",children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"p = 7"})," (note ",e.jsx(s,{children:"7 \\equiv 3 \\pmod 4"}),"), the quadratic residues mod 7 are ",e.jsx(s,{children:"{'{1, 2, 4}'}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The Paley construction yields a Hadamard matrix of order 8, which is equivalent (up to row/column permutations and sign changes) to the Sylvester matrix"," ",e.jsx(s,{children:"H_8"}),"."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"The Hadamard Conjecture"}),e.jsxs(t,{type:"warning",title:"The Hadamard Conjecture",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Hadamard Conjecture:"})," A Hadamard matrix of order ",e.jsx(s,{children:"n"}),"exists for every ",e.jsx(s,{children:"n"})," divisible by 4."]}),e.jsxs("p",{className:"mt-2",children:["This famous conjecture remains open. As of now, Hadamard matrices have been constructed for all orders ",e.jsx(s,{children:"n = 4k"})," with"," ",e.jsx(s,{children:"k \\leq 166"}),", but the smallest undecided case is"," ",e.jsx(s,{children:"n = 668"}),"."]})]}),e.jsxs(n,{title:"Known Existence Results",children:[e.jsx("p",{children:"Hadamard matrices exist for the following orders:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:e.jsx(s,{children:"n = 1, 2"})}),e.jsxs("li",{children:[e.jsx(s,{children:"n = 2^k"})," for all ",e.jsx(s,{children:"k \\geq 0"})," (Sylvester construction)"]}),e.jsxs("li",{children:[e.jsx(s,{children:"n = p + 1"})," where ",e.jsx(s,{children:"p \\equiv 3 \\pmod 4"})," is prime (Paley Type I)"]}),e.jsxs("li",{children:[e.jsx(s,{children:"n = 2(p + 1)"})," where ",e.jsx(s,{children:"p \\equiv 1 \\pmod 4"})," is prime (Paley Type II)"]}),e.jsxs("li",{children:[e.jsx(s,{children:"n = mn"})," if Hadamard matrices of orders ",e.jsx(s,{children:"m"})," and ",e.jsx(s,{children:"n"})," exist (Kronecker product)"]})]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Normalized Hadamard Matrices"}),e.jsxs(r,{title:"Normalized Hadamard Matrix",children:[e.jsxs("p",{children:["A Hadamard matrix is ",e.jsx("strong",{children:"normalized"})," if its first row and first column consist entirely of ",e.jsx(s,{children:"+1"}),"'s."]}),e.jsxs("p",{className:"mt-2",children:["Any Hadamard matrix can be normalized by multiplying appropriate rows and columns by ",e.jsx(s,{children:"-1"}),"."]})]}),e.jsxs(n,{title:"Properties of Normalized Hadamard Matrices",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["If ",e.jsx(s,{children:"H"})," is normalized, the first row is all"," ",e.jsx(s,{children:"+1"}),"'s. For any other row to be orthogonal to the first row, it must have equal numbers of ",e.jsx(s,{children:"+1"}),"'s and"," ",e.jsx(s,{children:"-1"}),"'s, hence ",e.jsx(s,{children:"n/2"})," of each."]}),e.jsxs("p",{className:"mt-2",children:["For a ",e.jsx(s,{children:"2 \\times 2"})," submatrix formed by two non-first rows, orthogonality forces each of the four ",e.jsx(s,{children:"(\\pm 1, \\pm 1)"}),"patterns to appear equally often, hence ",e.jsx(s,{children:"n/4"})," times each."]})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"H"})," be a normalized Hadamard matrix of order"," ",e.jsx(s,{children:"n \\geq 2"}),". Then:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2",children:[e.jsxs("li",{children:["Each row (except the first) has exactly ",e.jsx(s,{children:"n/2"})," entries equal to ",e.jsx(s,{children:"+1"})," and ",e.jsx(s,{children:"n/2"})," entries equal to ",e.jsx(s,{children:"-1"}),"."]}),e.jsxs("li",{children:["For ",e.jsx(s,{children:"n \\geq 4"}),", any two rows (other than the first) agree in exactly ",e.jsx(s,{children:"n/4"})," of the non-first columns and disagree in exactly ",e.jsx(s,{children:"n/4"})," of them."]})]})]}),e.jsx(t,{type:"success",title:"Connection to Coding Theory",children:e.jsxs("p",{children:["The rows of a normalized Hadamard matrix (after conversion from"," ",e.jsx(s,{children:"{'{-1, +1}'}"})," to ",e.jsx(s,{children:"{'{1, 0}'}"}),"via ",e.jsx(s,{children:"-1 \\mapsto 1"}),", ",e.jsx(s,{children:"+1 \\mapsto 0"}),") form the basis for Hadamard codes, which we will study in the next section."]})})]})}export{y as default};
