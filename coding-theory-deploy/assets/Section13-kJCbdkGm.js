import{j as t}from"./vendor-animation-0o8UKZ_1.js";import{L as r,D as i,C as h,E as s,T as m}from"./Callout-BFDudfNm.js";import{I as e,M as a}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function y(){return t.jsxs(r,{sectionId:13,children:[t.jsx("h2",{children:"Weight Distribution of Dual Codes"}),t.jsx("p",{children:"The weight distribution of a code provides essential information about its error-detecting and error-correcting capabilities. A remarkable result known as the MacWilliams identity relates the weight distribution of a code to that of its dual."}),t.jsx("h3",{children:"Weight Enumerator Polynomials"}),t.jsxs(i,{title:"Weight Distribution",children:["Let ",t.jsx(e,{math:"\\mathcal{C}"})," be a code of length ",t.jsx(e,{math:"n"})," over ",t.jsx(e,{math:"F = GF(q)"}),". For ",t.jsx(e,{math:"i = 0, 1, \\ldots, n"}),", let ",t.jsx(e,{math:"A_i"})," denote the number of code words of weight ",t.jsx(e,{math:"i"})," in ",t.jsx(e,{math:"\\mathcal{C}"}),". The sequence",t.jsx(e,{math:"(A_0, A_1, \\ldots, A_n)"})," is called the ",t.jsx("strong",{children:"weight distribution"})," of ",t.jsx(e,{math:"\\mathcal{C}"}),"."]}),t.jsxs(h,{type:"info",children:[t.jsx("strong",{children:"Basic Properties:"}),t.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[t.jsxs("li",{children:[t.jsx(e,{math:"A_0 = 1"})," (the zero vector has weight 0)"]}),t.jsxs("li",{children:[t.jsx(e,{math:"\\sum_{i=0}^{n} A_i = |\\mathcal{C}|"})," (total number of code words)"]}),t.jsxs("li",{children:["For a linear ",t.jsx(e,{math:"[n, k, d]"})," code, ",t.jsx(e,{math:"A_i = 0"})," for ",t.jsx(e,{math:"1 \\leq i < d"})]})]})]}),t.jsxs(i,{title:"Weight Enumerator Polynomial",children:["The ",t.jsx("strong",{children:"weight enumerator polynomial"})," of a code ",t.jsx(e,{math:"\\mathcal{C}"})," with weight distribution ",t.jsx(e,{math:"(A_0, A_1, \\ldots, A_n)"})," is the polynomial:",t.jsx(a,{math:"W_{\\mathcal{C}}(x, y) = \\sum_{i=0}^{n} A_i x^{n-i} y^i"}),"Alternatively, in one variable:",t.jsx(a,{math:"W_{\\mathcal{C}}(z) = \\sum_{i=0}^{n} A_i z^i = W_{\\mathcal{C}}(1, z)"})]}),t.jsxs(s,{title:"Weight Enumerator of a Simple Code",children:[t.jsxs("p",{children:["Consider the binary ",t.jsx(e,{math:"[4, 2]"})," code:"]}),t.jsx(a,{math:"\\mathcal{C} = \\{0000, 1100, 0011, 1111\\}"}),t.jsx("p",{className:"mt-2",children:"The weights are:"}),t.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[t.jsx("li",{children:t.jsx(e,{math:"\\text{wt}(0000) = 0"})}),t.jsx("li",{children:t.jsx(e,{math:"\\text{wt}(1100) = 2"})}),t.jsx("li",{children:t.jsx(e,{math:"\\text{wt}(0011) = 2"})}),t.jsx("li",{children:t.jsx(e,{math:"\\text{wt}(1111) = 4"})})]}),t.jsxs("p",{className:"mt-2",children:["So the weight distribution is ",t.jsx(e,{math:"(A_0, A_1, A_2, A_3, A_4) = (1, 0, 2, 0, 1)"}),"."]}),t.jsx("p",{className:"mt-2",children:"The weight enumerator polynomial is:"}),t.jsx(a,{math:"W_{\\mathcal{C}}(x, y) = x^4 + 2x^2y^2 + y^4"})]}),t.jsxs(s,{title:"Weight Enumerator of the (4, 7) Hamming Code",children:[t.jsxs("p",{children:["The ",t.jsx(e,{math:"[7, 4, 3]"})," Hamming code has 16 code words. Direct enumeration shows:"]}),t.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[t.jsx("li",{children:"1 code word of weight 0 (the zero word)"}),t.jsx("li",{children:"0 code words of weight 1 or 2 (minimum distance is 3)"}),t.jsx("li",{children:"7 code words of weight 3"}),t.jsx("li",{children:"7 code words of weight 4"}),t.jsx("li",{children:"0 code words of weight 5 or 6"}),t.jsx("li",{children:"1 code word of weight 7 (the all-ones word)"})]}),t.jsx("p",{className:"mt-2",children:"The weight enumerator is:"}),t.jsx(a,{math:"W_{\\mathcal{C}}(x, y) = x^7 + 7x^4y^3 + 7x^3y^4 + y^7"})]}),t.jsx("h3",{children:"The MacWilliams Identity"}),t.jsxs("p",{children:["The MacWilliams identity is a fundamental theorem that expresses the weight enumerator of the dual code ",t.jsx(e,{math:"\\mathcal{C}^\\perp"})," in terms of the weight enumerator of ",t.jsx(e,{math:"\\mathcal{C}"}),"."]}),t.jsxs(m,{title:"MacWilliams Identity",proof:t.jsxs(t.Fragment,{children:[t.jsxs("p",{children:["We present the key ideas of the proof. For each ",t.jsx(e,{math:"\\mathbf{u} \\in V(n, q)"}),", define the character sum:"]}),t.jsx(a,{math:"\\chi_{\\mathbf{u}}(\\mathbf{v}) = \\omega^{\\mathbf{u} \\cdot \\mathbf{v}}"}),t.jsxs("p",{className:"mt-2",children:["where ",t.jsx(e,{math:"\\omega = e^{2\\pi i/p}"})," is a primitive ",t.jsx(e,{math:"p"}),"-th root of unity and ",t.jsx(e,{math:"p"})," is the characteristic of ",t.jsx(e,{math:"F"}),"."]}),t.jsxs("p",{className:"mt-2",children:["The key lemma is that for a linear code ",t.jsx(e,{math:"\\mathcal{C}"}),":"]}),t.jsx(a,{math:"\\sum_{\\mathbf{c} \\in \\mathcal{C}} \\chi_{\\mathbf{u}}(\\mathbf{c}) = \\begin{cases} |\\mathcal{C}| & \\text{if } \\mathbf{u} \\in \\mathcal{C}^\\perp \\\\ 0 & \\text{if } \\mathbf{u} \\notin \\mathcal{C}^\\perp \\end{cases}"}),t.jsxs("p",{className:"mt-2",children:["Using this and the Poisson summation formula over the group ",t.jsx(e,{math:"\\mathcal{C}"}),", one obtains after careful analysis:"]}),t.jsx(a,{math:"\\sum_{\\mathbf{u} \\in \\mathcal{C}^\\perp} x^{n - \\text{wt}(\\mathbf{u})} y^{\\text{wt}(\\mathbf{u})} = \\frac{1}{|\\mathcal{C}|} \\sum_{\\mathbf{c} \\in \\mathcal{C}} (x + (q-1)y)^{n - \\text{wt}(\\mathbf{c})} (x - y)^{\\text{wt}(\\mathbf{c})}"}),t.jsxs("p",{className:"mt-2",children:["The left side is ",t.jsx(e,{math:"W_{\\mathcal{C}^\\perp}(x, y)"}),". The right side simplifies to",t.jsx(e,{math:"\\frac{1}{|\\mathcal{C}|} W_{\\mathcal{C}}(x + (q-1)y, x - y)"}),"."]})]}),children:["Let ",t.jsx(e,{math:"\\mathcal{C}"})," be a linear ",t.jsx(e,{math:"[n, k]"})," code over ",t.jsx(e,{math:"GF(q)"}),". Then the weight enumerator of the dual code ",t.jsx(e,{math:"\\mathcal{C}^\\perp"})," satisfies:",t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = \\frac{1}{|\\mathcal{C}|} W_{\\mathcal{C}}(x + (q-1)y, x - y)"}),"In the binary case (",t.jsx(e,{math:"q = 2"}),"):",t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = \\frac{1}{|\\mathcal{C}|} W_{\\mathcal{C}}(x + y, x - y)"})]}),t.jsxs(h,{type:"warning",children:[t.jsx("strong",{children:"Importance:"})," The MacWilliams identity allows us to compute the weight distribution of ",t.jsx(e,{math:"\\mathcal{C}^\\perp"})," from that of ",t.jsx(e,{math:"\\mathcal{C}"})," without explicitly constructing the dual code."]}),t.jsxs(s,{title:"Applying MacWilliams Identity",children:[t.jsxs("p",{children:["Consider the self-dual ",t.jsx(e,{math:"[4, 2]"})," code from before with:"]}),t.jsx(a,{math:"W_{\\mathcal{C}}(x, y) = x^4 + 2x^2y^2 + y^4"}),t.jsxs("p",{className:"mt-2",children:["Since ",t.jsx(e,{math:"\\mathcal{C}"})," is self-dual, ",t.jsx(e,{math:"\\mathcal{C}^\\perp = \\mathcal{C}"}),", so ",t.jsx(e,{math:"W_{\\mathcal{C}^\\perp} = W_{\\mathcal{C}}"}),"."]}),t.jsxs("p",{className:"mt-2",children:["Let us verify this using the MacWilliams identity with ",t.jsx(e,{math:"q = 2"}),":"]}),t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = \\frac{1}{4} W_{\\mathcal{C}}(x + y, x - y)"}),t.jsx("p",{className:"mt-2",children:"Substituting:"}),t.jsx(a,{math:"W_{\\mathcal{C}}(x + y, x - y) = (x + y)^4 + 2(x + y)^2(x - y)^2 + (x - y)^4"}),t.jsx("p",{className:"mt-2",children:"Expanding each term:"}),t.jsx(a,{math:"(x + y)^4 = x^4 + 4x^3y + 6x^2y^2 + 4xy^3 + y^4"}),t.jsx(a,{math:"(x - y)^4 = x^4 - 4x^3y + 6x^2y^2 - 4xy^3 + y^4"}),t.jsx(a,{math:"(x + y)^2(x - y)^2 = (x^2 - y^2)^2 = x^4 - 2x^2y^2 + y^4"}),t.jsx("p",{className:"mt-2",children:"Adding these:"}),t.jsx(a,{math:"(x + y)^4 + (x - y)^4 = 2x^4 + 12x^2y^2 + 2y^4"}),t.jsx(a,{math:"2(x + y)^2(x - y)^2 = 2x^4 - 4x^2y^2 + 2y^4"}),t.jsx("p",{className:"mt-2",children:"Total:"}),t.jsx(a,{math:"W_{\\mathcal{C}}(x + y, x - y) = 4x^4 + 8x^2y^2 + 4y^4"}),t.jsx("p",{className:"mt-2",children:"Dividing by 4:"}),t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = x^4 + 2x^2y^2 + y^4 = W_{\\mathcal{C}}(x, y) \\,\\, \\checkmark"})]}),t.jsxs(s,{title:"Dual Weight Enumerator of Hamming Code",children:[t.jsxs("p",{children:["The ",t.jsx(e,{math:"[7, 4, 3]"})," Hamming code has weight enumerator:"]}),t.jsx(a,{math:"W_{\\mathcal{C}}(x, y) = x^7 + 7x^4y^3 + 7x^3y^4 + y^7"}),t.jsxs("p",{className:"mt-2",children:["Its dual is the ",t.jsx(e,{math:"[7, 3, 4]"})," simplex code. Using the MacWilliams identity:"]}),t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = \\frac{1}{16} W_{\\mathcal{C}}(x + y, x - y)"}),t.jsx("p",{className:"mt-2",children:"After computation:"}),t.jsx(a,{math:"W_{\\mathcal{C}^\\perp}(x, y) = x^7 + 7x^3y^4"}),t.jsx("p",{className:"mt-2",children:"This shows the simplex code has 1 code word of weight 0 and 7 code words of weight 4. In particular, all non-zero code words have the same weight (4), which is a characteristic property of simplex codes."})]}),t.jsx("h3",{children:"Applications of Weight Enumerators"}),t.jsxs(m,{title:"Error Probability Bound",proof:t.jsxs(t.Fragment,{children:[t.jsxs("p",{children:["In a binary symmetric channel with crossover probability ",t.jsx(e,{math:"p"}),", a code word ",t.jsx(e,{math:"\\mathbf{c}"})," can be decoded incorrectly if the received word is closer to some other code word ",t.jsx(e,{math:"\\mathbf{c}'"}),"."]}),t.jsxs("p",{className:"mt-2",children:["The probability that exactly ",t.jsx(e,{math:"i"})," bits are flipped is:"]}),t.jsx(a,{math:"P(\\text{wt}(\\mathbf{e}) = i) = \\binom{n}{i} p^i (1-p)^{n-i}"}),t.jsxs("p",{className:"mt-2",children:["For minimum distance decoding, an error occurs if more than ",t.jsx(e,{math:"\\lfloor (d-1)/2 \\rfloor"})," bits are flipped. The weight enumerator provides bounds on this probability."]})]}),children:["For a linear ",t.jsx(e,{math:"[n, k, d]"})," code used over a binary symmetric channel with crossover probability ",t.jsx(e,{math:"p"}),", the probability of undetected error when using the code for error detection is:",t.jsx(a,{math:"P_{\\text{und}} = \\sum_{i=1}^{n} A_i p^i (1-p)^{n-i} = W_{\\mathcal{C}}(1-p, p) - (1-p)^n"})]}),t.jsxs(h,{type:"success",children:[t.jsx("strong",{children:"Summary:"})," The weight enumerator polynomial captures essential information about a code:",t.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[t.jsxs("li",{children:["The minimum distance (smallest ",t.jsx(e,{math:"i > 0"})," with ",t.jsx(e,{math:"A_i \\neq 0"}),")"]}),t.jsx("li",{children:"Error detection and correction capabilities"}),t.jsx("li",{children:"Through MacWilliams identity, the weight distribution of the dual code"}),t.jsx("li",{children:"Bounds on error probabilities in communication channels"})]})]}),t.jsxs(i,{title:"Distance Enumerator",children:["The ",t.jsx("strong",{children:"distance enumerator"})," of a code ",t.jsx(e,{math:"\\mathcal{C}"})," is:",t.jsx(a,{math:"D_{\\mathcal{C}}(x, y) = \\frac{1}{|\\mathcal{C}|} \\sum_{\\mathbf{u}, \\mathbf{v} \\in \\mathcal{C}} x^{n - d(\\mathbf{u}, \\mathbf{v})} y^{d(\\mathbf{u}, \\mathbf{v})}"}),"For linear codes, ",t.jsx(e,{math:"D_{\\mathcal{C}}(x, y) = W_{\\mathcal{C}}(x, y)"})," since",t.jsx(e,{math:"d(\\mathbf{u}, \\mathbf{v}) = \\text{wt}(\\mathbf{u} - \\mathbf{v})"}),"."]})]})}export{y as default};
