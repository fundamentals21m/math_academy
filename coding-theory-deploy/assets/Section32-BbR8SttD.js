import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l,D as a,C as s,T as n,E as r}from"./Callout-DA0JknRv.js";import{I as i,M as t}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function b(){return e.jsxs(l,{sectionId:32,children:[e.jsx("p",{children:"In this section, we establish necessary and sufficient conditions for a linear code to be a Maximum Distance Separable (MDS) code. These codes are particularly important because they achieve the maximum possible error detection and correction capability for their given length and dimension."}),e.jsxs(a,{title:"Maximum Distance Separable (MDS) Code",children:[e.jsxs("p",{children:["A linear ",e.jsx(i,{children:"[n, k, d]"})," code over a field ",e.jsx(i,{children:"F"})," with"," ",e.jsx(i,{children:"d = n - k + 1"})," is called a ",e.jsx("strong",{children:"maximum distance separable (MDS) code"}),"."]}),e.jsx("p",{className:"mt-2",children:"This means the code achieves the Singleton bound with equality, providing the best possible minimum distance for the given parameters."})]}),e.jsxs(s,{type:"info",title:"Why MDS Codes Matter",children:["MDS codes have the maximum possible error detection and correction capability. For a code with ",e.jsx(i,{children:"n - k"})," redundant symbols, an MDS code can detect up to"," ",e.jsx(i,{children:"n - k"})," errors and correct up to ",e.jsx(i,{children:"\\lfloor (n-k)/2 \\rfloor"})," errors."]}),e.jsx(n,{title:"Characterization via Parity Check Matrix",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Necessity:"})," Suppose ",e.jsx(i,{children:"mathcal{C}"})," is an MDS code. Then ",e.jsx(i,{children:"d = n - k + 1"}),", so there is no non-zero code word of weight at most ",e.jsx(i,{children:"n - k"}),". By the relationship between code words and linear dependence of columns (Proposition 9.1), every ",e.jsx(i,{children:"n - k"})," columns of ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Sufficiency:"})," Suppose every ",e.jsx(i,{children:"n - k"})," columns of"," ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent. Then there is no non-zero code word of weight at most ",e.jsx(i,{children:"n - k"}),". Therefore"," ",e.jsx(i,{children:"d \\geq n - k + 1"}),". But ",e.jsx(i,{children:"d \\leq n - k + 1"})," always, so ",e.jsx(i,{children:"d = n - k + 1"}),"."]})]}),children:e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathcal{C}"})," be a linear ",e.jsx(i,{children:"[n, k, d]"})," code over ",e.jsx(i,{children:"F"})," with a parity check matrix ",e.jsx(i,{children:"mathbf{H}"}),". Then ",e.jsx(i,{children:"mathcal{C}"})," is an MDS code if and only if every"," ",e.jsx(i,{children:"n - k"})," columns of ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent."]})}),e.jsx(n,{title:"Dual of an MDS Code",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Since ",e.jsx(i,{children:"mathcal{C}^perp"})," is a linear ",e.jsx(i,{children:"[n, n-k, -]"})," code, let ",e.jsx(i,{children:"d_1"})," be its minimum distance. Then"," ",e.jsx(i,{children:"d_1 \\leq n - (n-k) + 1 = k + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(i,{children:"mathbf{H}"})," be a parity check matrix of ",e.jsx(i,{children:"mathcal{C}"}),". Since ",e.jsx(i,{children:"mathcal{C}"})," is MDS, every ",e.jsx(i,{children:"n - k"})," columns of ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent."]}),e.jsxs("p",{className:"mt-2",children:["If any ",e.jsx(i,{children:"k"})," columns of ",e.jsx(i,{children:"mathbf{H}"})," are omitted, the remaining columns form a square submatrix of rank ",e.jsx(i,{children:"n - k"}),". This means a code word of ",e.jsx(i,{children:"mathcal{C}^perp"})," with at least"," ",e.jsx(i,{children:"n - k"})," zeros must be zero. Thus ",e.jsx(i,{children:"d_1 \\geq k + 1"}),", giving ",e.jsx(i,{children:"d_1 = k + 1"}),"."]})]}),children:e.jsxs("p",{children:["If a linear ",e.jsx(i,{children:"[n, k, d]"})," code ",e.jsx(i,{children:"mathcal{C}"})," is MDS, then so is its dual ",e.jsx(i,{children:"mathcal{C}^perp"}),"."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Equivalent Conditions for MDS Codes"}),e.jsxs(n,{title:"Equivalent Characterizations",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"Equivalence of (i) and (iii) follows from the first theorem above."}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(i,{children:"mathbf{G}"})," be a generator matrix of ",e.jsx(i,{children:"mathcal{C}"}),". By Theorem 5.2, ",e.jsx(i,{children:"mathbf{G}"})," is a parity check matrix of"," ",e.jsx(i,{children:"mathcal{C}^perp"})," which is an ",e.jsx(i,{children:"[n, n-k, -]"})," linear code."]}),e.jsxs("p",{className:"mt-2",children:["Therefore ",e.jsx(i,{children:"mathcal{C}^perp"})," is MDS iff every ",e.jsx(i,{children:"k"})," columns of ",e.jsx(i,{children:"mathbf{G}"})," are linearly independent. Since"," ",e.jsx(i,{children:"(mathcal{C}^perp)^perp = mathcal{C}"}),", it follows that"," ",e.jsx(i,{children:"mathcal{C}"})," is MDS iff ",e.jsx(i,{children:"mathcal{C}^perp"})," is MDS. Hence (i) is equivalent to (ii)."]})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathcal{C}"})," be an ",e.jsx(i,{children:"[n, k, d]"})," linear code over ",e.jsx(i,{children:"F = 	ext{GF}(q)"}),". Then the following statements are equivalent:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(i,{children:"mathcal{C}"})," is MDS"]}),e.jsxs("li",{children:["Every ",e.jsx(i,{children:"k"})," columns of a generator matrix ",e.jsx(i,{children:"mathbf{G}"})," are linearly independent"]}),e.jsxs("li",{children:["Every ",e.jsx(i,{children:"n - k"})," columns of a parity check matrix ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent"]})]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Standard Form Criterion"}),e.jsxs(n,{title:"Non-singularity Condition",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathbf{B}_r"})," be a square submatrix of ",e.jsx(i,{children:"mathbf{A}"}),"constituted by parts of the ",e.jsx(i,{children:"i_1"}),"th, ",e.jsx(i,{children:"i_2"}),"th, ...,"," ",e.jsx(i,{children:"i_r"}),"th rows with ",e.jsxs(i,{children:["i_1 ","<"," i_2 ","<"," \\\\cdots ","<"," i_r \\\\leq n - k"]}),"."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(i,{children:"mathbf{M}_r"})," be the square submatrix of ",e.jsx(i,{children:"mathbf{H}"})," of order ",e.jsx(i,{children:"n - k"})," constituted by the columns of ",e.jsx(i,{children:"mathbf{A}"})," appearing in ",e.jsx(i,{children:"mathbf{B}_r"})," and the remaining ",e.jsx(i,{children:"n - k - r"})," columns from ",e.jsx(i,{children:"mathbf{I}_{n-k}"})," different from the ",e.jsx(i,{children:"i_1"}),"th, ...,"," ",e.jsx(i,{children:"i_r"}),"th columns."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(i,{children:"det mathbf{M}_r = pm det mathbf{B}_r"}),", so"," ",e.jsx(i,{children:"mathbf{B}_r"})," is non-singular iff ",e.jsx(i,{children:"mathbf{M}_r"})," is. Therefore, every ",e.jsx(i,{children:"n - k"})," columns of ",e.jsx(i,{children:"mathbf{H}"})," are linearly independent iff every square submatrix of ",e.jsx(i,{children:"mathbf{A}"})," is non-singular."]})]}),children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathcal{C}"})," be an ",e.jsx(i,{children:"[n, k, -]"})," code with parity check matrix:"]}),e.jsx(t,{children:`
          \\mathbf{H} = (\\mathbf{A} \\mid \\mathbf{I}_{n-k})
        `}),e.jsxs("p",{children:["Then ",e.jsx(i,{children:"mathcal{C}"})," is an MDS code if and only if every square submatrix of ",e.jsx(i,{children:"mathbf{A}"})," is non-singular."]})]}),e.jsxs(r,{title:"MDS Code over GF(7)",children:[e.jsxs("p",{children:["Consider the matrix over ",e.jsx(i,{children:"	ext{GF}(7)"}),":"]}),e.jsx(t,{children:`
          \\mathbf{A} = \\begin{pmatrix} 1 & 6 & 2 & 5 & 1 \\\\ 1 & 4 & 3 & 3 & 6 \\\\ 1 & 5 & 5 & 1 & 5 \\end{pmatrix}
        `}),e.jsxs("p",{className:"mt-2",children:["Every ",e.jsx(i,{children:"2 \\times 2"})," submatrix is non-singular, and computing all"," ",e.jsx(i,{children:"\binom{5}{3} = 10"})," determinants of ",e.jsx(i,{children:"3 \\times 3"})," submatrices shows they are all non-zero in ",e.jsx(i,{children:"	ext{GF}(7)"}),"."]}),e.jsx("p",{className:"mt-2",children:"Therefore:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["The ",e.jsx(i,{children:"[8, 3, -]"})," code with generator matrix ",e.jsx(i,{children:"mathbf{G} = (mathbf{I}_3 mid mathbf{A})"})," is MDS"]}),e.jsxs("li",{children:["The ",e.jsx(i,{children:"[8, 5, -]"})," code with parity check matrix ",e.jsx(i,{children:"mathbf{H} = (mathbf{A} mid mathbf{I}_3)"})," is MDS"]})]})]}),e.jsxs(r,{title:"Binary MDS Codes",children:[e.jsxs("p",{children:["The only binary MDS codes are the ",e.jsx("strong",{children:"trivial codes"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(i,{children:"[n, 1, n]"})," - repetition code"]}),e.jsxs("li",{children:[e.jsx(i,{children:"[n, n-1, 2]"})," - parity check code"]}),e.jsxs("li",{children:[e.jsx(i,{children:"[n, n, 1]"})," - full space"]})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Proof:"})," If ",e.jsx(i,{children:"k {'>'} 1"})," and"," ",e.jsx(i,{children:"n {'>'} k + 1"}),", then a generator matrix in standard form has a column of weight less than ",e.jsx(i,{children:"k"})," and greater than 1. If the"," ",e.jsx(i,{children:"i"}),"th entry of this column is 0, then ",e.jsx(i,{children:"k"})," columns (the first ",e.jsx(i,{children:"k"})," except the ",e.jsx(i,{children:"i"}),"th, plus this column) are linearly dependent. Thus no non-trivial binary MDS code exists."]})]}),e.jsx(s,{type:"note",title:"Key Insight",children:"The characterization of MDS codes via the non-singularity of all square submatrices provides a practical method for verifying whether a code is MDS. This condition will be crucial when we study the existence problem for MDS codes."})]})}export{b as default};
