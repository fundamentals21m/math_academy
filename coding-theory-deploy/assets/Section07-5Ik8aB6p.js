import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a,D as t,E as n,T as i,C as d}from"./Callout-BFDudfNm.js";import{I as r,M as s}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function b(){return e.jsxs(a,{sectionId:7,children:[e.jsx("h2",{children:"3.2 Hamming Codes"}),e.jsx("p",{children:"Hamming codes, invented by Richard Hamming in 1950, are among the most elegant and historically important error-correcting codes. They provide a systematic method for constructing single-error-correcting codes with optimal efficiency."}),e.jsx("h3",{children:"Construction of Hamming Codes"}),e.jsxs(t,{title:"Hamming Code",children:[e.jsxs("p",{children:["For any integer ",e.jsx(r,{children:"r \\geq 2"}),", the ",e.jsx("strong",{children:"Hamming code"})," ",e.jsx(r,{children:"\\mathcal{H}_r"})," is defined by a parity check matrix ",e.jsx(r,{children:"\\mathbf{H}"})," whose columns are all the non-zero binary vectors of length ",e.jsx(r,{children:"r"}),", arranged in order of increasing value when interpreted as binary numbers."]}),e.jsx("p",{className:"mt-2",children:"The code has parameters:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Code length: ",e.jsx(r,{children:"n = 2^r - 1"})]}),e.jsxs("li",{children:["Number of message bits: ",e.jsx(r,{children:"k = 2^r - 1 - r"})]}),e.jsxs("li",{children:["Number of parity check bits: ",e.jsx(r,{children:"r"})]}),e.jsxs("li",{children:["Minimum distance: ",e.jsx(r,{children:"d = 3"})]})]})]}),e.jsxs(n,{title:"The (7, 4) Hamming Code",children:[e.jsxs("p",{children:["For ",e.jsx(r,{children:"r = 3"}),", we get ",e.jsx(r,{children:"n = 2^3 - 1 = 7"})," and ",e.jsx(r,{children:"k = 7 - 3 = 4"}),"."]}),e.jsx("p",{className:"mt-2",children:"The parity check matrix has columns 1, 2, 3, 4, 5, 6, 7 in binary:"}),e.jsx(s,{children:"\\mathbf{H} = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"Column positions correspond to integers:"}),e.jsxs("div",{className:"bg-dark-800/50 p-3 rounded-lg mt-2 font-mono text-sm",children:[e.jsx("p",{children:"Column 1: 001 (binary) = 1"}),e.jsx("p",{children:"Column 2: 010 (binary) = 2"}),e.jsx("p",{children:"Column 3: 011 (binary) = 3"}),e.jsx("p",{children:"Column 4: 100 (binary) = 4"}),e.jsx("p",{children:"Column 5: 101 (binary) = 5"}),e.jsx("p",{children:"Column 6: 110 (binary) = 6"}),e.jsx("p",{children:"Column 7: 111 (binary) = 7"})]})]}),e.jsx("h3",{children:"Why Hamming Codes Work"}),e.jsx(i,{title:"Hamming Codes Correct Single Errors",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The columns of ",e.jsx(r,{children:"\\mathbf{H}"})," are all ",e.jsx(r,{children:"2^r - 1"})," non-zero binary ",e.jsx(r,{children:"r"}),"-tuples. By construction:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"All columns are non-zero"}),e.jsxs("li",{children:["All columns are distinct (each represents a different integer from 1 to ",e.jsx(r,{children:"2^r - 1"}),")"]})]}),e.jsx("p",{className:"mt-2",children:"By Theorem 1.5, a parity check matrix with non-zero, distinct columns can decode all single errors correctly."})]}),children:e.jsxs("p",{children:["The Hamming code ",e.jsx(r,{children:"\\mathcal{H}_r"})," can correct any single error."]})}),e.jsx("h3",{children:"The Syndrome Directly Indicates Error Position"}),e.jsxs(d,{type:"info",children:[e.jsx("strong",{children:"The Magic of Hamming Codes:"})," When a single error occurs in position ",e.jsx(r,{children:"i"}),", the syndrome is exactly the binary representation of ",e.jsx(r,{children:"i"}),"!",e.jsx("p",{className:"mt-2",children:"This makes decoding extremely simple: compute the syndrome, interpret it as a binary number, and flip the bit at that position."})]}),e.jsx(i,{title:"Syndrome Equals Error Position",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(r,{children:"\\mathbf{b}"})," be a code word and suppose an error occurs in position ",e.jsx(r,{children:"i"}),". The received word is ",e.jsx(r,{children:"\\mathbf{r} = \\mathbf{b} + \\mathbf{e}^i"}),", where ",e.jsx(r,{children:"\\mathbf{e}^i"})," has a 1 in position ",e.jsx(r,{children:"i"})," and 0s elsewhere."]}),e.jsx("p",{className:"mt-2",children:"The syndrome is:"}),e.jsx(s,{children:"\\mathbf{s} = \\mathbf{Hr}^t = \\mathbf{H}(\\mathbf{b} + \\mathbf{e}^i)^t = \\mathbf{Hb}^t + \\mathbf{H}(\\mathbf{e}^i)^t"}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(r,{children:"\\mathbf{b}"})," is a code word, ",e.jsx(r,{children:"\\mathbf{Hb}^t = \\mathbf{0}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The product ",e.jsx(r,{children:"\\mathbf{H}(\\mathbf{e}^i)^t"})," selects the ",e.jsx(r,{children:"i"}),"-th column of ",e.jsx(r,{children:"\\mathbf{H}"}),", which by construction is the binary representation of ",e.jsx(r,{children:"i"}),"."]})]}),children:e.jsxs("p",{children:["In a Hamming code, if a single error occurs in position ",e.jsx(r,{children:"i"}),", the syndrome ",e.jsx(r,{children:"\\mathbf{s} = \\mathbf{Hr}^t"})," equals the binary representation of ",e.jsx(r,{children:"i"}),"."]})}),e.jsxs(n,{title:"Decoding with the (7, 4) Hamming Code",children:[e.jsxs("p",{children:["Suppose we receive the word ",e.jsx(r,{children:"\\mathbf{r} = (1, 0, 1, 1, 0, 0, 1)"}),"."]}),e.jsx("p",{className:"mt-2",children:"Compute the syndrome:"}),e.jsx(s,{children:"\\mathbf{s} = \\mathbf{Hr}^t = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}"}),e.jsx(s,{children:"= \\begin{pmatrix} 1 + 1 \\\\ 1 + 1 \\\\ 1 + 1 + 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = (001)_2 = 1"}),e.jsxs("p",{className:"mt-2",children:["The syndrome ",e.jsx(r,{children:"(001)_2 = 1"})," indicates an error in position 1."]}),e.jsx("p",{className:"mt-2",children:"Correct by flipping bit 1:"}),e.jsx(s,{children:"\\mathbf{c} = (0, 0, 1, 1, 0, 0, 1)"}),e.jsxs("p",{className:"mt-2 text-emerald-400",children:["The decoded code word is ",e.jsx(r,{children:"(0, 0, 1, 1, 0, 0, 1)"}),"."]})]}),e.jsx("h3",{children:"Generator Matrix for Hamming Codes"}),e.jsx("p",{children:"To find the generator matrix, we rearrange the parity check matrix into standard form."}),e.jsxs(n,{title:"Generator Matrix for (7, 4) Hamming Code",children:[e.jsxs("p",{children:["Rearranging columns of ",e.jsx(r,{children:"\\mathbf{H}"})," to standard form:"]}),e.jsx(s,{children:"\\mathbf{H}' = \\begin{pmatrix} 1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["This is ",e.jsx(r,{children:"\\mathbf{H}' = (\\mathbf{A}^t \\;|\\; \\mathbf{I}_3)"})," with:"]}),e.jsx(s,{children:"\\mathbf{A}^t = \\begin{pmatrix} 1 & 1 & 0 & 1 \\\\ 1 & 0 & 1 & 1 \\\\ 0 & 1 & 1 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"The generator matrix is:"}),e.jsx(s,{children:"\\mathbf{G} = (\\mathbf{I}_4 \\;|\\; \\mathbf{A}) = \\begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix}"})]}),e.jsx("h3",{children:"Hamming Codes as Polynomial Codes"}),e.jsx(i,{title:"Hamming Codes are Polynomial Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Consider the polynomial ",e.jsx(r,{children:"g(X) = 1 + X + X^3"})," over ",e.jsx(r,{children:"\\mathbb{B}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This polynomial has the property that it divides ",e.jsx(r,{children:"X^7 + 1"})," but does not divide ",e.jsx(r,{children:"X^k + 1"})," for ",e.jsx(r,{children:"k < 7"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The polynomial code generated by ",e.jsx(r,{children:"g(X)"})," has length 7 and dimension ",e.jsx(r,{children:"7 - 3 = 4"}),"."]}),e.jsx("p",{className:"mt-2",children:"It can be shown that this polynomial code is equivalent to the (7, 4) Hamming code (after appropriate reordering of positions)."})]}),children:e.jsxs("p",{children:["The (7, 4) Hamming code is equivalent to the polynomial code generated by ",e.jsx(r,{children:"g(X) = 1 + X + X^3"}),"."]})}),e.jsx("h3",{children:"Properties of Hamming Codes"}),e.jsx(i,{title:"Minimum Distance",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Upper bound:"})," Consider any two columns of ",e.jsx(r,{children:"\\mathbf{H}"}),", say columns ",e.jsx(r,{children:"i"})," and ",e.jsx(r,{children:"j"}),". If their sum equals another column ",e.jsx(r,{children:"k"}),", then the word with 1s in positions ",e.jsx(r,{children:"i, j, k"})," is a code word of weight 3."]}),e.jsxs("p",{className:"mt-2",children:["For example, columns 1, 2, 3 of the (7, 4) code satisfy: ",e.jsx(r,{children:"(001) + (010) = (011)"}),". So ",e.jsx(r,{children:"d \\leq 3"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Lower bound:"})," Since all columns are distinct and non-zero, no single column is zero (so weight-1 vectors are not code words), and no two columns are equal (so weight-2 vectors are not code words). Thus ",e.jsx(r,{children:"d \\geq 3"}),"."]})]}),children:e.jsxs("p",{children:["Every Hamming code ",e.jsx(r,{children:"\\mathcal{H}_r"})," has minimum distance exactly 3."]})}),e.jsx("h3",{children:"Table of Hamming Codes"}),e.jsx("div",{className:"overflow-x-auto my-6",children:e.jsxs("table",{className:"w-full border-collapse",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"bg-dark-800",children:[e.jsx("th",{className:"border border-dark-600 px-4 py-2 text-left",children:e.jsx(r,{children:"r"})}),e.jsxs("th",{className:"border border-dark-600 px-4 py-2 text-left",children:["Code Length ",e.jsx(r,{children:"n = 2^r - 1"})]}),e.jsxs("th",{className:"border border-dark-600 px-4 py-2 text-left",children:["Message Bits ",e.jsx(r,{children:"k"})]}),e.jsx("th",{className:"border border-dark-600 px-4 py-2 text-left",children:"Check Bits"}),e.jsxs("th",{className:"border border-dark-600 px-4 py-2 text-left",children:["Rate ",e.jsx(r,{children:"k/n"})]})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"2"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"3"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"1"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"2"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"0.333"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"3"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"7"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"4"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"3"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"0.571"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"4"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"15"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"11"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"4"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"0.733"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"5"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"31"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"26"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"5"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"0.839"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"6"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"63"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"57"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"6"}),e.jsx("td",{className:"border border-dark-600 px-4 py-2",children:"0.905"})]})]})]})}),e.jsxs(d,{type:"info",children:[e.jsx("strong",{children:"Efficiency:"})," As ",e.jsx(r,{children:"r"})," increases, the rate ",e.jsx(r,{children:"k/n"})," approaches 1. This means Hamming codes become increasingly efficient for longer code lengths, with the overhead of parity bits becoming negligible."]}),e.jsx("h3",{children:"Historical Significance"}),e.jsx("p",{children:"Richard Hamming developed these codes while working at Bell Labs in the late 1940s. Frustrated by errors in the mechanical relay computers of the time, he sought a way to automatically detect and correct errors. His elegant solution remains one of the foundations of coding theory."}),e.jsxs(d,{type:"success",children:[e.jsx("strong",{children:"Chapter Summary:"})," Hamming codes are single-error-correcting codes with parameters ",e.jsx(r,{children:"[2^r - 1, 2^r - 1 - r, 3]"}),". They are constructed by using all non-zero ",e.jsx(r,{children:"r"}),"-bit binary vectors as columns of the parity check matrix. This construction ensures that:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"All columns are distinct and non-zero (enabling single-error correction)"}),e.jsx("li",{children:"The syndrome directly indicates the error position (enabling efficient decoding)"}),e.jsx("li",{children:"The minimum distance is exactly 3"})]}),e.jsx("p",{className:"mt-2",children:"Hamming codes can also be viewed as polynomial codes, connecting the matrix and polynomial approaches to coding theory."})]})]})}export{b as default};
