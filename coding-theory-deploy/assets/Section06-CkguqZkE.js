import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as d,D as t,E as i,C as n,T as a}from"./Callout-DA0JknRv.js";import{M as s,I as r}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function u(){return e.jsxs(d,{sectionId:6,children:[e.jsx("h2",{children:"Chapter 3: Hamming Codes"}),e.jsx("h3",{children:"3.1 Binary Representation of Numbers"}),e.jsx("p",{children:"Before introducing Hamming codes, we need to understand the binary representation of integers. This representation is fundamental to understanding how Hamming codes are constructed and why they work."}),e.jsx("h3",{children:"Positional Number Systems"}),e.jsx("p",{children:"We are familiar with the decimal (base 10) representation of numbers, where each position represents a power of 10. For example:"}),e.jsx(s,{children:"347 = 3 \\times 10^2 + 4 \\times 10^1 + 7 \\times 10^0"}),e.jsx("p",{children:"The binary (base 2) system works similarly, but each position represents a power of 2, and only the digits 0 and 1 are used."}),e.jsxs(t,{title:"Binary Representation",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"binary representation"})," of a non-negative integer ",e.jsx(r,{children:"n"})," is the unique expression:"]}),e.jsx(s,{children:"n = a_k 2^k + a_{k-1} 2^{k-1} + \\cdots + a_1 2^1 + a_0 2^0"}),e.jsxs("p",{className:"mt-2",children:["where each ",e.jsx(r,{children:"a_i \\in \\{0, 1\\}"})," and ",e.jsx(r,{children:"a_k = 1"})," (for ",e.jsx(r,{children:"n > 0"}),")."]}),e.jsxs("p",{className:"mt-2",children:["We write this as ",e.jsx(r,{children:"n = (a_k a_{k-1} \\cdots a_1 a_0)_2"}),"."]})]}),e.jsx(i,{title:"Binary Representations",children:e.jsxs("div",{className:"grid grid-cols-2 gap-4",children:[e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{className:"text-primary-400 font-semibold mb-2",children:"Decimal to Binary"}),e.jsx("p",{children:e.jsx(r,{children:"1 = 1 \\cdot 2^0 = (1)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"2 = 1 \\cdot 2^1 + 0 \\cdot 2^0 = (10)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"3 = 1 \\cdot 2^1 + 1 \\cdot 2^0 = (11)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"4 = 1 \\cdot 2^2 = (100)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"5 = 1 \\cdot 2^2 + 1 \\cdot 2^0 = (101)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"6 = 1 \\cdot 2^2 + 1 \\cdot 2^1 = (110)_2"})}),e.jsx("p",{children:e.jsx(r,{children:"7 = 1 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 = (111)_2"})})]}),e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{className:"text-primary-400 font-semibold mb-2",children:"Binary to Decimal"}),e.jsx("p",{children:e.jsx(r,{children:"(1001)_2 = 8 + 1 = 9"})}),e.jsx("p",{children:e.jsx(r,{children:"(1010)_2 = 8 + 2 = 10"})}),e.jsx("p",{children:e.jsx(r,{children:"(1011)_2 = 8 + 2 + 1 = 11"})}),e.jsx("p",{children:e.jsx(r,{children:"(1100)_2 = 8 + 4 = 12"})}),e.jsx("p",{children:e.jsx(r,{children:"(1101)_2 = 8 + 4 + 1 = 13"})}),e.jsx("p",{children:e.jsx(r,{children:"(1110)_2 = 8 + 4 + 2 = 14"})}),e.jsx("p",{children:e.jsx(r,{children:"(1111)_2 = 8 + 4 + 2 + 1 = 15"})})]})]})}),e.jsx("h3",{children:"Conversion Algorithm"}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Converting Decimal to Binary:"}),e.jsx("p",{className:"mt-2",children:"Repeatedly divide by 2 and record the remainders. The binary representation is the sequence of remainders read from bottom to top."}),e.jsxs("div",{className:"mt-4 bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{className:"font-semibold",children:"Example: Convert 13 to binary"}),e.jsxs("div",{className:"mt-2 font-mono",children:[e.jsxs("p",{children:["13 ÷ 2 = 6 remainder ",e.jsx("span",{className:"text-emerald-400",children:"1"})]}),e.jsxs("p",{children:[" 6 ÷ 2 = 3 remainder ",e.jsx("span",{className:"text-emerald-400",children:"0"})]}),e.jsxs("p",{children:[" 3 ÷ 2 = 1 remainder ",e.jsx("span",{className:"text-emerald-400",children:"1"})]}),e.jsxs("p",{children:[" 1 ÷ 2 = 0 remainder ",e.jsx("span",{className:"text-emerald-400",children:"1"})]})]}),e.jsxs("p",{className:"mt-2",children:["Reading bottom to top: ",e.jsx(r,{children:"13 = (1101)_2"})]})]})]}),e.jsx("h3",{children:"Properties of Binary Representations"}),e.jsx(a,{title:"Number of Bits Required",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["If ",e.jsx(r,{children:"n = (a_k a_{k-1} \\cdots a_0)_2"})," with ",e.jsx(r,{children:"a_k = 1"}),", then:"]}),e.jsx(s,{children:"2^k \\leq n < 2^{k+1}"}),e.jsxs("p",{className:"mt-2",children:["Taking logarithms: ",e.jsx(r,{children:"k \\leq \\log_2 n < k + 1"})]}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(r,{children:"k = \\lfloor \\log_2 n \\rfloor"}),", and the number of bits is ",e.jsx(r,{children:"k + 1 = \\lfloor \\log_2 n \\rfloor + 1"}),"."]})]}),children:e.jsxs("p",{children:["A positive integer ",e.jsx(r,{children:"n"})," requires ",e.jsx(r,{children:"\\lfloor \\log_2 n \\rfloor + 1"})," bits in its binary representation."]})}),e.jsx(i,{title:"Bits Required",children:e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx("p",{children:"Numbers from 1 to 15 require at most 4 bits:"}),e.jsx(s,{children:"2^3 = 8 \\leq n \\leq 15 < 2^4 = 16"}),e.jsx("p",{className:"mt-2",children:"Numbers from 1 to 7 require at most 3 bits:"}),e.jsx(s,{children:"2^2 = 4 \\leq n \\leq 7 < 2^3 = 8"})]})}),e.jsx("h3",{children:"Binary Representation as Column Vectors"}),e.jsx("p",{children:"For Hamming codes, we will represent integers as column vectors of their binary digits. This allows us to use them as columns of a matrix."}),e.jsxs(t,{title:"Binary Column Vector",children:[e.jsxs("p",{children:["For an integer ",e.jsx(r,{children:"n \\geq 1"})," with ",e.jsx(r,{children:"r"}),"-bit binary representation, we write:"]}),e.jsx(s,{children:"n \\leftrightarrow \\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_r \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(r,{children:"n = a_1 \\cdot 2^{r-1} + a_2 \\cdot 2^{r-2} + \\cdots + a_r \\cdot 2^0"}),"."]})]}),e.jsxs(i,{title:"Binary Column Vectors (3 bits)",children:[e.jsx("p",{children:"The integers 1 through 7 as 3-bit column vectors:"}),e.jsxs("div",{className:"grid grid-cols-7 gap-2 mt-4 text-center",children:[e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"1"}),e.jsx(s,{children:"\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"2"}),e.jsx(s,{children:"\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"3"}),e.jsx(s,{children:"\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"4"}),e.jsx(s,{children:"\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"5"}),e.jsx(s,{children:"\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"6"}),e.jsx(s,{children:"\\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-2 rounded-lg",children:[e.jsx("p",{className:"text-primary-400",children:"7"}),e.jsx(s,{children:"\\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}"})]})]})]}),e.jsx("h3",{children:"Key Observations for Hamming Codes"}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Important Properties:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:["With ",e.jsx(r,{children:"r"})," bits, we can represent ",e.jsx(r,{children:"2^r - 1"})," distinct non-zero values (from 1 to ",e.jsx(r,{children:"2^r - 1"}),")."]}),e.jsxs("li",{children:["All ",e.jsx(r,{children:"2^r - 1"})," binary ",e.jsx(r,{children:"r"}),"-tuples (except ",e.jsx(r,{children:"00\\cdots0"}),") correspond to unique integers."]}),e.jsx("li",{children:"These column vectors are all distinct and non-zero—exactly what we need for a parity check matrix that corrects single errors!"})]})]}),e.jsx("h3",{children:"Binary Addition (XOR)"}),e.jsxs("p",{children:["When working over the binary field ",e.jsx(r,{children:"\\mathbb{B}"}),", addition is performed modulo 2, which is equivalent to the XOR operation."]}),e.jsxs(i,{title:"Binary Addition",children:[e.jsxs("p",{children:["Adding binary column vectors (in ",e.jsx(r,{children:"\\mathbb{B}"}),"):"]}),e.jsxs("div",{className:"grid grid-cols-2 gap-4 mt-4",children:[e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx(s,{children:"\\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}"}),e.jsx("p",{className:"text-center text-sm mt-2",children:"(5 + 6 ≡ 3 mod binary)"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-4 rounded-lg",children:[e.jsx(s,{children:"\\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} + \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}"}),e.jsx("p",{className:"text-center text-sm mt-2",children:"(3 + 4 ≡ 7 mod binary)"})]})]}),e.jsx("p",{className:"mt-4 text-amber-400",children:"Note: Binary addition of column vectors corresponds to XOR of each component, not ordinary integer addition."})]}),e.jsx("h3",{children:"Connection to Hamming Codes"}),e.jsxs("p",{children:["The key insight for Hamming codes is this: if we use all non-zero ",e.jsx(r,{children:"r"}),"-bit binary representations as columns of a parity check matrix ",e.jsx(r,{children:"\\mathbf{H}"}),", then:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 my-4",children:[e.jsx("li",{children:"All columns are non-zero"}),e.jsx("li",{children:"All columns are distinct"}),e.jsxs("li",{children:["Therefore, by our earlier theorem, this ",e.jsx(r,{children:"\\mathbf{H}"})," can correct all single errors"]}),e.jsxs("li",{children:["Furthermore, when an error occurs in position ",e.jsx(r,{children:"i"}),", the syndrome equals the binary representation of ",e.jsx(r,{children:"i"}),"—directly telling us where the error is!"]})]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"Section Summary:"})," The binary representation of integers provides the foundation for Hamming codes. With ",e.jsx(r,{children:"r"})," bits, we can represent ",e.jsx(r,{children:"2^r - 1"})," distinct non-zero integers. Using these as columns of a parity check matrix creates a code where the syndrome of a single-error pattern directly indicates the error position. This elegant construction is developed fully in the next section."]})]})}export{u as default};
