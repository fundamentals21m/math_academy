import{j as e}from"./vendor-animation-BtDNYRNB.js";import{L as r,C as s,E as a,T as t}from"./Callout-9bhk3xzT.js";import{I as i,M as n}from"./MathBlock-BPgtCiNw.js";import"./vendor-react-DamxDR2H.js";import"./index-Bqqh6CFH.js";import"./vendor-math-p018AHG0.js";import"./quizMap-MGF5DqnC.js";function j(){return e.jsxs(r,{sectionId:17,children:[e.jsx("p",{children:"In this section, we establish an important connection: both BCH codes and Hamming codes can be viewed as cyclic codes. This perspective provides additional structure and leads to efficient encoding and decoding algorithms."}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Roots and Cyclic Codes"}),e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathscr{C}"})," be a cyclic code of length ",e.jsx(i,{children:"n"})," over ",e.jsx(i,{children:"F"}),", i.e., an ideal in ",e.jsx(i,{children:"F[X]/I"})," where ",e.jsx(i,{children:"I = \\langle X^n - 1 \\rangle"}),". Let ",e.jsx(i,{children:"g(X)"})," be the generator polynomial of degree ",e.jsx(i,{children:"r"}),", and let ",e.jsx(i,{children:"\\alpha_1, \\alpha_2, \\ldots, \\alpha_r"})," be the roots of ",e.jsx(i,{children:"g(X)"})," in a suitable extension field of ",e.jsx(i,{children:"F"}),". Then:"]}),e.jsx(n,{children:"g(X) = (X - \\alpha_1)(X - \\alpha_2)\\cdots(X - \\alpha_r)"}),e.jsx(s,{type:"info",title:"Root Characterization",children:e.jsxs("p",{children:["Observe that ",e.jsx(i,{children:"g(X)"})," divides a polynomial ",e.jsx(i,{children:"a(X)"})," if and only if ",e.jsx(i,{children:"\\alpha_1, \\ldots, \\alpha_r"})," are among the roots of ",e.jsx(i,{children:"a(X)"}),". Therefore, ",e.jsx(i,{children:"a(X) + I"})," is in ",e.jsx(i,{children:"mathscr{C}"})," if and only if ",e.jsx(i,{children:"\\alpha_1, \\ldots, \\alpha_r"})," are among the roots of ",e.jsx(i,{children:"a(X)"}),"."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Binary Hamming Codes"}),e.jsxs("p",{children:["Given a positive integer ",e.jsx(i,{children:"m"}),", recall that a binary ",e.jsx(i,{children:"(2^m - m - 1, 2^m - 1)"})," Hamming code is defined by taking the ",e.jsx(i,{children:"m \\times (2^m - 1)"})," parity check matrix ",e.jsx(i,{children:"mathbf{H}"}),", where the ",e.jsx(i,{children:"i"}),"-th column is the binary representation of the number ",e.jsx(i,{children:"i"}),"."]}),e.jsxs(a,{title:"Binary Hamming Code of Length 7",children:[e.jsxs("p",{children:["For ",e.jsx(i,{children:"m = 3"}),", we have ",e.jsx(i,{children:"n = 2^3 - 1 = 7"}),". A parity check matrix is:"]}),e.jsx(n,{children:"\\mathbf{H} = \\begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"Applying a suitable column permutation, we can obtain a generator matrix and enumerate all 16 code words."})]}),e.jsx(t,{title:"Hamming Codes as Cyclic Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(i,{children:"\\alpha"})," be a primitive element of ",e.jsx(i,{children:"	ext{GF}(2^m)"}),". Let ",e.jsx(i,{children:"m(X)"})," be the minimal polynomial of ",e.jsx(i,{children:"\\alpha"})," over ",e.jsx(i,{children:"mathbb{B}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since for ",e.jsx(i,{children:"\beta in 	ext{GF}(2^m)"}),", ",e.jsx(i,{children:"\\beta"})," and ",e.jsx(i,{children:"\\beta^2"})," have the same minimal polynomial, the elements ",e.jsx(i,{children:"\\alpha, \\alpha^2, \\ldots, \\alpha^{2^{m-1}}"})," are distinct roots of ",e.jsx(i,{children:"m(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(i,{children:"[	ext{GF}(2^m) : mathbb{B}] = m"}),", the degree of the minimal polynomial of any element of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," over ",e.jsx(i,{children:"mathbb{B}"})," is at most ",e.jsx(i,{children:"m"}),". Hence:"]}),e.jsx(n,{children:"m(X) = (X - \\alpha)(X - \\alpha^2)\\cdots(X - \\alpha^{2^{m-1}})"}),e.jsxs("p",{className:"mt-2",children:["The elements ",e.jsx(i,{children:"1, \\alpha, \\alpha^2, \\ldots, \\alpha^{m-1}"})," form a basis of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," over ",e.jsx(i,{children:"mathbb{B}"}),". Therefore, every element of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," can be uniquely written as:"]}),e.jsx(n,{children:"\\sum_{i=0}^{m-1} e_i \\alpha^i \\quad \\text{where } e_i \\in \\mathbb{B}"}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(i,{children:"0 \\leq j \\leq 2^m - 2"}),", let ",e.jsx(i,{children:"\\alpha^j = \\sum_{i=0}^{m-1} e_{ij}\\alpha^i"}),", and let ",e.jsx(i,{children:"mathbf{H}"})," be the ",e.jsx(i,{children:"m \\times n"})," matrix whose ",e.jsx(i,{children:"(j+1)"}),"-th column is ",e.jsx(i,{children:"(e_{0j}, e_{1j}, \\ldots, e_{m-1,j})^t"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Every row vector ",e.jsx(i,{children:"(e_{0j}, e_{1j}, \\ldots, e_{m-1,j})"})," gives the binary representation of a unique positive integer at most ",e.jsx(i,{children:"n"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Now ",e.jsx(i,{children:"a(X) + \\langle X^n - 1 \\rangle"})," belongs to the cyclic code generated by ",e.jsx(i,{children:"m(X)"})," if and only if ",e.jsx(i,{children:"a(\\alpha) = 0"}),". But this is so if and only if ",e.jsx(i,{children:"mathbf{H}mathbf{a}^t = 0"}),", where ",e.jsx(i,{children:"\\mathbf{a} = (a_0, a_1, \\ldots, a_{n-1})"})," with ",e.jsx(i,{children:"a(X) = a_0 + a_1X + \\cdots + a_{n-1}X^{n-1}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Therefore, the cyclic code generated by ",e.jsx(i,{children:"m(X)"})," is the same as the code given by the parity check matrix ",e.jsx(i,{children:"mathbf{H}"}),". But ",e.jsx(i,{children:"mathbf{H}"})," is obtained by permuting the binary representations of ",e.jsx(i,{children:"1, 2, \\ldots, n"}),". This completes the proof."]})]}),children:e.jsxs("p",{children:["The binary cyclic code of length ",e.jsx(i,{children:"n = 2^m - 1"})," for which the generator is the minimal polynomial of a primitive element of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," is equivalent to the ",e.jsx(i,{children:"(n - m, n)"})," Hamming code."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"BCH Codes as Cyclic Codes"}),e.jsxs("p",{children:["We have seen that every non-zero element of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," is a root of the polynomial ",e.jsx(i,{children:"X^n - 1"})," with ",e.jsx(i,{children:"n = 2^m - 1"}),". Therefore, the minimal polynomial of every element ",e.jsx(i,{children:"\\beta"})," of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," divides ",e.jsx(i,{children:"X^n - 1"}),"."]}),e.jsxs("p",{className:"mt-4",children:["Also, the minimal polynomials of two elements are either identical or relatively coprime. Hence, if ",e.jsx(i,{children:"\\alpha"})," is a primitive element of ",e.jsx(i,{children:"	ext{GF}(2^m)"})," and ",e.jsx(i,{children:"d \\geq 2"})," is a positive integer, then:"]}),e.jsx(n,{children:"g(X) = \\text{LCM}\\{m_1(X), \\ldots, m_{d-1}(X)\\}"}),e.jsxs("p",{children:["where ",e.jsx(i,{children:"m_i(X)"})," denotes the minimal polynomial of ",e.jsx(i,{children:"\\alpha^i"}),", divides ",e.jsx(i,{children:"X^n - 1"}),"."]}),e.jsx(s,{type:"success",title:"BCH Codes are Cyclic",children:e.jsxs("p",{children:["It follows that the polynomial code of length ",e.jsx(i,{children:"n"})," generated by ",e.jsx(i,{children:"g(X)"})," is the same as the cyclic code with generator ",e.jsx(i,{children:"g(X)"}),". Thus, ",e.jsx("strong",{children:"every binary BCH code is a cyclic code"}),"."]})}),e.jsxs(a,{title:"Hamming Code as BCH Code",children:[e.jsxs("p",{children:["The above proof also shows that a binary Hamming code is a BCH code (up to equivalence). Specifically, the binary Hamming code of length ",e.jsx(i,{children:"2^m - 1"})," is the BCH code with designed distance ",e.jsx(i,{children:"d = 3"})," generated by ",e.jsx(i,{children:"m_1(X)"}),", the minimal polynomial of a primitive element ",e.jsx(i,{children:"\\alpha"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(i,{children:"m_1(X)"})," has ",e.jsx(i,{children:"\\alpha"})," as a root, any code word ",e.jsx(i,{children:"c(X)"})," satisfies ",e.jsx(i,{children:"c(\\alpha) = 0"}),", meaning the code has minimum distance at least 3."]})]}),e.jsxs(a,{title:"Generator Matrix of Binary Hamming Code of Length 15",children:[e.jsxs("p",{children:["For ",e.jsx(i,{children:"m = 4"}),", the parity check matrix is:"]}),e.jsx(n,{children:"\\mathbf{H} = \\begin{pmatrix} 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\\\ 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\\\ 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["After applying a suitable permutation ",e.jsx(i,{children:"\\sigma"})," to obtain canonical form and computing the corresponding generator matrix, we get an ",e.jsx(i,{children:"11 \\times 15"})," generator matrix for this Hamming code."]}),e.jsxs("p",{className:"mt-2",children:["The code has dimension ",e.jsx(i,{children:"15 - 4 = 11"}),", minimum distance 3, and is equivalent to the cyclic code generated by the minimal polynomial of a primitive element in ",e.jsx(i,{children:"	ext{GF}(16)"}),"."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4 text-gradient",children:"Minimum Distance Revisited"}),e.jsxs("p",{children:["Let ",e.jsx(i,{children:"mathscr{C}"})," be a Hamming code of length ",e.jsx(i,{children:"n = 2^r - 1"}),". Then ",e.jsx(i,{children:"mathscr{C}"})," is a code with a parity check matrix ",e.jsx(i,{children:"mathbf{H}"})," of order ",e.jsx(i,{children:"r \\times n"})," in which the columns are the binary representations of the numbers ",e.jsx(i,{children:"1, 2, \\ldots, n"}),"."]}),e.jsx(t,{title:"Minimum Distance of Hamming Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["No two columns of ",e.jsx(i,{children:"mathbf{H}"})," are identical since each column represents a distinct non-zero integer from 1 to ",e.jsx(i,{children:"n"}),"."]}),e.jsx("p",{className:"mt-2",children:"By the general theory of linear codes, the code is single error correcting if and only if no two columns of the parity check matrix are identical. Since this condition is satisfied, the Hamming code is single error correcting."}),e.jsx("p",{className:"mt-2",children:"A code is single error correcting if and only if its minimum distance is at least 3. Therefore, the minimum distance of the Hamming code is at least 3."}),e.jsxs("p",{className:"mt-2",children:["Moreover, we can find three columns that sum to zero (over ",e.jsx(i,{children:"mathbb{B}"}),"), showing the minimum distance is exactly 3."]})]}),children:e.jsxs("p",{children:["The binary Hamming code of length ",e.jsx(i,{children:"n = 2^m - 1"})," has minimum distance exactly 3 and is single error correcting."]})}),e.jsx(s,{type:"note",title:"Alternative Proof via Cyclic Structure",children:e.jsxs("p",{children:["The cyclic code perspective provides an alternative proof of the minimum distance result. Since the generator polynomial ",e.jsx(i,{children:"m_1(X)"})," has ",e.jsx(i,{children:"\\alpha"})," and ",e.jsx(i,{children:"\\alpha^2"})," as roots (because ",e.jsx(i,{children:"\\alpha"})," and ",e.jsx(i,{children:"\\alpha^2"})," have the same minimal polynomial over ",e.jsx(i,{children:"mathbb{B}"}),"), any code word ",e.jsx(i,{children:"c(X)"})," satisfies ",e.jsx(i,{children:"c(\\alpha) = c(\\alpha^2) = 0"}),". This implies the code has designed distance at least 3 by BCH bound theory."]})})]})}export{j as default};
