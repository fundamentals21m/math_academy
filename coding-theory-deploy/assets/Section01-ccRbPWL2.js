import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as t,D as r,T as n,C as c,E as d}from"./Callout-DA0JknRv.js";import{I as s,M as i}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function g(){return e.jsxs(t,{sectionId:1,children:[e.jsx("h2",{children:"1.2 Matrix Encoding Techniques"}),e.jsxs("p",{children:["One systematic algebraic technique for encoding binary words is through ",e.jsx("strong",{children:"matrix multiplication"}),". This approach provides a structured way to add redundancy to messages, enabling error detection and correction."]}),e.jsx("h3",{children:"Review of Matrix Operations"}),e.jsxs("p",{children:["Recall that if ",e.jsx(s,{children:"\\mathbf{A} = (a_{ij})"})," is an ",e.jsx(s,{children:"m \\times n"})," matrix and ",e.jsx(s,{children:"\\mathbf{B} = (b_{rs})"})," is an ",e.jsx(s,{children:"n \\times k"})," matrix, then the product ",e.jsx(s,{children:"\\mathbf{AB}"})," is an ",e.jsx(s,{children:"m \\times k"})," matrix ",e.jsx(s,{children:"(c_{ij})"})," where:"]}),e.jsx(i,{children:"c_{ij} = \\sum_{r=1}^{n} a_{ir}b_{rj} \\quad \\text{for } 1 \\leq i \\leq m, \\, 1 \\leq j \\leq k"}),e.jsxs(r,{title:"Homomorphism",children:[e.jsxs("p",{children:["If ",e.jsx(s,{children:"A"})," and ",e.jsx(s,{children:"B"})," are two groups, a map ",e.jsx(s,{children:"f: A \\to B"})," satisfying:"]}),e.jsx(i,{children:"f(xy) = f(x)f(y) \\quad \\forall x, y \\in A"}),e.jsxs("p",{className:"mt-2",children:["is called a ",e.jsx("strong",{children:"homomorphism"}),"."]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["A homomorphism that is one-to-one is called a ",e.jsx("strong",{children:"monomorphism"})]}),e.jsxs("li",{children:["A homomorphism that is both one-to-one and onto is called an ",e.jsx("strong",{children:"isomorphism"})]})]})]}),e.jsx("h3",{children:"Generator Matrices"}),e.jsxs(r,{title:"Encoding (Generator) Matrix",children:[e.jsxs("p",{children:["An ",e.jsx(s,{children:"m \\times n"})," matrix over ",e.jsx(s,{children:"\\mathbb{B}"})," with ",e.jsx(s,{children:"m < n"})," is called an ",e.jsx("strong",{children:"encoding matrix"})," (or ",e.jsx("strong",{children:"generator matrix"}),") if its first ",e.jsx(s,{children:"m"})," columns form the identity matrix ",e.jsx(s,{children:"\\mathbf{I}_m"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Given a generator matrix ",e.jsx(s,{children:"\\mathbf{G}"}),", we define an encoding function ",e.jsx(s,{children:"E: \\mathbb{B}^m \\to \\mathbb{B}^n"})," by:"]}),e.jsx(i,{children:"E(\\mathbf{x}) = \\mathbf{x}\\mathbf{G} \\quad \\text{for } \\mathbf{x} \\in \\mathbb{B}^m"})]}),e.jsx(n,{title:"Matrix Encoding is a Monomorphism",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Since the first ",e.jsx(s,{children:"m"})," columns of ",e.jsx(s,{children:"\\mathbf{G}"})," form the identity matrix, for any ",e.jsx(s,{children:"\\mathbf{x} = (x_1, \\ldots, x_m)"}),", the code word ",e.jsx(s,{children:"\\mathbf{xG}"})," has ",e.jsx(s,{children:"(x_1, \\ldots, x_m)"})," as its first ",e.jsx(s,{children:"m"})," components."]}),e.jsxs("p",{className:"mt-2",children:["Thus, different message words produce different code words, so ",e.jsx(s,{children:"E"})," is one-to-one."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{children:"\\mathbf{x}, \\mathbf{y} \\in \\mathbb{B}^m"}),":"]}),e.jsx(i,{children:"E(\\mathbf{x} + \\mathbf{y}) = (\\mathbf{x} + \\mathbf{y})\\mathbf{G} = \\mathbf{x}\\mathbf{G} + \\mathbf{y}\\mathbf{G} = E(\\mathbf{x}) + E(\\mathbf{y})"}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(s,{children:"E"})," is a homomorphism, and being one-to-one, it is a monomorphism."]})]}),children:e.jsxs("p",{children:["For any ",e.jsx(s,{children:"m \\times n"})," generator matrix ",e.jsx(s,{children:"\\mathbf{G}"}),", the encoding function ",e.jsx(s,{children:"E: \\mathbb{B}^m \\to \\mathbb{B}^n"})," given by ",e.jsx(s,{children:"E(\\mathbf{x}) = \\mathbf{x}\\mathbf{G}"})," is a monomorphism."]})}),e.jsx(r,{title:"Matrix Code",children:e.jsxs("p",{children:["A code given by a generator matrix is called a ",e.jsx("strong",{children:"matrix code"}),"."]})}),e.jsx(r,{title:"Group Code",children:e.jsxs("p",{children:["When the code words in a block code form an additive group, the code is called a ",e.jsx("strong",{children:"group code"}),"."]})}),e.jsxs(c,{type:"info",children:[e.jsx("strong",{children:"Key Insight:"})," A matrix code is always a group code, since the code words form the image of a homomorphism, which is always a subgroup."]}),e.jsxs(d,{title:"A (3, 6) Matrix Code",children:[e.jsxs("p",{children:["Consider the ",e.jsx(s,{children:"3 \\times 6"})," generator matrix:"]}),e.jsx(i,{children:"\\mathbf{G} = \\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"All the code words of this code are:"}),e.jsxs("div",{className:"grid grid-cols-2 gap-4 mt-2",children:[e.jsxs("div",{className:"bg-dark-800/50 p-3 rounded-lg font-mono text-sm",children:[e.jsx("p",{children:"000 → 000000"}),e.jsx("p",{children:"001 → 001111"}),e.jsx("p",{children:"010 → 010011"}),e.jsx("p",{children:"100 → 100110"})]}),e.jsxs("div",{className:"bg-dark-800/50 p-3 rounded-lg font-mono text-sm",children:[e.jsx("p",{children:"011 → 011100"}),e.jsx("p",{children:"101 → 101001"}),e.jsx("p",{children:"110 → 110101"}),e.jsx("p",{children:"111 → 111010"})]})]}),e.jsx("p",{className:"mt-4",children:"This code has 4 code words of weight 3, 3 code words of weight 4, and only the zero code word of weight 0."}),e.jsx("p",{className:"mt-2 text-emerald-400",children:"The minimum distance is 3, so this code can correct any single error and detect any error of weight 2."})]}),e.jsx("h3",{children:"Parity Check Codes"}),e.jsxs(r,{title:"(m, m+1) Parity Check Code",children:[e.jsxs("p",{children:["An ",e.jsxs("strong",{children:[e.jsx(s,{children:"(m, m+1)"})," parity check code"]})," is defined by the encoding function ",e.jsx(s,{children:"E: \\mathbb{B}^m \\to \\mathbb{B}^{m+1}"}),":"]}),e.jsx(i,{children:"E(a_1a_2\\cdots a_m) = a_1a_2\\cdots a_m a_{m+1}"}),e.jsx("p",{className:"mt-2",children:"where:"}),e.jsx(i,{children:"a_{m+1} = \\begin{cases} 1 & \\text{if } \\text{wt}(a_1a_2\\cdots a_m) \\text{ is odd} \\\\ 0 & \\text{if } \\text{wt}(a_1a_2\\cdots a_m) \\text{ is even} \\end{cases}"}),e.jsxs("p",{className:"mt-2",children:["The extra bit ",e.jsx(s,{children:"a_{m+1}"})," ensures that every code word has even weight."]})]}),e.jsx(n,{title:"Parity Check Code is a Group Code",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"a = a_1\\cdots a_m"})," and ",e.jsx(s,{children:"a' = a'_1\\cdots a'_m"})," be message words with corresponding code words ",e.jsx(s,{children:"b = b_1\\cdots b_{m+1}"})," and ",e.jsx(s,{children:"b' = b'_1\\cdots b'_{m+1}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{children:"c = b + b' = c_1\\cdots c_{m+1}"})," where ",e.jsx(s,{children:"c_i = b_i + b'_i"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Now ",e.jsx(s,{children:"c_1 + \\cdots + c_m = (b_1 + \\cdots + b_m) + (b'_1 + \\cdots + b'_m)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This sum is odd if and only if exactly one of ",e.jsx(s,{children:"b_1 + \\cdots + b_m"})," and ",e.jsx(s,{children:"b'_1 + \\cdots + b'_m"})," is odd. In this case, exactly one of ",e.jsx(s,{children:"b_{m+1}"})," and ",e.jsx(s,{children:"b'_{m+1}"})," equals 1, so ",e.jsx(s,{children:"c_{m+1} = 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If both sums are even (or both odd), then ",e.jsx(s,{children:"c_1 + \\cdots + c_m"})," is even and ",e.jsx(s,{children:"c_{m+1} = b_{m+1} + b'_{m+1} = 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(s,{children:"c"})," satisfies the parity check condition and is a code word. The zero word is the identity, and every word is its own inverse."]})]}),children:e.jsxs("p",{children:["The ",e.jsx(s,{children:"(m, m+1)"})," parity check code is a group code."]})}),e.jsx("h3",{children:"Minimum Distance in Group Codes"}),e.jsx(n,{title:"Minimum Distance Equals Minimum Weight",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"d"})," be the minimum distance of the group code. Then there exist code words ",e.jsx(s,{children:"b, b'"})," such that ",e.jsx(s,{children:"d = d(b, b') = \\text{wt}(b + b')"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since the code is a group code, ",e.jsx(s,{children:"b + b'"})," is a code word. Let ",e.jsx(s,{children:"t"})," be the minimum weight among non-zero code words. Then ",e.jsx(s,{children:"d \\geq t"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Conversely, there exists a non-zero code word ",e.jsx(s,{children:"b''"})," with ",e.jsx(s,{children:"\\text{wt}(b'') = t"}),". Then ",e.jsx(s,{children:"t = \\text{wt}(b'') = d(b'', 0) \\geq d"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Hence ",e.jsx(s,{children:"d = t"}),"."]})]}),children:e.jsx("p",{children:"For a group code, the minimum distance equals the minimum of the weights of the non-zero code words."})}),e.jsxs(c,{type:"warning",children:[e.jsx("strong",{children:"Important:"})," In group codes, the error patterns that pass undetected are precisely those which correspond to non-zero code words. If ",e.jsx(s,{children:"e = b^*"})," is a code word, then for any code word ",e.jsx(s,{children:"b"}),", ",e.jsx(s,{children:"b + e"})," is again a code word, so the error goes undetected."]}),e.jsx("h3",{children:"Decoding by Coset Leaders"}),e.jsx("p",{children:"For group codes, we can use a systematic decoding procedure based on the decomposition of a group into cosets."}),e.jsxs(r,{title:"Subgroup and Coset",children:[e.jsxs("p",{children:["A non-empty subset ",e.jsx(s,{children:"N"})," of a group ",e.jsx(s,{children:"M"})," is called a ",e.jsx("strong",{children:"subgroup"})," if the composition in ",e.jsx(s,{children:"M"})," induces a composition in ",e.jsx(s,{children:"N"})," and ",e.jsx(s,{children:"N"})," is itself a group."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{children:"a \\in \\mathbb{B}^n"})," and a subgroup ",e.jsx(s,{children:"C"}),", the set ",e.jsx(s,{children:"a + C = \\{a + c : c \\in C\\}"})," is called a ",e.jsx("strong",{children:"coset"})," of ",e.jsx(s,{children:"C"}),"."]})]}),e.jsx(n,{title:"Coset Properties",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["If ",e.jsx(s,{children:"b \\in a + C"}),", then ",e.jsx(s,{children:"b = a + c"})," for some ",e.jsx(s,{children:"c \\in C"}),". For any ",e.jsx(s,{children:"c' \\in C"}),":"]}),e.jsx(i,{children:"b + c' = a + (c + c') \\in a + C"}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(s,{children:"b + C \\subseteq a + C"}),". Similarly, ",e.jsx(s,{children:"a = b + c"})," implies ",e.jsx(s,{children:"a + C \\subseteq b + C"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Hence ",e.jsx(s,{children:"a + C = b + C"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"(a + C) \\cap (b + C) \\neq \\emptyset"}),", there exists ",e.jsx(s,{children:"x \\in a + C"})," and ",e.jsx(s,{children:"x \\in b + C"}),", so ",e.jsx(s,{children:"a + C = x + C = b + C"}),"."]})]}),children:e.jsxs("p",{children:["Two cosets of ",e.jsx(s,{children:"C"})," in ",e.jsx(s,{children:"\\mathbb{B}^n"})," are either disjoint or identical. Furthermore, ",e.jsx(s,{children:"b \\in a + C"})," if and only if ",e.jsx(s,{children:"a + C = b + C"}),"."]})}),e.jsxs(r,{title:"Coset Leader",children:[e.jsxs("p",{children:["In each coset of ",e.jsx(s,{children:"C"})," in ",e.jsx(s,{children:"\\mathbb{B}^n"}),", we choose a word ",e.jsx(s,{children:"b^i"})," of least weight. This word is called a ",e.jsx("strong",{children:"coset leader"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Any element ",e.jsx(s,{children:"c"})," of ",e.jsx(s,{children:"\\mathbb{B}^n"})," can be uniquely written as ",e.jsx(s,{children:"c = b^i + c^j"})," for some coset leader ",e.jsx(s,{children:"b^i"})," and code word ",e.jsx(s,{children:"c^j \\in C"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The ",e.jsx("strong",{children:"decoding by coset leaders"})," procedure defines ",e.jsx(s,{children:"D(c) = c^j"}),"."]})]}),e.jsx(n,{title:"Coset Leader Decoding",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(⇒)"})," Suppose error pattern ",e.jsx(s,{children:"e"})," is corrected. Let ",e.jsx(s,{children:"c^i"})," be transmitted, so received word is ",e.jsx(s,{children:"b = c^i + e"}),". Write ",e.jsx(s,{children:"b = b^k + c'"})," for coset leader ",e.jsx(s,{children:"b^k"})," and code word ",e.jsx(s,{children:"c'"}),"."]}),e.jsxs("p",{className:"mt-2",children:["By the decoding process, ",e.jsx(s,{children:"D(b) = c'"}),". Since error is corrected, ",e.jsx(s,{children:"D(b) = c^i"}),", so ",e.jsx(s,{children:"c' = c^i"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Thus ",e.jsx(s,{children:"b^k + c^i = c^i + e"}),", giving ",e.jsx(s,{children:"e = b^k"}),"—a coset leader."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(⇐)"})," If ",e.jsx(s,{children:"e = b^k"})," is a coset leader, then for any code word ",e.jsx(s,{children:"c^i"}),", the received word is ",e.jsx(s,{children:"c^i + e = b^k + c^i"}),", and ",e.jsx(s,{children:"D(b^k + c^i) = c^i"}),"."]})]}),children:e.jsx("p",{children:"In group codes, decoding by coset leaders corrects precisely those error patterns which are coset leaders."})}),e.jsxs(d,{title:"Coset Decomposition for (3, 4) Parity Check Code",children:[e.jsx("p",{children:"The code words are:"}),e.jsx(i,{children:"\\{0000, 0011, 0101, 0110, 1001, 1010, 1100, 1111\\}"}),e.jsxs("p",{className:"mt-2",children:["Coset decomposition in ",e.jsx(s,{children:"\\mathbb{B}^4"}),":"]}),e.jsx("div",{className:"bg-dark-800/50 p-4 rounded-lg mt-2 overflow-x-auto",children:e.jsxs("table",{className:"font-mono text-sm",children:[e.jsx("thead",{children:e.jsxs("tr",{children:[e.jsx("th",{className:"px-2 text-left text-primary-400",children:"Leader"}),e.jsx("th",{className:"px-2 text-left",colSpan:8,children:"Coset Elements"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{children:[e.jsx("td",{className:"px-2",children:"0000"}),e.jsx("td",{className:"px-2",children:"0000"}),e.jsx("td",{className:"px-2",children:"0011"}),e.jsx("td",{className:"px-2",children:"0101"}),e.jsx("td",{className:"px-2",children:"1001"}),e.jsx("td",{className:"px-2",children:"0110"}),e.jsx("td",{className:"px-2",children:"1010"}),e.jsx("td",{className:"px-2",children:"1100"}),e.jsx("td",{className:"px-2",children:"1111"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"px-2",children:"0001"}),e.jsx("td",{className:"px-2",children:"0001"}),e.jsx("td",{className:"px-2",children:"0010"}),e.jsx("td",{className:"px-2",children:"0100"}),e.jsx("td",{className:"px-2",children:"1000"}),e.jsx("td",{className:"px-2",children:"0111"}),e.jsx("td",{className:"px-2",children:"1011"}),e.jsx("td",{className:"px-2",children:"1101"}),e.jsx("td",{className:"px-2",children:"1110"})]})]})]})}),e.jsxs("p",{className:"mt-4",children:["If the received word is 1011, it lies in the second coset. The coset leader is 0001. Adding ",e.jsx(s,{children:"1011 + 0001 = 1010"}),", which is the code word at the head of the column containing 1011."]})]}),e.jsxs(c,{type:"success",children:[e.jsx("strong",{children:"Section Summary:"})," Matrix encoding provides a systematic way to construct codes using matrix multiplication. The generator matrix ",e.jsx(s,{children:"\\mathbf{G}"})," defines an encoding function that is a monomorphism. Matrix codes are group codes, and for group codes, the minimum distance equals the minimum non-zero weight. Decoding by coset leaders provides an efficient method for error correction in group codes."]})]})}export{g as default};
