import{j as a}from"./vendor-animation-0o8UKZ_1.js";import{L as i,D as h,E as s,C as m,T as l}from"./Callout-DA0JknRv.js";import{I as t,M as e}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function u(){return a.jsxs(i,{sectionId:12,children:[a.jsx("h2",{children:"Dual Code of a Linear Code"}),a.jsx("p",{children:"The dual code of a linear code is a fundamental concept that provides deep insights into the structure of codes. It is defined using the orthogonality relation between vectors."}),a.jsx("h3",{children:"Inner Products and Orthogonality"}),a.jsxs(h,{title:"Intersection and Scalar Product",children:["Let ",a.jsx(t,{math:"\\\\mathbf{x} = (x_1 \\\\, x_2 \\\\, \\\\cdots \\\\, x_n)"})," and",a.jsx(t,{math:"\\\\mathbf{y} = (y_1 \\\\, y_2 \\\\, \\\\cdots \\\\, y_n)"})," be two vectors of length ",a.jsx(t,{math:"n"})," over a field ",a.jsx(t,{math:"F"}),". Then:",a.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-2",children:[a.jsxs("li",{children:["The ",a.jsx("strong",{children:"intersection"})," (Hadamard product) is:",a.jsx(e,{math:"\\\\mathbf{x} * \\\\mathbf{y} = (x_1 y_1 \\\\, x_2 y_2 \\\\, \\\\cdots \\\\, x_n y_n)"})]}),a.jsxs("li",{children:["The ",a.jsx("strong",{children:"scalar product"})," (inner product) is:",a.jsx(e,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = x_1 y_1 + x_2 y_2 + \\\\cdots + x_n y_n \\\\in F"})]})]})]}),a.jsx("p",{children:"Note that:"}),a.jsx(e,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = \\\\mathbf{x}\\\\mathbf{y}^t = \\\\mathbf{y} \\\\cdot \\\\mathbf{x} = \\\\mathbf{y}\\\\mathbf{x}^t"}),a.jsxs(s,{title:"Binary Vector Products",children:[a.jsxs("p",{children:["Let ",a.jsx(t,{math:"F = \\\\mathbb{B}"})," and:"]}),a.jsx(e,{math:"\\\\mathbf{x} = (1 \\\\, 1 \\\\, 0 \\\\, 1), \\\\quad \\\\mathbf{y} = (1 \\\\, 1 \\\\, 1 \\\\, 1)"}),a.jsx("p",{className:"mt-2",children:"Then:"}),a.jsx(e,{math:"\\\\mathbf{x} * \\\\mathbf{y} = (1 \\\\, 1 \\\\, 0 \\\\, 1)"}),a.jsx(e,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = 1 + 1 + 0 + 1 = 1"}),a.jsx("p",{className:"mt-2",children:"For another example:"}),a.jsx(e,{math:"\\\\mathbf{z} = (1 \\\\, 0 \\\\, 1 \\\\, 0 \\\\, 1 \\\\, 1), \\\\quad \\\\mathbf{t} = (1 \\\\, 1 \\\\, 0 \\\\, 1 \\\\, 0 \\\\, 1)"}),a.jsx(e,{math:"\\\\mathbf{z} * \\\\mathbf{t} = (1 \\\\, 0 \\\\, 0 \\\\, 0 \\\\, 0 \\\\, 1)"}),a.jsx(e,{math:"\\\\mathbf{z} \\\\cdot \\\\mathbf{t} = 1 + 0 + 0 + 0 + 0 + 1 = 0"})]}),a.jsxs(h,{title:"Orthogonal Vectors",children:["Two vectors ",a.jsx(t,{math:"\\\\mathbf{x}"})," and ",a.jsx(t,{math:"\\\\mathbf{y}"})," of the same length ",a.jsx(t,{math:"n"})," over",a.jsx(t,{math:"F"})," are called ",a.jsx("strong",{children:"orthogonal"})," if ",a.jsx(t,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = 0"}),", or equivalently:",a.jsx(e,{math:"\\\\mathbf{x}\\\\mathbf{y}^t = \\\\mathbf{y} \\\\cdot \\\\mathbf{x} = \\\\mathbf{y}\\\\mathbf{x}^t = 0"})]}),a.jsxs(m,{type:"info",children:[a.jsx("strong",{children:"Observation:"})," For binary vectors ",a.jsx(t,{math:"\\\\mathbf{x}"})," and ",a.jsx(t,{math:"\\\\mathbf{y}"}),":",a.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[a.jsxs("li",{children:[a.jsx(t,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = 0"})," iff ",a.jsx(t,{math:"\\\\text{wt}(\\\\mathbf{x} * \\\\mathbf{y})"})," is even"]}),a.jsxs("li",{children:[a.jsx(t,{math:"\\\\mathbf{x} \\\\cdot \\\\mathbf{y} = 1"})," iff ",a.jsx(t,{math:"\\\\text{wt}(\\\\mathbf{x} * \\\\mathbf{y})"})," is odd"]})]})]}),a.jsx("h3",{children:"The Dual Code"}),a.jsxs(h,{title:"Dual Code (Orthogonal Code)",children:["If ",a.jsx(t,{math:"\\\\mathcal{C}"})," is an ",a.jsx(t,{math:"[n, k, d]"})," linear code over ",a.jsx(t,{math:"F"}),", its ",a.jsx("strong",{children:"dual code"})," or ",a.jsx("strong",{children:"orthogonal code"})," ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is the set of all vectors of length ",a.jsx(t,{math:"n"})," that are orthogonal to all code words of ",a.jsx(t,{math:"\\\\mathcal{C}"}),":",a.jsx(e,{math:"\\\\mathcal{C}^\\\\perp = \\\\{\\\\mathbf{u} \\\\in V(n, q) \\\\mid \\\\mathbf{u} \\\\cdot \\\\mathbf{v} = 0 \\\\,\\\\, \\\\forall \\\\mathbf{v} \\\\in \\\\mathcal{C}\\\\}"})]}),a.jsxs(s,{title:"Dual of a Simple Code",children:[a.jsxs("p",{children:["Consider the linear code ",a.jsx(t,{math:"\\\\mathcal{C}"})," with generator matrix:"]}),a.jsx(e,{math:"\\\\mathbf{G} = \\\\begin{pmatrix} 1 & 1 & 0 & 0 \\\\\\\\ 0 & 1 & 1 & 1 \\\\\\\\ 1 & 0 & 1 & 0 \\\\end{pmatrix}"}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"(x_1 \\\\, x_2 \\\\, x_3 \\\\, x_4)"})," be orthogonal to all code words. In particular, it must be orthogonal to the rows of ",a.jsx(t,{math:"\\\\mathbf{G}"}),":"]}),a.jsx(e,{math:"x_1 + x_2 = 0, \\\\quad x_2 + x_3 + x_4 = 0, \\\\quad x_1 + x_3 = 0"}),a.jsxs("p",{className:"mt-2",children:["These relations give ",a.jsx(t,{math:"x_1 = x_2 = x_3"})," and ",a.jsx(t,{math:"x_4 = 0"}),"."]}),a.jsx("p",{className:"mt-2",children:"Therefore:"}),a.jsx(e,{math:"\\\\mathcal{C}^\\\\perp = \\\\{0000, 1110\\\\}"}),a.jsxs("p",{className:"mt-2",children:["Note that ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is also linear and",a.jsx(t,{math:"\\\\dim \\\\mathcal{C}^\\\\perp + \\\\dim \\\\mathcal{C} = 1 + 3 = 4 = n"}),"."]})]}),a.jsxs(s,{title:"Dual of the (4,7) Hamming Code",children:[a.jsxs("p",{children:["The (4, 7) binary Hamming code ",a.jsx(t,{math:"\\\\mathcal{C}"})," is a [7, 4, 3] linear code with basis:"]}),a.jsx(e,{math:"1110100, \\\\quad 0111010, \\\\quad 0011101, \\\\quad 0001011"}),a.jsxs("p",{className:"mt-2",children:["A vector ",a.jsx(t,{math:"(x_1 \\\\, x_2 \\\\, \\\\cdots \\\\, x_7)"})," is orthogonal to ",a.jsx(t,{math:"\\\\mathcal{C}"})," iff it is orthogonal to the basis vectors:"]}),a.jsx(e,{math:"x_1 + x_2 + x_3 + x_5 = 0"}),a.jsx(e,{math:"x_2 + x_3 + x_4 + x_6 = 0"}),a.jsx(e,{math:"x_3 + x_4 + x_5 + x_7 = 0"}),a.jsx(e,{math:"x_4 + x_6 + x_7 = 0"}),a.jsx("p",{className:"mt-2",children:"Solving these equations in matrix form:"}),a.jsx(e,{math:"\\\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 & 0 & 0 \\\\\\\\ 1 & 1 & 1 & 0 & 1 & 0 & 0 \\\\\\\\ 1 & 1 & 0 & 0 & 0 & 1 & 0 \\\\\\\\ 0 & 1 & 1 & 0 & 0 & 0 & 1 \\\\end{pmatrix} \\\\begin{pmatrix} x_1 \\\\\\\\ \\\\vdots \\\\\\\\ x_7 \\\\end{pmatrix} = 0"}),a.jsxs("p",{className:"mt-2",children:["The generator matrix of ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is:"]}),a.jsx(e,{math:"\\\\mathbf{G} = \\\\begin{pmatrix} 1 & 0 & 0 & 1 & 1 & 1 & 0 \\\\\\\\ 0 & 1 & 0 & 0 & 1 & 1 & 1 \\\\\\\\ 0 & 0 & 1 & 1 & 1 & 0 & 1 \\\\end{pmatrix}"}),a.jsxs("p",{className:"mt-2",children:["So ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is a [7, 3, -] linear code."]})]}),a.jsx("h3",{children:"Main Theorem on Dual Codes"}),a.jsxs(l,{title:"Properties of Dual Codes",proof:a.jsxs(a.Fragment,{children:[a.jsx("p",{children:a.jsxs("strong",{children:["Part 1: ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is linear."]})}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\mathbf{u}, \\\\mathbf{w} \\\\in \\\\mathcal{C}^\\\\perp"})," and",a.jsx(t,{math:"\\\\alpha, \\\\beta \\\\in GF(q) = F"}),". For any ",a.jsx(t,{math:"\\\\mathbf{v} \\\\in \\\\mathcal{C}"}),":"]}),a.jsx(e,{math:"(\\\\alpha\\\\mathbf{u} + \\\\beta\\\\mathbf{w})\\\\mathbf{v}^t = \\\\alpha(\\\\mathbf{u}\\\\mathbf{v}^t) + \\\\beta(\\\\mathbf{w}\\\\mathbf{v}^t) = 0"}),a.jsxs("p",{className:"mt-2",children:["Therefore ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is a linear code."]}),a.jsx("p",{className:"mt-4",children:a.jsxs("strong",{children:["Part 2: ",a.jsx(t,{math:"\\\\mathbf{G}"})," is a parity check matrix for ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"}),"."]})}),a.jsxs("p",{className:"mt-2",children:["Suppose ",a.jsx(t,{math:"\\\\mathbf{G}"})," is a ",a.jsx(t,{math:"k \\\\times n"})," matrix. The map",a.jsx(t,{math:"\\\\phi: V(k, q) \\\\to \\\\mathcal{C}"})," defined by",a.jsx(t,{math:"\\\\phi(\\\\mathbf{a}) = \\\\mathbf{aG}"})," is a vector space isomorphism. Hence",a.jsx(t,{math:"k = \\\\dim \\\\mathcal{C}"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\mathbf{u} \\\\in \\\\mathcal{C}^\\\\perp"}),". Then",a.jsx(t,{math:"\\\\mathbf{v}\\\\mathbf{u}^t = 0"})," for all ",a.jsx(t,{math:"\\\\mathbf{v} \\\\in \\\\mathcal{C}"}),", i.e., ",a.jsx(t,{math:"\\\\mathbf{a}(\\\\mathbf{G}\\\\mathbf{u}^t) = 0"})," for all ",a.jsx(t,{math:"\\\\mathbf{a} \\\\in V(k, q)"}),". This implies ",a.jsx(t,{math:"\\\\mathbf{G}\\\\mathbf{u}^t = 0"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Conversely, if ",a.jsx(t,{math:"\\\\mathbf{G}\\\\mathbf{u}^t = 0"}),", then",a.jsx(t,{math:"(\\\\mathbf{aG})\\\\mathbf{u}^t = 0"})," for all ",a.jsx(t,{math:"\\\\mathbf{a}"}),", so",a.jsx(t,{math:"\\\\mathbf{u} \\\\in \\\\mathcal{C}^\\\\perp"}),"."]}),a.jsx("p",{className:"mt-2",children:"Hence:"}),a.jsx(e,{math:"\\\\mathcal{C}^\\\\perp = \\\\{\\\\mathbf{u} \\\\in V(n, q) \\\\mid \\\\mathbf{G}\\\\mathbf{u}^t = 0\\\\}"}),a.jsx("p",{className:"mt-4",children:a.jsxs("strong",{children:["Part 3: Dimension of ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"}),"."]})}),a.jsxs("p",{className:"mt-2",children:["Define ",a.jsx(t,{math:"\\\\theta: V(n, q) \\\\to V(n, q)"})," by ",a.jsx(t,{math:"\\\\theta(\\\\mathbf{x}) = \\\\mathbf{G}\\\\mathbf{x}^t"}),". Then ",a.jsx(t,{math:"\\\\theta"})," is a linear transformation with:"]}),a.jsx(e,{math:"\\\\text{rank}(\\\\theta) + \\\\text{nullity}(\\\\theta) = n"}),a.jsxs("p",{className:"mt-2",children:["Since ",a.jsx(t,{math:"\\\\text{rank}(\\\\theta) = \\\\text{rank}(\\\\mathbf{G}) = k"})," and",a.jsx(t,{math:"\\\\ker \\\\theta = \\\\mathcal{C}^\\\\perp"}),":"]}),a.jsx(e,{math:"\\\\dim \\\\mathcal{C}^\\\\perp = n - k"}),a.jsx("p",{className:"mt-4",children:a.jsxs("strong",{children:["Part 4: ",a.jsx(t,{math:"\\\\mathbf{H}"})," is a generator matrix for ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"}),"."]})}),a.jsxs("p",{className:"mt-2",children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}'"})," be the code generated by ",a.jsx(t,{math:"\\\\mathbf{H}"}),". Every code word in ",a.jsx(t,{math:"\\\\mathcal{C}"})," is orthogonal to every row of ",a.jsx(t,{math:"\\\\mathbf{H}"})," and hence to every code word in ",a.jsx(t,{math:"\\\\mathcal{C}'"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Therefore ",a.jsx(t,{math:"\\\\mathcal{C}' \\\\subseteq \\\\mathcal{C}^\\\\perp"}),". Since ",a.jsx(t,{math:"\\\\mathbf{H}"})," has rank ",a.jsx(t,{math:"n - k"}),", ",a.jsx(t,{math:"\\\\dim \\\\mathcal{C}' = n - k = \\\\dim \\\\mathcal{C}^\\\\perp"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Hence ",a.jsx(t,{math:"\\\\mathcal{C}' = \\\\mathcal{C}^\\\\perp"}),"."]})]}),children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}"})," be a linear ",a.jsx(t,{math:"[n, k, d]"})," code with generator matrix ",a.jsx(t,{math:"\\\\mathbf{G}"})," and parity check matrix ",a.jsx(t,{math:"\\\\mathbf{H}"}),". Then",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is a linear ",a.jsx(t,{math:"[n, n-k, -]"})," code with generator matrix ",a.jsx(t,{math:"\\\\mathbf{H}"})," and parity check matrix ",a.jsx(t,{math:"\\\\mathbf{G}"}),"."]}),a.jsxs(m,{type:"success",children:[a.jsx("strong",{children:"Key Result:"})," ",a.jsx(t,{math:"(\\\\mathcal{C}^\\\\perp)^\\\\perp = \\\\mathcal{C}"}),". The dual of the dual is the original code."]}),a.jsxs(s,{title:"Dual of a Polynomial Code",children:[a.jsxs("p",{children:["Consider the (4, 7) polynomial code ",a.jsx(t,{math:"\\\\mathcal{C}"})," generated by ",a.jsx(t,{math:"1 + X + X^3"}),". Its generator matrix is:"]}),a.jsx(e,{math:"\\\\mathbf{G} = \\\\begin{pmatrix} 1 & 1 & 0 & 1 & 0 & 0 & 0 \\\\\\\\ 0 & 1 & 1 & 0 & 1 & 0 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 0 & 1 & 0 \\\\\\\\ 0 & 0 & 0 & 1 & 1 & 0 & 1 \\\\end{pmatrix}"}),a.jsxs("p",{className:"mt-2",children:["Solving ",a.jsx(t,{math:"\\\\mathbf{G}\\\\mathbf{x}^t = 0"}),":"]}),a.jsx(e,{math:"x_4 = x_1 + x_3, \\\\quad x_5 = x_2 + x_3, \\\\quad x_6 = x_1 + x_2 + x_3, \\\\quad x_7 = x_1 + x_3"}),a.jsxs("p",{className:"mt-2",children:["The generator matrix of ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is:"]}),a.jsx(e,{math:"\\\\mathbf{H} = \\\\begin{pmatrix} 1 & 0 & 0 & 1 & 0 & 1 & 1 \\\\\\\\ 0 & 1 & 0 & 1 & 1 & 1 & 0 \\\\\\\\ 0 & 0 & 1 & 1 & 1 & 0 & 1 \\\\end{pmatrix}"}),a.jsxs("p",{className:"mt-2",children:[a.jsx("strong",{children:"Important observation:"})," If we check whether ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp"})," is a polynomial code generated by some ",a.jsx(t,{math:"f(X) = 1 + bX + cX^2 + dX^3 + eX^4"}),", we find that no such polynomial exists. Thus, ",a.jsx("strong",{children:"the dual of a polynomial code need not be a polynomial code"}),"."]})]}),a.jsx("h3",{children:"Self-Dual Codes"}),a.jsxs(h,{title:"Self-Dual Code",children:["A linear code ",a.jsx(t,{math:"\\\\mathcal{C}"})," over ",a.jsx(t,{math:"F"})," is called ",a.jsx("strong",{children:"self-dual"}),"if ",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp = \\\\mathcal{C}"}),"."]}),a.jsxs(m,{type:"info",children:[a.jsx("strong",{children:"Properties of Self-Dual Codes:"}),a.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[a.jsxs("li",{children:["The length of a self-dual code is always even (since ",a.jsx(t,{math:"k = n - k"})," implies ",a.jsx(t,{math:"n = 2k"}),")"]}),a.jsx("li",{children:"The weight of every code word of a binary self-dual code is even"})]})]}),a.jsxs(s,{title:"Self-Dual Code of Length 4",children:[a.jsxs("p",{children:["Let ",a.jsx(t,{math:"\\\\mathcal{C}"})," be a binary self-dual code of length 4. Then its dimension is ",a.jsx(t,{math:"k = 2"}),"."]}),a.jsxs("p",{className:"mt-2",children:["Consider vectors ",a.jsx(t,{math:"(1 \\\\, 1 \\\\, 0 \\\\, 0)"})," and ",a.jsx(t,{math:"(0 \\\\, 0 \\\\, 1 \\\\, 1)"}),". These are linearly independent and each is self-orthogonal (inner product with itself is 0 over ",a.jsx(t,{math:"\\\\mathbb{B}"}),"). Also, they are orthogonal to each other."]}),a.jsxs("p",{className:"mt-2",children:["Thus, the code ",a.jsx(t,{math:"\\\\mathcal{C} = \\\\{0000, 1100, 0011, 1111\\\\}"})," is self-dual."]}),a.jsxs("p",{className:"mt-2",children:[a.jsx("strong",{children:"Note:"})," The vectors ",a.jsx(t,{math:"(1 \\\\, 1 \\\\, 0 \\\\, 0)"})," and ",a.jsx(t,{math:"(1 \\\\, 0 \\\\, 1 \\\\, 0)"})," are linearly independent but ",a.jsx(t,{math:"(1 \\\\, 1 \\\\, 0 \\\\, 0) \\\\cdot (1 \\\\, 0 \\\\, 1 \\\\, 0) = 1 \\\\neq 0"}),", so they do not generate a self-dual code."]})]}),a.jsxs(m,{type:"warning",children:[a.jsx("strong",{children:"Remark on Dual Codes:"})," The dual of a code ",a.jsx(t,{math:"\\\\mathcal{C}"})," that is not necessarily linear can still be defined as",a.jsx(t,{math:"\\\\mathcal{C}^\\\\perp = \\\\{\\\\mathbf{u} \\\\in V(n, q) \\\\mid \\\\mathbf{u} \\\\cdot \\\\mathbf{v} = 0 \\\\,\\\\, \\\\forall \\\\mathbf{v} \\\\in \\\\mathcal{C}\\\\}"}),". However, in this case ",a.jsx(t,{math:"(\\\\mathcal{C}^\\\\perp)^\\\\perp"})," may not equal ",a.jsx(t,{math:"\\\\mathcal{C}"}),"."]})]})}export{u as default};
