import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as d,D as a,C as i,T as n,E as h}from"./Callout-BFDudfNm.js";import{I as s,M as t}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-DiI0rOOo.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CeIDuB74.js";function p(){return e.jsxs(d,{sectionId:14,children:[e.jsx("h2",{children:"New Codes from Given Codes"}),e.jsxs("p",{children:["Given a linear code ",e.jsx(s,{math:"\\mathcal{C}"}),", we can construct new codes by modifying it in various ways. The three most important operations are ",e.jsx("strong",{children:"puncturing"}),",",e.jsx("strong",{children:" shortening"}),", and ",e.jsx("strong",{children:"extending"}),". These operations allow us to adjust code parameters to meet specific requirements."]}),e.jsx("h3",{children:"Punctured Codes"}),e.jsxs(a,{title:"Punctured Code",children:["Let ",e.jsx(s,{math:"\\mathcal{C}"})," be an ",e.jsx(s,{math:"[n, k, d]"})," code over ",e.jsx(s,{math:"F"}),". The ",e.jsx("strong",{children:"punctured code"})," ",e.jsx(s,{math:"\\mathcal{C}^*"})," obtained by puncturing",e.jsx(s,{math:"\\mathcal{C}"})," in coordinate position ",e.jsx(s,{math:"i"})," is the code of length",e.jsx(s,{math:"n - 1"})," formed by deleting the ",e.jsx(s,{math:"i"}),"-th coordinate from every code word:",e.jsx(t,{math:"\\mathcal{C}^* = \\{(c_1, \\ldots, c_{i-1}, c_{i+1}, \\ldots, c_n) \\mid (c_1, \\ldots, c_n) \\in \\mathcal{C}\\}"})]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Intuition:"})," Puncturing removes a coordinate position from all code words. This reduces the code length by 1 while potentially affecting the dimension and minimum distance."]}),e.jsxs(n,{title:"Parameters of Punctured Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Length:"})," By definition, deleting one position reduces the length from ",e.jsx(s,{math:"n"})," to ",e.jsx(s,{math:"n - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Dimension:"})," Let ",e.jsx(s,{math:"\\mathbf{G}"})," be a generator matrix of ",e.jsx(s,{math:"\\mathcal{C}"}),". The generator matrix ",e.jsx(s,{math:"\\mathbf{G}^*"}),"of ",e.jsx(s,{math:"\\mathcal{C}^*"})," is obtained by deleting the ",e.jsx(s,{math:"i"}),"-th column of ",e.jsx(s,{math:"\\mathbf{G}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If the ",e.jsx(s,{math:"i"}),"-th column is a linear combination of the other columns, then ",e.jsx(s,{math:"\\text{rank}(\\mathbf{G}^*) = k"}),". Otherwise, ",e.jsx(s,{math:"\\text{rank}(\\mathbf{G}^*) = k - 1"}),". In either case, ",e.jsx(s,{math:"k^* \\geq k - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Minimum distance:"})," Consider a code word ",e.jsx(s,{math:"\\mathbf{c}"})," of minimum weight ",e.jsx(s,{math:"d"}),". If ",e.jsx(s,{math:"c_i = 0"}),", puncturing does not change its weight. If ",e.jsx(s,{math:"c_i \\neq 0"}),", puncturing reduces its weight by 1."]}),e.jsxs("p",{className:"mt-2",children:["If there exists a minimum weight code word with ",e.jsx(s,{math:"c_i = 0"}),", then ",e.jsx(s,{math:"d^* = d"}),". Otherwise, ",e.jsx(s,{math:"d^* = d - 1"}),". In all cases, ",e.jsx(s,{math:"d^* \\geq d - 1"}),"."]})]}),children:["If ",e.jsx(s,{math:"\\mathcal{C}"})," is an ",e.jsx(s,{math:"[n, k, d]"})," code and ",e.jsx(s,{math:"\\mathcal{C}^*"})," is obtained by puncturing ",e.jsx(s,{math:"\\mathcal{C}"})," in one position, then ",e.jsx(s,{math:"\\mathcal{C}^*"})," is an ",e.jsx(s,{math:"[n-1, k^*, d^*]"})," code where:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(s,{math:"k - 1 \\leq k^* \\leq k"})}),e.jsx("li",{children:e.jsx(s,{math:"d - 1 \\leq d^* \\leq d"})})]})]}),e.jsxs(h,{title:"Puncturing the (7, 4) Hamming Code",children:[e.jsxs("p",{children:["Consider the ",e.jsx(s,{math:"[7, 4, 3]"})," Hamming code with generator matrix:"]}),e.jsx(t,{math:"\\mathbf{G} = \\begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 0 \\\\ 0 & 1 & 0 & 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 & 0 & 1 & 1 \\\\ 0 & 0 & 0 & 1 & 1 & 1 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"Puncturing by deleting the last column gives:"}),e.jsx(t,{math:"\\mathbf{G}^* = \\begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 \\\\ 0 & 1 & 0 & 0 & 1 & 0 \\\\ 0 & 0 & 1 & 0 & 0 & 1 \\\\ 0 & 0 & 0 & 1 & 1 & 1 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["Since the last column of ",e.jsx(s,{math:"\\mathbf{G}"})," is not a linear combination of other columns, the punctured code has dimension ",e.jsx(s,{math:"k^* = 4"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The resulting ",e.jsx(s,{math:"[6, 4, 2]"})," code is called the ",e.jsx("strong",{children:"shortened Hamming code"}),". Note that all minimum weight code words of the original Hamming code have a 1 in at least one position, so puncturing can reduce the minimum distance from 3 to 2."]})]}),e.jsx("h3",{children:"Shortened Codes"}),e.jsxs(a,{title:"Shortened Code",children:["Let ",e.jsx(s,{math:"\\mathcal{C}"})," be an ",e.jsx(s,{math:"[n, k, d]"})," code. The ",e.jsx("strong",{children:"shortened code"}),e.jsx(s,{math:"\\mathcal{C}_s"})," obtained by shortening ",e.jsx(s,{math:"\\mathcal{C}"})," in coordinate position ",e.jsx(s,{math:"i"})," is the code formed by:",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Selecting all code words with ",e.jsx(s,{math:"c_i = 0"})]}),e.jsxs("li",{children:["Deleting the ",e.jsx(s,{math:"i"}),"-th coordinate from these code words"]})]}),e.jsx(t,{math:"\\mathcal{C}_s = \\{(c_1, \\ldots, c_{i-1}, c_{i+1}, \\ldots, c_n) \\mid (c_1, \\ldots, c_n) \\in \\mathcal{C}, c_i = 0\\}"})]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Key Difference:"})," Puncturing deletes a position from ",e.jsx("em",{children:"all"})," code words, while shortening first restricts to code words with 0 in that position, then deletes it. Shortening is more restrictive and produces a smaller code."]}),e.jsxs(n,{title:"Parameters of Shortened Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Length:"})," Deleting one position gives length ",e.jsx(s,{math:"n - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Dimension:"})," The shortened code ",e.jsx(s,{math:"\\mathcal{C}_s"})," consists of code words from ",e.jsx(s,{math:"\\mathcal{C}"})," with ",e.jsx(s,{math:"c_i = 0"}),". This is the intersection of ",e.jsx(s,{math:"\\mathcal{C}"})," with the hyperplane ",e.jsx(s,{math:"x_i = 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If all code words have ",e.jsx(s,{math:"c_i = 0"}),", then ",e.jsx(s,{math:"\\mathcal{C}_s"})," has dimension ",e.jsx(s,{math:"k"})," (after coordinate deletion). Otherwise, the constraint",e.jsx(s,{math:"c_i = 0"})," reduces dimension by 1, giving ",e.jsx(s,{math:"k_s = k - 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Minimum distance:"})," Since ",e.jsx(s,{math:"\\mathcal{C}_s \\subseteq \\mathcal{C}"}),"(viewing shortened code words as code words of ",e.jsx(s,{math:"\\mathcal{C}"})," with ",e.jsx(s,{math:"c_i = 0"}),"), the minimum weight of non-zero code words in ",e.jsx(s,{math:"\\mathcal{C}_s"})," is at least ",e.jsx(s,{math:"d"}),". Deleting the zero coordinate does not change weight, so ",e.jsx(s,{math:"d_s \\geq d"}),"."]})]}),children:["If ",e.jsx(s,{math:"\\mathcal{C}"})," is an ",e.jsx(s,{math:"[n, k, d]"})," code and ",e.jsx(s,{math:"\\mathcal{C}_s"})," is obtained by shortening ",e.jsx(s,{math:"\\mathcal{C}"})," in one position, then ",e.jsx(s,{math:"\\mathcal{C}_s"})," is an ",e.jsx(s,{math:"[n-1, k_s, d_s]"})," code where:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(s,{math:"k - 1 \\leq k_s \\leq k"})}),e.jsx("li",{children:e.jsx(s,{math:"d_s \\geq d"})})]})]}),e.jsxs(h,{title:"Shortening a Binary Code",children:[e.jsxs("p",{children:["Consider the ",e.jsx(s,{math:"[4, 2]"})," code:"]}),e.jsx(t,{math:"\\mathcal{C} = \\{0000, 1100, 0011, 1111\\}"}),e.jsxs("p",{className:"mt-2",children:["To shorten in the first position, we select code words with ",e.jsx(s,{math:"c_1 = 0"}),":"]}),e.jsx(t,{math:"\\{0000, 0011\\}"}),e.jsx("p",{className:"mt-2",children:"Then delete the first coordinate:"}),e.jsx(t,{math:"\\mathcal{C}_s = \\{000, 011\\}"}),e.jsxs("p",{className:"mt-2",children:["The shortened code is a ",e.jsx(s,{math:"[3, 1, 2]"})," code. Note that the minimum distance is preserved (still 2)."]})]}),e.jsx("h3",{children:"Extended Codes"}),e.jsxs(a,{title:"Extended Code",children:["Let ",e.jsx(s,{math:"\\mathcal{C}"})," be an ",e.jsx(s,{math:"[n, k, d]"})," code over ",e.jsx(s,{math:"F"}),". The ",e.jsx("strong",{children:"extended code"})," ",e.jsx(s,{math:"\\bar{\\mathcal{C}}"})," (or ",e.jsx(s,{math:"\\mathcal{C}_e"}),") is obtained by adding an ",e.jsx("strong",{children:"overall parity check"})," coordinate to each code word:",e.jsx(t,{math:"\\bar{\\mathcal{C}} = \\{(c_1, c_2, \\ldots, c_n, c_{n+1}) \\mid (c_1, \\ldots, c_n) \\in \\mathcal{C}, \\, c_{n+1} = -\\sum_{i=1}^{n} c_i\\}"})]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Binary Case:"})," For binary codes, ",e.jsx(s,{math:"c_{n+1} = c_1 + c_2 + \\cdots + c_n"}),"(since ",e.jsx(s,{math:"-1 = 1"})," in ",e.jsx(s,{math:"\\mathbb{B}"}),"). The extended code word has even weight because ",e.jsx(s,{math:"c_1 + c_2 + \\cdots + c_n + c_{n+1} = 0"}),"."]}),e.jsxs(n,{title:"Parameters of Extended Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Length:"})," Adding one coordinate increases length to ",e.jsx(s,{math:"n + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Dimension:"})," The map ",e.jsx(s,{math:"\\mathcal{C} \\to \\bar{\\mathcal{C}}"})," that appends the parity check digit is a bijection, so ",e.jsx(s,{math:"|\\bar{\\mathcal{C}}| = |\\mathcal{C}|"}),". Since the code remains linear, ",e.jsx(s,{math:"\\bar{k} = k"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Minimum distance (binary):"})," Let ",e.jsx(s,{math:"\\mathbf{c}"})," be a code word of weight ",e.jsx(s,{math:"w"})," in ",e.jsx(s,{math:"\\mathcal{C}"}),". The extended code word has weight ",e.jsx(s,{math:"w"})," if ",e.jsx(s,{math:"w"})," is even, or ",e.jsx(s,{math:"w + 1"})," if",e.jsx(s,{math:"w"})," is odd."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"d"})," is odd, all minimum weight code words have odd weight, so they become weight ",e.jsx(s,{math:"d + 1"})," in ",e.jsx(s,{math:"\\bar{\\mathcal{C}}"}),". Hence ",e.jsx(s,{math:"\\bar{d} = d + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"d"})," is even, minimum weight code words remain weight ",e.jsx(s,{math:"d"}),", so ",e.jsx(s,{math:"\\bar{d} = d"}),"."]})]}),children:["If ",e.jsx(s,{math:"\\mathcal{C}"})," is an ",e.jsx(s,{math:"[n, k, d]"})," binary code, then the extended code ",e.jsx(s,{math:"\\bar{\\mathcal{C}}"})," is an ",e.jsx(s,{math:"[n+1, k, \\bar{d}]"})," code where:",e.jsx(t,{math:"\\bar{d} = \\begin{cases} d + 1 & \\text{if } d \\text{ is odd} \\\\ d & \\text{if } d \\text{ is even} \\end{cases}"}),"More precisely, ",e.jsx(s,{math:"\\bar{d} = d"})," or ",e.jsx(s,{math:"\\bar{d} = d + 1"}),", and ",e.jsx(s,{math:"\\bar{d}"})," is always even for binary codes."]}),e.jsxs(h,{title:"Extended Hamming Code",children:[e.jsxs("p",{children:["The ",e.jsx(s,{math:"[7, 4, 3]"})," Hamming code has odd minimum distance 3. Extending it gives the ",e.jsx(s,{math:"[8, 4, 4]"})," ",e.jsx("strong",{children:"extended Hamming code"}),"."]}),e.jsx("p",{className:"mt-2",children:"If the original parity check matrix is:"}),e.jsx(t,{math:"\\mathbf{H} = \\begin{pmatrix} 1 & 1 & 0 & 1 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 1 \\end{pmatrix}"}),e.jsx("p",{className:"mt-2",children:"The extended code has parity check matrix:"}),e.jsx(t,{math:"\\bar{\\mathbf{H}} = \\begin{pmatrix} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\\\ 1 & 1 & 0 & 1 & 1 & 0 & 0 & 0 \\\\ 1 & 0 & 1 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 \\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["The first row enforces the overall parity check. The extended ",e.jsx(s,{math:"[8, 4, 4]"})," code can correct 1 error and detect 2 errors."]})]}),e.jsx("h3",{children:"Relationships Between Operations"}),e.jsxs(n,{title:"Puncturing and Shortening Duality",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(s,{math:"\\mathcal{C}"})," be an ",e.jsx(s,{math:"[n, k]"})," code with generator matrix ",e.jsx(s,{math:"\\mathbf{G}"})," and parity check matrix ",e.jsx(s,{math:"\\mathbf{H}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Puncturing ",e.jsx(s,{math:"\\mathcal{C}"})," corresponds to deleting a column of ",e.jsx(s,{math:"\\mathbf{G}"}),". For the dual code ",e.jsx(s,{math:"\\mathcal{C}^\\perp"})," (generated by ",e.jsx(s,{math:"\\mathbf{H}"}),"), this corresponds to deleting a column of ",e.jsx(s,{math:"\\mathbf{H}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Shortening ",e.jsx(s,{math:"\\mathcal{C}^\\perp"})," in position ",e.jsx(s,{math:"i"})," selects code words with 0 in position ",e.jsx(s,{math:"i"}),", then deletes that position. The parity check matrix for this shortened code is obtained by deleting column ",e.jsx(s,{math:"i"})," of ",e.jsx(s,{math:"\\mathbf{H}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This shows that ",e.jsx(s,{math:"(\\mathcal{C}^*)^\\perp = (\\mathcal{C}^\\perp)_s"}),"."]})]}),children:["Let ",e.jsx(s,{math:"\\mathcal{C}"})," be a linear code. Then:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["The dual of the punctured code equals the shortened dual: ",e.jsx(s,{math:"(\\mathcal{C}^*)^\\perp = (\\mathcal{C}^\\perp)_s"})]}),e.jsxs("li",{children:["The dual of the shortened code equals the punctured dual: ",e.jsx(s,{math:"(\\mathcal{C}_s)^\\perp = (\\mathcal{C}^\\perp)^*"})]})]})]}),e.jsxs(h,{title:"Chain of Operations",children:[e.jsxs("p",{children:["Starting from the ",e.jsx(s,{math:"[8, 4, 4]"})," extended Hamming code:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Puncture once:"})," Get ",e.jsx(s,{math:"[7, 4, 3]"})," Hamming code"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Puncture twice:"})," Get ",e.jsx(s,{math:"[6, 4, 2]"})," code"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Shorten once:"})," Get ",e.jsx(s,{math:"[7, 3, 4]"})," simplex code"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Shorten twice:"})," Get ",e.jsx(s,{math:"[6, 2, 4]"})," code"]})]}),e.jsx("p",{className:"mt-2",children:"Note that shortening preserves (or increases) minimum distance but reduces dimension, while puncturing preserves dimension but may reduce minimum distance."})]}),e.jsx("h3",{children:"Multiple Operations"}),e.jsxs(a,{title:"Puncturing Multiple Positions",children:["If ",e.jsx(s,{math:"\\mathcal{C}"})," is an ",e.jsx(s,{math:"[n, k, d]"})," code, puncturing in ",e.jsx(s,{math:"s"})," positions gives a code of length ",e.jsx(s,{math:"n - s"}),". The resulting parameters satisfy:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Dimension: ",e.jsx(s,{math:"k - s \\leq k^* \\leq k"})]}),e.jsxs("li",{children:["Minimum distance: ",e.jsx(s,{math:"d - s \\leq d^* \\leq d"})]})]})]}),e.jsxs(i,{type:"warning",children:[e.jsx("strong",{children:"Design Trade-offs:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Puncturing"})," trades length for potentially reduced minimum distance"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Shortening"})," trades dimension (information rate) for preserved/increased minimum distance"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Extending"})," trades increased length for improved minimum distance (when d is odd)"]})]})]}),e.jsxs(i,{type:"success",children:[e.jsx("strong",{children:"Summary:"})," The three fundamental operations for constructing new codes are:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Puncturing:"})," Delete a coordinate position from all code words.",e.jsx(s,{math:"[n, k, d] \\to [n-1, k^*, d^*]"})," with ",e.jsx(s,{math:"k^* \\geq k - 1"})," and ",e.jsx(s,{math:"d^* \\geq d - 1"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Shortening:"})," Restrict to code words with 0 in a position, then delete it.",e.jsx(s,{math:"[n, k, d] \\to [n-1, k_s, d_s]"})," with ",e.jsx(s,{math:"k_s \\geq k - 1"})," and ",e.jsx(s,{math:"d_s \\geq d"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Extending:"})," Add an overall parity check.",e.jsx(s,{math:"[n, k, d] \\to [n+1, k, \\bar{d}]"})," with ",e.jsx(s,{math:"\\bar{d} \\in \\{d, d+1\\}"})]})]})]})]})}export{p as default};
