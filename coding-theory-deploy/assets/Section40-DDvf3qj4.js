import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l,D as r,T as n,E as d,C as t}from"./Callout-DA0JknRv.js";import{I as s,M as i}from"./MathBlock-D5AMPR82.js";import"./vendor-react-Drj8qL0h.js";import"./index-CgdPy4I5.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-D2ojV1jj.js";function w(){return e.jsxs(l,{sectionId:40,children:[e.jsx("p",{children:"Hadamard codes are an important family of codes derived from Hadamard matrices. These codes achieve good distance properties and have strong connections to Reed-Muller codes and simplex codes. In this section, we construct Hadamard codes and analyze their fundamental properties."}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"From Hadamard Matrices to Binary Codes"}),e.jsxs(r,{title:"Binary Representation",children:[e.jsxs("p",{children:["Given a Hadamard matrix ",e.jsx(s,{children:"H"})," of order ",e.jsx(s,{children:"n"}),"with entries in ",e.jsx(s,{children:"{'{-1, +1}'}"}),", we convert it to a binary matrix ",e.jsx(s,{children:"H'"})," with entries in ",e.jsx(s,{children:"{'{0, 1}'}"}),"via the map:"]}),e.jsx(i,{children:"+1 mapsto 0, quad -1 mapsto 1"}),e.jsxs("p",{className:"mt-2",children:["Equivalently, ",e.jsx(s,{children:"H' = \frac{'{1}{2}'}(J - H)"})," where"," ",e.jsx(s,{children:"J"})," is the all-ones matrix."]})]}),e.jsxs(r,{title:"Hadamard Code (First Definition)",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{children:"H"})," be a normalized Hadamard matrix of order"," ",e.jsx(s,{children:"n"}),", and let ",e.jsx(s,{children:"H'"})," be the corresponding binary matrix. The ",e.jsx("strong",{children:"Hadamard code"})," of length ",e.jsx(s,{children:"n"}),"is the code ",e.jsx(s,{children:"\\mathcal{C}"})," consisting of all rows of"," ",e.jsx(s,{children:"H'"})," together with their complements."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{children:"H"})," has order ",e.jsx(s,{children:"n"}),", then the Hadamard code has:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Length ",e.jsx(s,{children:"n"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"2n"})," codewords"]})]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Reed-Muller Codes and Hadamard Codes"}),e.jsxs(r,{title:"First-Order Reed-Muller Code",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"first-order Reed-Muller code"})," ",e.jsx(s,{children:"R(1, m)"})," is a binary linear code of:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Length ",e.jsx(s,{children:"n = 2^m"})]}),e.jsxs("li",{children:["Dimension ",e.jsx(s,{children:"k = m + 1"})]}),e.jsxs("li",{children:["Minimum distance ",e.jsx(s,{children:"d = 2^\\{m-1\\}"})]})]}),e.jsxs("p",{className:"mt-2",children:["It can be defined as the set of all vectors"," ",e.jsx(s,{children:"(f(P_1), f(P_2), ldots, f(P_\\{2^m\\}))"})," where"," ",e.jsx(s,{children:"f"})," ranges over all affine functions"," ",e.jsx(s,{children:"f: \\mathbb{F}_2^m 	o \\mathbb{F}_2"})," and"," ",e.jsx(s,{children:"P_1, ldots, P_\\{2^m\\}"})," are all points in"," ",e.jsx(s,{children:"\\mathbb{F}_2^m"}),"."]})]}),e.jsxs(n,{title:"Generator Matrix for R(1,m)",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The affine functions on ",e.jsx(s,{children:"\\mathbb{F}_2^m"})," are:"]}),e.jsx(i,{children:"f(x_1, ldots, x_m) = a_0 + a_1 x_1 + cdots + a_m x_m"}),e.jsxs("p",{className:"mt-2",children:["There are ",e.jsx(s,{children:"2^\\{m+1\\}"})," choices for"," ",e.jsx(s,{children:"(a_0, a_1, \\ldots, a_m)"}),", giving"," ",e.jsx(s,{children:"2^\\{m+1\\}"})," codewords. The dimension is thus"," ",e.jsx(s,{children:"m + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The row for the constant function ",e.jsx(s,{children:"f = 1"})," is the all-ones vector. The row for ",e.jsx(s,{children:"f = x_i"})," evaluates to the ",e.jsx(s,{children:"i"}),"-th coordinate of each point."]})]}),children:[e.jsxs("p",{children:["A generator matrix for ",e.jsx(s,{children:"R(1, m)"})," is the"," ",e.jsx(s,{children:"(m+1) \\times 2^m"})," matrix:"]}),e.jsx(i,{children:`
          G = \begin\\{pmatrix\\} 1 & 1 & 1 & cdots & 1 \\ \\text{(rows encoding evaluation of } x_1, x_2, ldots, x_m \\text{)} end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["where the columns are indexed by all ",e.jsx(s,{children:"2^m"})," binary vectors, and row ",e.jsx(s,{children:"i"})," (for ",e.jsx(s,{children:"i \\geq 1"}),") contains the ",e.jsx(s,{children:"i"}),"-th coordinate of each indexing vector."]})]}),e.jsxs(d,{title:"First-Order Reed-Muller Code R(1,3)",children:[e.jsxs("p",{children:["For ",e.jsx(s,{children:"m = 3"}),", we have"," ",e.jsx(s,{children:"R(1, 3)"})," with parameters"," ",e.jsx(s,{children:"[8, 4, 4]"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Index the columns by ",e.jsx(s,{children:"(0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), (1,0,1), (1,1,0), (1,1,1)"}),"."]}),e.jsx(i,{children:`
          G = \begin\\{pmatrix\\} 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["This code has ",e.jsx(s,{children:"2^4 = 16"})," codewords: the 8 rows of a Hadamard matrix (in binary form) and their 8 complements."]})]}),e.jsx(n,{title:"Connection Between R(1,m) and Hadamard Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Consider the Sylvester-Hadamard matrix ",e.jsx(s,{children:"H_\\{2^m\\}"}),"of order ",e.jsx(s,{children:"2^m"}),". Converting to binary form with"," ",e.jsx(s,{children:"+1 \\mapsto 0"}),", ",e.jsx(s,{children:"-1 \\mapsto 1"}),", we obtain a matrix whose rows are precisely the codewords of"," ",e.jsx(s,{children:"R(1, m)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["This can be verified by noting that both constructions produce the same set of ",e.jsx(s,{children:"2^\\{m+1\\}"})," vectors: the rows of the binary Hadamard matrix and their complements coincide with the evaluations of all affine functions."]})]}),children:e.jsxs("p",{children:["The first-order Reed-Muller code ",e.jsx(s,{children:"R(1, m)"})," is identical to the Hadamard code of length ",e.jsx(s,{children:"2^m"})," derived from the Sylvester-Hadamard matrix."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Minimum Distance of Hadamard Codes"}),e.jsx(n,{title:"Minimum Distance",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["In a normalized Hadamard matrix ",e.jsx(s,{children:"H"})," of order"," ",e.jsx(s,{children:"n"}),", the first row is all ",e.jsx(s,{children:"+1"}),"'s, and every other row has exactly ",e.jsx(s,{children:"n/2"})," entries equal to"," ",e.jsx(s,{children:"+1"})," and ",e.jsx(s,{children:"n/2"})," equal to"," ",e.jsx(s,{children:"-1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["In binary form, the first row becomes the all-zeros vector (weight 0), and every other row has weight ",e.jsx(s,{children:"n/2"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The complement of the all-zeros vector is the all-ones vector (weight"," ",e.jsx(s,{children:"n"}),"), and the complement of a weight-",e.jsx(s,{children:"n/2"}),"vector also has weight ",e.jsx(s,{children:"n/2"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For two distinct rows ",e.jsx(s,{children:"i, j"})," (neither being the first row), their agreement/disagreement pattern shows that the Hamming distance between corresponding binary vectors is ",e.jsx(s,{children:"n/2"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The distance between a row and the complement of another row is also"," ",e.jsx(s,{children:"n/2"}),". Hence the minimum non-zero distance is"," ",e.jsx(s,{children:"n/2"}),"."]})]}),children:e.jsxs("p",{children:["The Hadamard code of length ",e.jsx(s,{children:"n"})," (derived from an"," ",e.jsx(s,{children:"n \\times n"})," Hadamard matrix) has minimum distance"," ",e.jsx(s,{children:"d = n/2"}),"."]})}),e.jsxs(t,{type:"info",title:"Parameters of Hadamard Codes",children:[e.jsxs("p",{children:["A Hadamard code derived from an ",e.jsx(s,{children:"n \\times n"})," Hadamard matrix has parameters:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Length: ",e.jsx(s,{children:"n"})]}),e.jsxs("li",{children:["Size: ",e.jsx(s,{children:"2n"})," codewords"]}),e.jsxs("li",{children:["Minimum distance: ",e.jsx(s,{children:"n/2"})]})]}),e.jsxs("p",{className:"mt-2",children:["For the Sylvester-Hadamard case (",e.jsx(s,{children:"n = 2^m"}),"), this gives a ",e.jsx(s,{children:"(2^m, 2^\\{m+1\\}, 2^\\{m-1\\})"})," code."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Relationship to Simplex Codes"}),e.jsxs(r,{title:"Simplex Code",children:[e.jsxs("p",{children:["The ",e.jsx("strong",{children:"simplex code"})," ",e.jsx(s,{children:"S(m)"})," is the dual of the Hamming code ",e.jsx(s,{children:"H(m)"}),". It is a"," ",e.jsx(s,{children:"[2^m - 1, m, 2^\\{m-1\\}]"})," code."]}),e.jsxs("p",{className:"mt-2",children:["Every non-zero codeword of the simplex code has weight exactly"," ",e.jsx(s,{children:"2^\\{m-1\\}"}),". The code is also called a"," ",e.jsx("strong",{children:"maximum-length sequence code"}),"."]})]}),e.jsxs(n,{title:"Relationship Between Simplex and Hadamard Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Consider ",e.jsx(s,{children:"R(1, m)"})," with its generator matrix"," ",e.jsx(s,{children:"G"})," having the all-ones row as the first row."]}),e.jsxs("p",{className:"mt-2",children:["Puncturing (removing) the first column from ",e.jsx(s,{children:"R(1, m)"}),"does not affect the dimension since the all-ones vector punctured at one position is still independent of the other generators."]}),e.jsxs("p",{className:"mt-2",children:["Deleting the all-ones generator row and puncturing the first column gives a code with parameters ",e.jsx(s,{children:"[2^m - 1, m]"}),". This is precisely the simplex code ",e.jsx(s,{children:"S(m)"}),"."]})]}),children:[e.jsxs("p",{children:["The simplex code ",e.jsx(s,{children:"S(m)"})," can be obtained from the first-order Reed-Muller code ",e.jsx(s,{children:"R(1, m)"})," by:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2",children:[e.jsx("li",{children:"Removing the all-ones row from the generator matrix"}),e.jsx("li",{children:"Puncturing one coordinate position"})]}),e.jsxs("p",{className:"mt-2",children:["Equivalently, ",e.jsx(s,{children:"S(m)"})," is the code obtained by taking all non-zero codewords of ",e.jsx(s,{children:"R(1, m)"})," that have a 0 in a fixed position, and then puncturing that position."]})]}),e.jsxs(d,{title:"Simplex Code S(3)",children:[e.jsxs("p",{children:["The simplex code ",e.jsx(s,{children:"S(3)"})," has parameters"," ",e.jsx(s,{children:"[7, 3, 4]"}),". Its generator matrix is:"]}),e.jsx(i,{children:`
          G = \begin\\{pmatrix\\} 0 & 0 & 0 & 1 & 1 & 1 & 1 \\ 0 & 1 & 1 & 0 & 0 & 1 & 1 \\ 1 & 0 & 1 & 0 & 1 & 0 & 1 end\\{pmatrix\\}
        `}),e.jsxs("p",{className:"mt-2",children:["The 7 non-zero codewords each have weight 4. Together with the zero codeword, this gives ",e.jsx(s,{children:"2^3 = 8"})," codewords total."]})]}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Non-Linear Hadamard Codes"}),e.jsxs(t,{type:"warning",title:"Linear vs Non-Linear",children:[e.jsxs("p",{children:["The Hadamard code derived from the Sylvester construction is linear (it is ",e.jsx(s,{children:"R(1, m)"}),"). However, Hadamard codes from other constructions (e.g., Paley) may not be linear."]}),e.jsxs("p",{className:"mt-2",children:["A Hadamard code is ",e.jsx("strong",{children:"non-linear"})," when it cannot be expressed as a vector subspace. In this case, it is specified by listing all codewords rather than by a generator matrix."]})]}),e.jsxs(r,{title:"General Hadamard Code",children:[e.jsxs("p",{children:["Given any Hadamard matrix ",e.jsx(s,{children:"H"})," of order"," ",e.jsx(s,{children:"n"}),", the ",e.jsx("strong",{children:"Hadamard code"})," ",e.jsx(s,{children:"\\mathcal{C}_H"})," consists of:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["The ",e.jsx(s,{children:"n"})," binary vectors obtained from the rows of ",e.jsx(s,{children:"H"})]}),e.jsxs("li",{children:["The ",e.jsx(s,{children:"n"})," complements of these vectors"]})]}),e.jsxs("p",{className:"mt-2",children:["This code has ",e.jsx(s,{children:"2n"})," codewords, length ",e.jsx(s,{children:"n"}),", and minimum distance ",e.jsx(s,{children:"n/2"}),", regardless of whether it is linear."]})]}),e.jsx(n,{title:"Optimality of Hadamard Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The Plotkin bound states that for a code of length ",e.jsx(s,{children:"n"}),"and minimum distance ",e.jsx(s,{children:"d {'>'} n/2"}),", the number of codewords ",e.jsx(s,{children:"M"})," satisfies:"]}),e.jsx(i,{children:"M leq \frac{'{2d}{2d - n}'}"}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{children:"d = n/2"}),", a refinement of the bound gives"," ",e.jsx(s,{children:"M \\leq 2n"})," when all codewords have even weight."]}),e.jsxs("p",{className:"mt-2",children:["A Hadamard code achieves exactly ",e.jsx(s,{children:"M = 2n"})," codewords with ",e.jsx(s,{children:"d = n/2"}),", meeting this bound with equality."]})]}),children:e.jsxs("p",{children:["Hadamard codes are optimal in the sense that they achieve the Plotkin bound. A code with length ",e.jsx(s,{children:"n"}),", ",e.jsx(s,{children:"2n"}),"codewords, and minimum distance ",e.jsx(s,{children:"n/2"})," meets the theoretical maximum."]})}),e.jsx("h2",{className:"text-2xl font-bold mt-8 mb-4",children:"Applications"}),e.jsxs(d,{title:"Mariner 9 Mission",children:[e.jsxs("p",{children:["The Hadamard code (specifically ",e.jsx(s,{children:"R(1, 5)"}),", a"," ",e.jsx(s,{children:"[32, 6, 16]"})," code) was used in the Mariner 9 mission to Mars in 1971-1972. The code was used for transmitting grayscale images back to Earth."]}),e.jsxs("p",{className:"mt-2",children:["Each pixel was encoded as one of 64 brightness levels (6 bits). The"," ",e.jsx(s,{children:"R(1, 5)"})," code expanded this to 32 bits, providing strong error correction for the noisy deep-space communication channel."]}),e.jsxs("p",{className:"mt-2",children:["The code can correct up to ",e.jsx(s,{children:"\\lfloor (16-1)/2 \\rfloor = 7"}),"errors per 32-bit block."]})]}),e.jsxs(t,{type:"success",title:"Key Properties Summary",children:[e.jsx("p",{children:"Hadamard codes possess several desirable properties:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"High rate of error correction:"})," Can correct nearly"," ",e.jsx(s,{children:"n/4"})," errors in a length-",e.jsx(s,{children:"n"})," code"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Simple decoding:"})," Fast Hadamard Transform enables efficient maximum-likelihood decoding"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Optimal:"})," Meet the Plotkin bound with equality"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Well-understood structure:"})," Deep connections to Reed-Muller codes and simplex codes"]})]})]}),e.jsxs(d,{title:"Weight Distribution",children:[e.jsxs("p",{children:["For a Hadamard code of length ",e.jsx(s,{children:"n = 2^m"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:"1 codeword of weight 0 (the zero vector)"}),e.jsxs("li",{children:[e.jsx(s,{children:"2^\\{m+1\\} - 2"})," codewords of weight ",e.jsx(s,{children:"2^\\{m-1\\}"})]}),e.jsxs("li",{children:["1 codeword of weight ",e.jsx(s,{children:"2^m"})," (the all-ones vector)"]})]}),e.jsxs("p",{className:"mt-2",children:["For example, with ",e.jsx(s,{children:"m = 3"})," (length 8):"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsx("li",{children:"1 codeword of weight 0"}),e.jsx("li",{children:"14 codewords of weight 4"}),e.jsx("li",{children:"1 codeword of weight 8"})]})]})]})}export{w as default};
