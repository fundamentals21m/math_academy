import{j as e}from"./vendor-animation-BtDNYRNB.js";import{L as i,T as m,E as t,C as h}from"./Callout-9bhk3xzT.js";import{I as a,M as s}from"./MathBlock-BPgtCiNw.js";import"./vendor-react-DamxDR2H.js";import"./index-Bqqh6CFH.js";import"./vendor-math-p018AHG0.js";import"./quizMap-MGF5DqnC.js";function j(){return e.jsxs(i,{sectionId:10,children:[e.jsx("h2",{children:"BCH Codes"}),e.jsxs("p",{children:["Hocquenghem (1959) and Bose and Ray-Chaudhuri (1960) independently proved a remarkable theorem which enables us to systematically construct one of the most powerful multiple error-correcting codes for random independent errors. These are polynomial codes called ",e.jsx("strong",{children:"Bose-Chaudhuri-Hocquenghem codes"}),"(BCH codes for short)."]}),e.jsx("h3",{children:"Construction of BCH Codes"}),e.jsx("p",{children:"A polynomial code is determined as soon as the generator polynomial is determined. The procedure for constructing a BCH code is as follows:"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"BCH Code Construction Procedure"}),e.jsxs("p",{children:["Suppose a BCH code with code word length ",e.jsx(a,{math:"n"}),", minimum distance ",e.jsx(a,{math:"d"}),", and symbols in ",e.jsx(a,{math:"F = GF(q)"})," is required."]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-2",children:[e.jsxs("li",{children:["Choose the least positive integer ",e.jsx(a,{math:"r"})," satisfying ",e.jsx(a,{math:"q^r \\\\geq n + 1"})]}),e.jsxs("li",{children:["Let ",e.jsx(a,{math:"K"})," be an extension of ",e.jsx(a,{math:"F"})," of degree ",e.jsx(a,{math:"r"})]}),e.jsxs("li",{children:["Let ",e.jsx(a,{math:"\\\\alpha"})," be a primitive element of ",e.jsx(a,{math:"K"})]}),e.jsxs("li",{children:["Let ",e.jsx(a,{math:"m_i(X)"})," be the minimal polynomial of ",e.jsx(a,{math:"\\\\alpha^i"}),", ",e.jsx(a,{math:"1 \\\\leq i \\\\leq d-1"})]}),e.jsxs("li",{children:["Set ",e.jsx(a,{math:"g(X) = \\\\text{LCM}(m_1(X), \\\\ldots, m_{d-1}(X))"})]})]})]}),e.jsxs(m,{title:"BCH Bound",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx(a,{math:"h(X)"})," be any polynomial over ",e.jsx(a,{math:"F"})," which has",e.jsx(a,{math:"\\\\alpha, \\\\alpha^2, \\\\ldots, \\\\alpha^{d-1}"})," among its roots. Then:"]}),e.jsx(s,{math:"m_i(X) \\\\mid h(X) \\\\quad \\\\forall i, \\\\, 1 \\\\leq i \\\\leq d-1"}),e.jsxs("p",{className:"mt-2",children:["and hence ",e.jsx(a,{math:"g(X) \\\\mid h(X)"}),". Thus ",e.jsx(a,{math:"g(X)"})," is the polynomial of least possible degree (up to a constant factor) with roots ",e.jsx(a,{math:"\\\\alpha, \\\\alpha^2, \\\\ldots, \\\\alpha^{d-1}"}),"."]}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(a,{math:"c(X)"})," is a code polynomial in the polynomial code generated by ",e.jsx(a,{math:"g(X)"}),", then",e.jsx(a,{math:"c(X) = a(X)g(X)"})," for some ",e.jsx(a,{math:"a(X) \\\\in F[X]"}),", so ",e.jsx(a,{math:"\\\\alpha, \\\\alpha^2, \\\\ldots, \\\\alpha^{d-1}"})," are roots of ",e.jsx(a,{math:"c(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Suppose a code word has less than ",e.jsx(a,{math:"d"})," non-zero entries. Then the corresponding code polynomial is of the form:"]}),e.jsx(s,{math:"c(X) = b_1 X^{n_1} + b_2 X^{n_2} + \\\\cdots + b_{d-1} X^{n_{d-1}}"}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(a,{math:"b_1, \\\\ldots, b_{d-1} \\\\in F"})," and ",e.jsx(a,{math:"n_1 > n_2 > \\\\cdots > n_{d-1} \\\\geq 0"}),". Since ",e.jsx(a,{math:"\\\\alpha, \\\\alpha^2, \\\\ldots, \\\\alpha^{d-1}"})," are roots of ",e.jsx(a,{math:"c(X)"}),":"]}),e.jsx(s,{math:"\\\\mathbf{A} \\\\begin{pmatrix} b_1 \\\\\\\\ b_2 \\\\\\\\ \\\\vdots \\\\\\\\ b_{d-1} \\\\end{pmatrix} = 0"}),e.jsx("p",{className:"mt-2",children:"where:"}),e.jsx(s,{math:"\\\\mathbf{A} = \\\\begin{pmatrix} \\\\alpha^{n_1} & \\\\alpha^{n_2} & \\\\cdots & \\\\alpha^{n_{d-1}} \\\\\\\\ \\\\alpha^{2n_1} & \\\\alpha^{2n_2} & \\\\cdots & \\\\alpha^{2n_{d-1}} \\\\\\\\ \\\\vdots & \\\\vdots & \\\\ddots & \\\\vdots \\\\\\\\ \\\\alpha^{(d-1)n_1} & \\\\alpha^{(d-1)n_2} & \\\\cdots & \\\\alpha^{(d-1)n_{d-1}} \\\\end{pmatrix}"}),e.jsxs("p",{className:"mt-2",children:["The determinant of ",e.jsx(a,{math:"\\\\mathbf{A}"})," is a Vandermonde determinant:"]}),e.jsx(s,{math:"\\\\det \\\\mathbf{A} = \\\\prod_{i > j} (\\\\alpha^{n_i} - \\\\alpha^{n_j})"}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(a,{math:"\\\\alpha"})," is primitive and ",e.jsx(a,{math:"q^r - 1 > n_1 > \\\\cdots > n_{d-1} \\\\geq 0"}),", we have ",e.jsx(a,{math:"\\\\alpha^{n_i} - \\\\alpha^{n_j} \\\\neq 0"})," for ",e.jsx(a,{math:"i \\\\neq j"}),". Therefore ",e.jsx(a,{math:"\\\\det \\\\mathbf{A} \\\\neq 0"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The system admits only the zero solution, so ",e.jsx(a,{math:"c(X) = 0"}),". Hence there is no non-zero code word with less than ",e.jsx(a,{math:"d"})," non-zero entries."]})]}),children:["The polynomial code with symbols in ",e.jsx(a,{math:"F"})," and encoding polynomial ",e.jsx(a,{math:"g(X)"})," has minimum distance at least ",e.jsx(a,{math:"d"}),"."]}),e.jsx("h3",{children:"Examples of BCH Code Construction"}),e.jsxs(t,{title:"Binary BCH Code of Length 7, Distance 3",children:[e.jsxs("p",{children:["Here ",e.jsx(a,{math:"n = 7"})," so we need an extension of ",e.jsx(a,{math:"\\\\mathbb{B}"})," of degree ",e.jsx(a,{math:"r"})," where",e.jsx(a,{math:"2^r \\\\geq 8"}),". Thus ",e.jsx(a,{math:"r = 3"}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx(a,{math:"X^3 + X + 1"})," is a primitive polynomial of degree 3 over ",e.jsx(a,{math:"\\\\mathbb{B}"}),". Therefore ",e.jsx(a,{math:"K = \\\\mathbb{B}[X]/\\\\langle X^3 + X + 1 \\\\rangle"})," is a field of order 8 and",e.jsx(a,{math:"\\\\alpha = X + \\\\langle X^3 + X + 1 \\\\rangle"})," is a primitive element."]}),e.jsxs("p",{className:"mt-2",children:["Then ",e.jsx(a,{math:"\\\\alpha^3 + \\\\alpha + 1 = 0"})," and ",e.jsx(a,{math:"\\\\alpha^7 = 1"}),". The minimal polynomial of ",e.jsx(a,{math:"\\\\alpha"})," is ",e.jsx(a,{math:"X^3 + X + 1"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(a,{math:"\\\\alpha"})," and ",e.jsx(a,{math:"\\\\alpha^2"})," have the same minimal polynomial, the generator polynomial of the required BCH code is:"]}),e.jsx(s,{math:"g(X) = X^3 + X + 1"}),e.jsx("p",{className:"mt-2",children:"The encoding polynomial has 3 non-zero terms, so the minimum distance is exactly 3."})]}),e.jsxs(t,{title:"Binary BCH Code of Length 15, Distance 5",children:[e.jsxs("p",{children:["Here ",e.jsx(a,{math:"n = 15 \\\\leq 2^4 - 1"})," so we need an extension ",e.jsx(a,{math:"K"})," of",e.jsx(a,{math:"\\\\mathbb{B}"})," of degree 4."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx(a,{math:"X^4 + X + 1"})," is a primitive polynomial, so ",e.jsx(a,{math:"\\\\alpha = X + \\\\langle X^4 + X + 1 \\\\rangle"})," is a primitive element of ",e.jsx(a,{math:"K = \\\\mathbb{B}[X]/\\\\langle X^4 + X + 1 \\\\rangle"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The minimal polynomial of ",e.jsx(a,{math:"\\\\alpha"})," is ",e.jsx(a,{math:"m_1(X) = X^4 + X + 1"}),". Also",e.jsx(a,{math:"m_2(X) = m_4(X) = m_1(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(a,{math:"m_3(X)"}),": the elements ",e.jsx(a,{math:"\\\\alpha^3, \\\\alpha^6, \\\\alpha^{12}, \\\\alpha^9"})," have the same minimal polynomial:"]}),e.jsx(s,{math:"m_3(X) = (X - \\\\alpha^3)(X - \\\\alpha^6)(X - \\\\alpha^9)(X - \\\\alpha^{12})"}),e.jsx("p",{className:"mt-2",children:"Computing:"}),e.jsx(s,{math:"m_3(X) = X^4 + X^3 + X^2 + X + 1"}),e.jsx("p",{className:"mt-2",children:"Therefore, the encoding polynomial is:"}),e.jsx(s,{math:"g(X) = (X^4 + X + 1)(X^4 + X^3 + X^2 + X + 1) = X^8 + X^7 + X^6 + X^4 + 1"}),e.jsx("p",{className:"mt-2",children:"Since the encoding polynomial has 5 non-zero terms, the minimum distance is exactly 5."})]}),e.jsxs(t,{title:"Binary BCH Code of Length 31, Distance 5",children:[e.jsxs("p",{children:["Given that ",e.jsx(a,{math:"X^5 + X^2 + 1"})," is irreducible over ",e.jsx(a,{math:"\\\\mathbb{B}"}),":"]}),e.jsx(s,{math:"F = \\\\mathbb{B}[X]/\\\\langle X^5 + X^2 + 1 \\\\rangle"}),e.jsxs("p",{className:"mt-2",children:["is a field of order 32. Since ",e.jsx(a,{math:"F^*"})," is cyclic of order 31 (prime), every non-identity element is primitive. Let ",e.jsx(a,{math:"\\\\alpha = X + \\\\langle X^5 + X^2 + 1 \\\\rangle"}),"."]}),e.jsxs("p",{className:"mt-2",children:["The minimal polynomial of ",e.jsx(a,{math:"\\\\alpha"})," is ",e.jsx(a,{math:"m_1(X) = X^5 + X^2 + 1"}),". Note that ",e.jsx(a,{math:"m_1(X) = m_2(X) = m_4(X)"}),"."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(a,{math:"m_3(X)"}),": the elements ",e.jsx(a,{math:"\\\\alpha^3, \\\\alpha^6, \\\\alpha^{12}, \\\\alpha^{24}, \\\\alpha^{17}"})," share the same minimal polynomial (since ",e.jsx(a,{math:"\\\\{3, 6, 12, 24, 17\\\\}"})," is a cyclotomic class mod 31)."]}),e.jsx("p",{className:"mt-2",children:"Computing coefficients:"}),e.jsx(s,{math:"m_3(X) = X^5 + X^4 + X^3 + X^2 + 1"}),e.jsx("p",{className:"mt-2",children:"Therefore:"}),e.jsx(s,{math:"g(X) = m_1(X) \\\\cdot m_3(X) = (X^5 + X^2 + 1)(X^5 + X^4 + X^3 + X^2 + 1)"}),e.jsx(s,{math:"= X^{10} + X^9 + X^8 + X^6 + X^5 + X^3 + 1"})]}),e.jsxs(t,{title:"5-Error-Correcting BCH Code of Length 63",children:[e.jsxs("p",{children:["Given ",e.jsx(a,{math:"X^6 + X + 1"})," is primitive over ",e.jsx(a,{math:"\\\\mathbb{B}"}),":"]}),e.jsx(s,{math:"K = \\\\mathbb{B}[X]/\\\\langle X^6 + X + 1 \\\\rangle"}),e.jsxs("p",{className:"mt-2",children:["is a field of order 64, and ",e.jsx(a,{math:"\\\\alpha = X + \\\\langle X^6 + X + 1 \\\\rangle"})," is primitive."]}),e.jsxs("p",{className:"mt-2",children:["For a 5-error-correcting code, minimum distance is at least ",e.jsx(a,{math:"2 \\\\times 5 + 1 = 11"}),". We need minimal polynomials ",e.jsx(a,{math:"m_i(X)"})," of ",e.jsx(a,{math:"\\\\alpha^i"})," for ",e.jsx(a,{math:"1 \\\\leq i \\\\leq 10"}),"."]}),e.jsx("p",{className:"mt-2",children:"Using cyclotomic classes:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:e.jsx(a,{math:"m_1(X) = m_2(X) = m_4(X) = m_8(X) = m_{16}(X) = m_{32}(X) = X^6 + X + 1"})}),e.jsx("li",{children:e.jsx(a,{math:"m_3(X) = m_6(X) = m_{12}(X) = m_{24}(X) = m_{48}(X) = m_{33}(X)"})}),e.jsx("li",{children:e.jsx(a,{math:"m_5(X) = m_{10}(X) = m_{20}(X) = m_{40}(X) = m_{17}(X) = m_{34}(X)"})}),e.jsx("li",{children:e.jsx(a,{math:"m_7(X) = m_{14}(X) = m_{28}(X) = m_{56}(X) = m_{49}(X) = m_{35}(X)"})}),e.jsx("li",{children:e.jsx(a,{math:"m_9(X) = m_{18}(X) = m_{36}(X)"})})]}),e.jsx("p",{className:"mt-2",children:"Computing these minimal polynomials (degree 6 for the first four, degree 3 for the last):"}),e.jsx(s,{math:"m_3(X) = X^6 + X^4 + X^3 + X^2 + X + 1"}),e.jsx(s,{math:"m_5(X) = X^6 + X^5 + X^2 + X + 1"}),e.jsx(s,{math:"m_7(X) = X^6 + X^3 + 1"}),e.jsx(s,{math:"m_9(X) = X^3 + X^2 + 1"}),e.jsx("p",{className:"mt-2",children:"The generator polynomial is:"}),e.jsx(s,{math:"g(X) = m_1(X) \\\\cdot m_3(X) \\\\cdot m_5(X) \\\\cdot m_7(X) \\\\cdot m_9(X)"}),e.jsx("p",{className:"mt-2",children:"which has degree 27."})]}),e.jsx("h3",{children:"Bound on Check Digits"}),e.jsxs(m,{title:"Check Digit Bound for Binary BCH Codes",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["The code is of length ",e.jsx(a,{math:"n = 2^m - 1"}),". We construct an extension ",e.jsx(a,{math:"K"})," of",e.jsx(a,{math:"\\\\mathbb{B}"})," of degree ",e.jsx(a,{math:"m"})," and let ",e.jsx(a,{math:"\\\\alpha"})," be a primitive element."]}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(a,{math:"[K:\\\\mathbb{B}] = m"})," is finite, every element of ",e.jsx(a,{math:"K"})," is algebraic over",e.jsx(a,{math:"\\\\mathbb{B}"}),". If ",e.jsx(a,{math:"\\\\beta \\\\in K"}),", then ",e.jsx(a,{math:"\\\\mathbb{B}(\\\\beta)"})," is a subfield of ",e.jsx(a,{math:"K"})," and:"]}),e.jsx(s,{math:"[K:\\\\mathbb{B}] = [K:\\\\mathbb{B}(\\\\beta)][\\\\mathbb{B}(\\\\beta):\\\\mathbb{B}]"}),e.jsxs("p",{className:"mt-2",children:["shows that ",e.jsx(a,{math:"[\\\\mathbb{B}(\\\\beta):\\\\mathbb{B}] \\\\leq m"}),". Thus the degree of the minimal polynomial of ",e.jsx(a,{math:"\\\\beta"})," is at most ",e.jsx(a,{math:"m"}),"."]}),e.jsxs("p",{className:"mt-2",children:["We prove by induction on ",e.jsx(a,{math:"t"})," that ",e.jsx(a,{math:"\\\\deg g(X) \\\\leq mt"}),". For ",e.jsx(a,{math:"t = 1"}),": ",e.jsx(a,{math:"g(X) = \\\\text{LCM}\\\\{m_1(X), m_2(X)\\\\} = m_1(X)"}),"since ",e.jsx(a,{math:"\\\\alpha"})," and ",e.jsx(a,{math:"\\\\alpha^2"})," have the same minimal polynomial."]}),e.jsxs("p",{className:"mt-2",children:["Suppose the claim holds for ",e.jsx(a,{math:"t"}),". Let:"]}),e.jsx(s,{math:"g_1(X) = \\\\text{LCM}\\\\{m_1(X), \\\\ldots, m_{2t}(X), m_{2t+1}(X), m_{2t+2}(X)\\\\}"}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(a,{math:"m_{2t+2}(X) = m_{t+1}(X)"}),":"]}),e.jsx(s,{math:"g_1(X) = \\\\text{LCM}\\\\{g(X), m_{2t+1}(X)\\\\}"}),e.jsx("p",{className:"mt-2",children:"Then:"}),e.jsx(s,{math:"\\\\deg g_1(X) \\\\leq \\\\deg g(X) + \\\\deg m_{2t+1}(X) \\\\leq mt + m = m(t+1)"})]}),children:["A binary BCH code with code word length ",e.jsx(a,{math:"n = 2^m - 1"})," and minimum distance at least ",e.jsx(a,{math:"d = 2t + 1"})," can always be constructed with check digits at most ",e.jsx(a,{math:"mt"}),"."]}),e.jsxs(h,{type:"info",children:[e.jsx("strong",{children:"Remark:"})," If ",e.jsx(a,{math:"g(X)"})," is the generating polynomial of the binary BCH code with minimum distance at least ",e.jsx(a,{math:"2t"}),", then:",e.jsx(s,{math:"g(X) = \\\\text{LCM}\\\\{m_1(X), \\\\ldots, m_{2t-1}(X)\\\\} = \\\\text{LCM}\\\\{m_1(X), \\\\ldots, m_{2t}(X)\\\\}"}),"Therefore, ",e.jsx(a,{math:"g(X)"})," is also the generating polynomial of a BCH code with minimum distance at least ",e.jsx(a,{math:"2t + 1"}),"."]}),e.jsxs(m,{title:"General Check Digit Bound",proof:e.jsx(e.Fragment,{children:e.jsxs("p",{children:["The proof follows exactly the same lines as the binary case, with ",e.jsx(a,{math:"p"})," replacing 2. The key observation is that ",e.jsx(a,{math:"\\\\alpha"})," and ",e.jsx(a,{math:"\\\\alpha^p"})," share the same minimal polynomial over the prime subfield."]})}),children:["A BCH code over ",e.jsx(a,{math:"GF(p)"})," with code word length ",e.jsx(a,{math:"n = p^m - 1"})," and minimum distance at least ",e.jsx(a,{math:"pt + 1"})," can always be constructed with at most ",e.jsx(a,{math:"(p-1)mt"})," check digits."]}),e.jsx("h3",{children:"Non-Binary BCH Codes"}),e.jsxs(t,{title:"2-Error-Correcting BCH Code over GF(3)",children:[e.jsxs("p",{children:["For a code of length ",e.jsx(a,{math:"8 = 3^2 - 1"})," over ",e.jsx(a,{math:"GF(3)"}),", we construct an extension of degree 2."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx(a,{math:"X^2 + X + 2"})," is primitive over ",e.jsx(a,{math:"F_3"}),". Let",e.jsx(a,{math:"K = F_3[X]/\\\\langle X^2 + X + 2 \\\\rangle"})," and",e.jsx(a,{math:"\\\\alpha = X + \\\\langle X^2 + X + 2 \\\\rangle"}),"."]}),e.jsxs("p",{className:"mt-2",children:["Minimum distance is at least ",e.jsx(a,{math:"2 \\\\times 2 + 1 = 5"}),". We need",e.jsx(a,{math:"m_i(X)"})," for ",e.jsx(a,{math:"1 \\\\leq i \\\\leq 4"}),"."]}),e.jsxs("p",{className:"mt-2",children:["By the theory, ",e.jsx(a,{math:"m_1(X) = m_3(X)"})," and ",e.jsx(a,{math:"m_2(X) = m_6(X)"}),"."]}),e.jsx(s,{math:"m_2(X) = (X - \\\\alpha^2)(X - \\\\alpha^6) = X^2 + 1"}),e.jsx(s,{math:"m_4(X) = X - \\\\alpha^4 = X + 1"}),e.jsx("p",{className:"mt-2",children:"The generator polynomial is:"}),e.jsx(s,{math:"g(X) = m_1(X) \\\\cdot m_2(X) \\\\cdot m_4(X) = (X^2 + X + 2)(X^2 + 1)(X + 1)"}),e.jsx(s,{math:"= X^5 + 2X^4 + X^3 + X^2 + 2"}),e.jsx("p",{className:"mt-2",children:"Since the generator polynomial has 5 non-zero terms, the minimum distance is exactly 5."})]}),e.jsxs(h,{type:"success",children:[e.jsx("strong",{children:"Summary:"})," BCH codes provide a powerful systematic method for constructing codes with guaranteed minimum distance. The key ingredients are:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"Finite field extensions and primitive elements"}),e.jsx("li",{children:"Minimal polynomials and cyclotomic classes"}),e.jsx("li",{children:"The Vandermonde determinant argument for the BCH bound"})]})]})]})}export{j as default};
