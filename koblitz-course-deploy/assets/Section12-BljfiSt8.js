import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as r,D as i,C as n,E as o,T as t}from"./Callout-DzP_hyKf.js";import{M as s}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-BWUjVAcL.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CQDzgGif.js";function u(){return e.jsxs(r,{sectionId:12,children:[e.jsx("h2",{children:"Zero-Knowledge Proofs"}),e.jsx("p",{children:"Zero-knowledge proofs allow one party (the prover) to convince another party (the verifier) that a statement is true, without revealing anything beyond the truth of the statement. This remarkable concept has profound applications in cryptography."}),e.jsx("h3",{children:"The Concept of Zero-Knowledge"}),e.jsxs(i,{title:"Interactive Proof",children:["An ",e.jsx("strong",{children:"interactive proof system"})," for a language ",e.jsx("em",{children:"L"})," consists of:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["A prover ",e.jsx("em",{children:"P"})," (computationally unbounded)"]}),e.jsxs("li",{children:["A verifier ",e.jsx("em",{children:"V"})," (polynomial-time)"]}),e.jsx("li",{children:"Multiple rounds of interaction"}),e.jsxs("li",{children:[e.jsx("strong",{children:"Completeness:"})," If ",e.jsx(s,{math:"x \\in L",inline:!0}),", honest prover convinces verifier"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Soundness:"})," If ",e.jsx(s,{math:"x \\notin L",inline:!0}),", no prover can convince verifier (except with negligible probability)"]})]})]}),e.jsxs(i,{title:"Zero-Knowledge",children:["An interactive proof is ",e.jsx("strong",{children:"zero-knowledge"})," if the verifier learns nothing beyond the validity of the statement. Formally, there exists a simulator that can produce transcripts indistinguishable from real interactions."]}),e.jsx("h3",{children:"The Cave Analogy"}),e.jsx("p",{children:"Imagine a cave with a forking path that reconnects at the back. A magic door blocks the connection, openable only with a secret word."}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Ali Baba's Cave"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 text-dark-300",children:[e.jsx("li",{children:"Prover (Peggy) enters cave, chooses random path (A or B)"}),e.jsx("li",{children:"Verifier (Victor) waits outside, doesn't see which path"}),e.jsx("li",{children:"Victor calls out a random path for Peggy to exit from"}),e.jsx("li",{children:"Peggy exits from requested path (using secret word if needed)"}),e.jsx("li",{children:"Repeat many times; if Peggy always succeeds, she likely knows the secret"})]})]}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Zero-Knowledge Property:"})," A video of this protocol proves nothing to third parties - it could be faked by having Victor and Peggy conspire to match paths. Yet it convinces Victor who chooses randomly."]}),e.jsx("h3",{children:"Schnorr Identification Protocol"}),e.jsxs(i,{title:"Schnorr Protocol",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Setup:"})," Group ",e.jsx("em",{children:"G"})," of prime order ",e.jsx("em",{children:"q"}),", generator ",e.jsx("em",{children:"g"}),". Prover has secret ",e.jsx("em",{children:"x"}),", public key ",e.jsx(s,{math:"y = g^x",inline:!0}),"."]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Commitment:"})," Prover chooses random ",e.jsx("em",{children:"r"}),", sends ",e.jsx(s,{math:"R = g^r",inline:!0})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Challenge:"})," Verifier sends random ",e.jsx(s,{math:"c \\in \\{0, 1, \\ldots, 2^t-1\\}",inline:!0})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Response:"})," Prover sends ",e.jsx(s,{math:"s = r + cx \\bmod q",inline:!0})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Verify:"})," Check that ",e.jsx(s,{math:"g^s = R \\cdot y^c",inline:!0})]})]})]}),e.jsxs(o,{title:"Schnorr Protocol Execution",children:[e.jsxs("p",{children:["Let ",e.jsx(s,{math:"g = 2, q = 11, x = 7",inline:!0}),". Public: ",e.jsx(s,{math:"y = 2^7 \\bmod 11 = 7",inline:!0})]}),e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Round:"})}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Prover: ",e.jsx(s,{math:"r = 4",inline:!0}),", ",e.jsx(s,{math:"R = 2^4 \\bmod 11 = 5",inline:!0})]}),e.jsxs("li",{children:["Verifier: ",e.jsx(s,{math:"c = 3",inline:!0})]}),e.jsxs("li",{children:["Prover: ",e.jsx(s,{math:"s = 4 + 3 \\cdot 7 = 25 \\equiv 3 \\pmod{11}",inline:!0})]}),e.jsxs("li",{children:["Verify: ",e.jsx(s,{math:"2^3 = 8",inline:!0})," and ",e.jsx(s,{math:"5 \\cdot 7^3 = 5 \\cdot 2 = 10 \\equiv 8",inline:!0})," ✓"]})]})]}),e.jsxs(t,{title:"Schnorr Security",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Completeness:"})," If the prover knows ",e.jsx("em",{children:"x"})," and follows the protocol honestly:"]}),e.jsx(s,{math:"g^s = g^{r + cx} = g^r \\cdot g^{cx} = g^r \\cdot (g^x)^c = R \\cdot y^c"}),e.jsxs("p",{children:["The verification equation ",e.jsx(s,{math:"g^s = R \\cdot y^c",inline:!0})," holds with probability 1."]}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Soundness:"})," We show a cheating prover succeeds with probability at most ",e.jsx(s,{math:"1/2^t",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["Suppose a cheater can answer two different challenges ",e.jsx(s,{math:"c",inline:!0})," and ",e.jsx(s,{math:"c'",inline:!0})," for the same commitment ",e.jsx("em",{children:"R"})," with responses ",e.jsx("em",{children:"s"})," and ",e.jsx(s,{math:"s'",inline:!0}),". Then:"]}),e.jsx(s,{math:"g^s = R \\cdot y^c \\quad \\text{and} \\quad g^{s'} = R \\cdot y^{c'}"}),e.jsx("p",{children:"Dividing these equations:"}),e.jsx(s,{math:"g^{s - s'} = y^{c - c'} = g^{x(c - c')}"}),e.jsxs("p",{children:["Therefore ",e.jsx(s,{math:"s - s' \\equiv x(c - c') \\pmod{q}",inline:!0}),", giving:"]}),e.jsx(s,{math:"x = (s - s')(c - c')^{-1} \\bmod q"}),e.jsxs("p",{children:["This extracts the secret key! By contrapositive, a prover who doesn't know ",e.jsx("em",{children:"x"})," can answer at most one challenge per commitment. Since challenges are chosen uniformly from ",e.jsx(s,{math:"\\{0, 1, \\ldots, 2^t - 1\\}",inline:!0}),", the probability of guessing correctly is ",e.jsx(s,{math:"1/2^t",inline:!0}),"."]}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Zero-Knowledge:"})," We construct a simulator that produces transcripts indistinguishable from real ones:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Choose random ",e.jsx(s,{math:"c \\in \\{0, \\ldots, 2^t - 1\\}",inline:!0})," and random ",e.jsx(s,{math:"s \\in \\mathbb{Z}_q",inline:!0})]}),e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"R = g^s \\cdot y^{-c}",inline:!0})]}),e.jsxs("li",{children:["Output transcript ",e.jsx(s,{math:"(R, c, s)",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:["Verification: ",e.jsx(s,{math:"g^s = g^s \\cdot y^{-c} \\cdot y^c = R \\cdot y^c",inline:!0})," holds by construction."]}),e.jsxs("p",{className:"mt-2",children:["In a real transcript, ",e.jsx("em",{children:"R"})," is uniform (since ",e.jsx(s,{math:"r",inline:!0})," is random), ",e.jsx("em",{children:"c"})," is uniform (chosen by verifier), and ",e.jsx("em",{children:"s"})," is uniform in ",e.jsx(s,{math:"\\mathbb{Z}_q",inline:!0})," (since ",e.jsx(s,{math:"r",inline:!0})," is). The simulated transcript has identical distribution: ",e.jsx("em",{children:"c"})," and ",e.jsx("em",{children:"s"})," are uniform by construction, and ",e.jsx("em",{children:"R"})," is uniform because ",e.jsx(s,{math:"g^s y^{-c}",inline:!0})," with uniform ",e.jsx("em",{children:"s"})," is uniform."]})]}),children:["The Schnorr protocol satisfies:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Completeness:"})," Honest prover always convinces verifier"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Soundness:"})," Cheater succeeds with probability ",e.jsx(s,{math:"1/2^t",inline:!0})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Zero-knowledge:"})," Simulator can fake transcripts (choose ",e.jsx("em",{children:"c, s"})," first, compute ",e.jsx(s,{math:"R = g^s y^{-c}",inline:!0}),")"]})]})]}),e.jsx("h3",{children:"Zero-Knowledge Proofs for NP"}),e.jsx(t,{title:"ZK for All of NP (GMW, 1986)",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"The proof proceeds in two steps: (1) construct a ZK proof for graph 3-coloring, and (2) use NP-completeness to extend to all of NP."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 1: ZK Proof for 3-Coloring"})}),e.jsxs("p",{className:"mt-2",children:["Given a graph ",e.jsx(s,{math:"G = (V, E)",inline:!0})," and a valid 3-coloring ",e.jsx(s,{math:"\\chi: V \\to \\{1, 2, 3\\}",inline:!0}),":"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Commitment:"})," Prover randomly permutes the 3 colors (applying ",e.jsx(s,{math:"\\pi",inline:!0})," to ",e.jsx(s,{math:"\\chi",inline:!0}),"), then commits to each vertex's new color using a hiding commitment scheme."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Challenge:"})," Verifier selects a random edge ",e.jsx(s,{math:"(u, v) \\in E",inline:!0}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Response:"})," Prover opens the commitments for vertices ",e.jsx("em",{children:"u"})," and ",e.jsx("em",{children:"v"}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Verify:"})," Verifier checks that the two colors are different."]})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Analysis:"})}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Completeness:"})," Valid coloring means adjacent vertices have different colors, so honest prover always passes."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Soundness:"})," If the graph is not 3-colorable, at least one edge has endpoints of the same color. Probability of catching this is ",e.jsx(s,{math:"\\geq 1/|E|",inline:!0}),". After ",e.jsx(s,{math:"k \\cdot |E|",inline:!0})," rounds, cheater's success probability is at most ",e.jsx(s,{math:"(1 - 1/|E|)^{k|E|} \\approx e^{-k}",inline:!0}),"."]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Zero-knowledge:"})," The random permutation ensures each revealed pair is a uniformly random pair of distinct colors from ",e.jsx(s,{math:"\\{1,2,3\\}",inline:!0}),". A simulator can produce this distribution without knowing the coloring: for the challenged edge, output two random distinct colors with valid commitments."]})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 2: Extension to all of NP"})}),e.jsxs("p",{className:"mt-2",children:["Since 3-coloring is NP-complete, any NP language ",e.jsx("em",{children:"L"})," has a polynomial-time reduction to 3-coloring. Given instance ",e.jsx("em",{children:"x"})," and witness ",e.jsx("em",{children:"w"})," for ",e.jsx(s,{math:"x \\in L",inline:!0}),":"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Compute the reduction: ",e.jsx(s,{math:"(G, \\chi) = \\text{Reduce}(x, w)",inline:!0})]}),e.jsxs("li",{children:["Run the 3-coloring ZK proof on ",e.jsx(s,{math:"(G, \\chi)",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:["The reduction preserves zero-knowledge: the verifier only sees the graph ",e.jsx("em",{children:"G"})," (which is computable from ",e.jsx("em",{children:"x"})," alone) and the ZK proof reveals nothing about ",e.jsx(s,{math:"\\chi",inline:!0}),", hence nothing about ",e.jsx("em",{children:"w"}),"."]}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Note:"})," This construction requires a commitment scheme, which in turn requires one-way functions."]})]}),children:"Every problem in NP has a zero-knowledge proof system (assuming one-way functions exist). This is shown by giving a ZK proof for graph 3-coloring, which is NP-complete."}),e.jsx("h3",{children:"Non-Interactive Zero-Knowledge (NIZK)"}),e.jsxs(i,{title:"Fiat-Shamir Transform",children:["Convert an interactive ZK proof to non-interactive using a hash function ",e.jsx("em",{children:"H"}),":",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Compute commitment ",e.jsx("em",{children:"R"})," as usual"]}),e.jsxs("li",{children:["Set challenge ",e.jsx(s,{math:"c = H(g, y, R)",inline:!0})," (no interaction needed)"]}),e.jsxs("li",{children:["Compute response ",e.jsx("em",{children:"s"})]}),e.jsxs("li",{children:["Proof is ",e.jsx(s,{math:"(R, s)",inline:!0})," or just ",e.jsx(s,{math:"(c, s)",inline:!0})]})]})]}),e.jsxs("p",{children:["The Fiat-Shamir transform converts Schnorr identification into the Schnorr signature scheme: sign message ",e.jsx("em",{children:"M"})," by including it in the hash: ",e.jsx(s,{math:"c = H(R, M)",inline:!0}),"."]}),e.jsx("h3",{children:"Applications"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Modern Applications"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Authentication:"})," Prove identity without revealing password"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"E-voting:"})," Prove vote validity without revealing choice"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Blockchain:"})," zk-SNARKs for private transactions (Zcash)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Credentials:"})," Prove age > 18 without revealing birthdate"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"zkRollups:"})," Scalable blockchain computation verification"]})]})]}),e.jsx("h3",{children:"zk-SNARKs"}),e.jsxs(i,{title:"zk-SNARK",children:[e.jsx("strong",{children:"Zero-Knowledge Succinct Non-interactive ARgument of Knowledge:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Zero-knowledge:"})," Reveals nothing beyond statement truth"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Succinct:"})," Proof size is constant (a few hundred bytes)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Non-interactive:"})," Single message from prover to verifier"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Argument:"})," Computationally sound (vs. statistically)"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"of Knowledge:"}),' Prover must "know" the witness']})]})]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"Revolutionary Impact:"})," zk-SNARKs allow verification of arbitrary computation in constant time. A verifier can check that a program was executed correctly without re-running it - even for programs that take hours to run."]}),e.jsx("h3",{children:"Oblivious Transfer"}),e.jsxs(i,{title:"1-out-of-2 Oblivious Transfer",children:["Alice has two messages ",e.jsx(s,{math:"m_0, m_1",inline:!0}),". Bob wants ",e.jsx(s,{math:"m_b",inline:!0})," ","for some choice bit ",e.jsx("em",{children:"b"}),". The protocol ensures:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Bob receives ",e.jsx(s,{math:"m_b",inline:!0})," but learns nothing about ",e.jsx(s,{math:"m_{1-b}",inline:!0})]}),e.jsx("li",{children:"Alice doesn't learn which message Bob chose"})]})]}),e.jsx(t,{title:"OT Sufficiency",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We sketch the proof that OT suffices for secure two-party computation of any function ",e.jsx(s,{math:"f(x, y)",inline:!0}),"."]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 1: Boolean circuit representation"})}),e.jsxs("p",{className:"mt-2",children:["Any efficiently computable function can be expressed as a Boolean circuit with AND and XOR gates. Convert ",e.jsx("em",{children:"f"})," to such a circuit ",e.jsx("em",{children:"C"}),"."]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 2: Garbled circuits (Yao's protocol)"})}),e.jsxs("p",{className:"mt-2",children:["Party A (the garbler) creates an encrypted version of ",e.jsx("em",{children:"C"}),":"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["For each wire ",e.jsx("em",{children:"w"}),", choose two random keys ",e.jsx(s,{math:"k_w^0, k_w^1",inline:!0})," representing values 0 and 1"]}),e.jsx("li",{children:"For each gate, create a garbled gate table that encrypts the output wire keys under the corresponding input wire keys"})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 3: Input wire keys via OT"})}),e.jsx("p",{className:"mt-2",children:"A sends their garbled circuit and keys for their own input wires to B."}),e.jsxs("p",{className:"mt-2",children:["For B's input wires, they use OT: for each input bit ",e.jsx(s,{math:"b_i",inline:!0})," of B:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["A offers both keys ",e.jsx(s,{math:"(k_{w_i}^0, k_{w_i}^1)",inline:!0})]}),e.jsxs("li",{children:["B selects ",e.jsx(s,{math:"k_{w_i}^{b_i}",inline:!0})," without A learning ",e.jsx(s,{math:"b_i",inline:!0})]}),e.jsx("li",{children:"B receives exactly one key per wire without learning the other"})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Step 4: Evaluation"})}),e.jsx("p",{className:"mt-2",children:"B evaluates the garbled circuit gate-by-gate, decrypting each gate table with the known wire keys, obtaining the output."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Security:"})}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"A learns nothing about B's input (OT hides B's choice)"}),e.jsxs("li",{children:["B learns nothing about A's input beyond ",e.jsx(s,{math:"f(x, y)",inline:!0})," (garbling hides intermediate values)"]})]}),e.jsx("p",{className:"mt-3",children:"This shows OT enables arbitrary secure computation. The converse—that secure computation implies OT—is straightforward: OT itself is a two-party function."})]}),children:"Oblivious transfer is a complete primitive for secure two-party computation. Any function can be securely computed given OT as a building block."}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Broader Impact:"})," Zero-knowledge proofs have transformed from a theoretical curiosity to a practical technology. They enable privacy-preserving computation, verifiable credentials, and scalable blockchain systems."]})]})}export{u as default};
