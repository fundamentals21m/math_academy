import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a,D as t,T as n,E as s,C as r}from"./Callout-CVmmxFk2.js";import{M as i}from"./MathBlock-pVcpo8VG.js";import"./vendor-react-Drj8qL0h.js";import"./index-Ct81wkAO.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-DY5kfYst.js";function g(){return e.jsxs(a,{sectionId:1,children:[e.jsx("h2",{children:"Divisibility and the Euclidean Algorithm"}),e.jsx("p",{children:"The concept of divisibility is fundamental to number theory and cryptography. In this section, we study the properties of divisibility and the ancient but remarkably efficient Euclidean algorithm for computing the greatest common divisor."}),e.jsx("h3",{children:"Basic Divisibility"}),e.jsxs(t,{title:"Divisibility",children:["Let ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," be integers with ",e.jsx(i,{math:"b \\neq 0",inline:!0}),". We say that",e.jsx("em",{children:"b"})," ",e.jsx("strong",{children:"divides"})," ",e.jsx("em",{children:"a"}),", written ",e.jsx(i,{math:"b \\mid a",inline:!0}),", if there exists an integer ",e.jsx("em",{children:"q"})," such that ",e.jsx(i,{math:"a = bq",inline:!0}),"."]}),e.jsxs(t,{title:"Greatest Common Divisor",children:["The ",e.jsx("strong",{children:"greatest common divisor"})," of integers ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"}),", denoted",e.jsx(i,{math:"\\gcd(a, b)",inline:!0})," or simply ",e.jsx(i,{math:"(a, b)",inline:!0}),", is the largest positive integer that divides both ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"}),"."]}),e.jsxs(t,{title:"Relatively Prime",children:["Two integers ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," are ",e.jsx("strong",{children:"relatively prime"})," (or ",e.jsx("strong",{children:"coprime"}),") if ",e.jsx(i,{math:"\\gcd(a, b) = 1",inline:!0}),"."]}),e.jsx("h3",{children:"The Euclidean Algorithm"}),e.jsx("p",{children:"The Euclidean algorithm is one of the oldest algorithms known, dating back to around 300 BCE. It efficiently computes the GCD using repeated division with remainder."}),e.jsxs(n,{title:"Division Algorithm",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Existence:"})," Consider the set ",e.jsx(i,{math:"S = \\{a - bk : k \\in \\mathbb{Z}, a - bk \\geq 0\\}",inline:!0}),"."]}),e.jsxs("p",{children:["This set is nonempty: if ",e.jsx(i,{math:"a \\geq 0",inline:!0}),", then ",e.jsx(i,{math:"a - b \\cdot 0 = a \\in S",inline:!0}),"; if ",e.jsx(i,{math:"a < 0",inline:!0}),", then ",e.jsx(i,{math:"a - b \\cdot a = a(1-b) \\geq 0",inline:!0})," since ",e.jsx(i,{math:"b \\geq 1",inline:!0})," and ",e.jsx(i,{math:"a < 0",inline:!0}),"."]}),e.jsxs("p",{children:["By the Well-Ordering Principle, ",e.jsx("em",{children:"S"})," has a least element. Let ",e.jsx(i,{math:"r = a - bq",inline:!0})," be this least element for some integer ",e.jsx("em",{children:"q"}),"."]}),e.jsxs("p",{children:["We have ",e.jsx(i,{math:"r \\geq 0",inline:!0})," by definition of ",e.jsx("em",{children:"S"}),". Suppose ",e.jsx(i,{math:"r \\geq b",inline:!0}),". Then:"]}),e.jsx(i,{math:"a - b(q+1) = a - bq - b = r - b \\geq 0"}),e.jsxs("p",{children:["This means ",e.jsx(i,{math:"r - b \\in S",inline:!0}),", contradicting that ",e.jsx("em",{children:"r"})," is the least element. Therefore ",e.jsx(i,{math:"0 \\leq r < b",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Uniqueness:"})," Suppose ",e.jsx(i,{math:"a = bq_1 + r_1 = bq_2 + r_2",inline:!0})," with ",e.jsx(i,{math:"0 \\leq r_1, r_2 < b",inline:!0}),"."]}),e.jsxs("p",{children:["Then ",e.jsx(i,{math:"b(q_1 - q_2) = r_2 - r_1",inline:!0}),". Since ",e.jsx(i,{math:"|r_2 - r_1| < b",inline:!0})," and ",e.jsx(i,{math:"b \\mid (r_2 - r_1)",inline:!0}),", we must have ",e.jsx(i,{math:"r_2 - r_1 = 0",inline:!0}),", so ",e.jsx(i,{math:"r_1 = r_2",inline:!0})," and consequently ",e.jsx(i,{math:"q_1 = q_2",inline:!0}),"."]})]}),children:["For any integers ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," with ",e.jsx(i,{math:"b > 0",inline:!0}),", there exist unique integers ",e.jsx("em",{children:"q"})," (quotient) and ",e.jsx("em",{children:"r"})," (remainder) such that:",e.jsx(i,{math:"a = bq + r, \\quad 0 \\leq r < b"})]}),e.jsxs(n,{title:"Euclidean Algorithm",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," The algorithm relies on the key identity:"]}),e.jsx(i,{math:"\\gcd(a, b) = \\gcd(b, a \\bmod b)"}),e.jsxs("p",{children:["To prove this, let ",e.jsx(i,{math:"d = \\gcd(a, b)",inline:!0})," and write ",e.jsx(i,{math:"a = bq + r",inline:!0})," where ",e.jsx(i,{math:"r = a \\bmod b",inline:!0}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"d \\mid a",inline:!0})," and ",e.jsx(i,{math:"d \\mid b",inline:!0}),", we have ",e.jsx(i,{math:"d \\mid (a - bq) = r",inline:!0}),". Thus ",e.jsx("em",{children:"d"})," is a common divisor of ",e.jsx("em",{children:"b"})," and ",e.jsx("em",{children:"r"}),"."]}),e.jsxs("p",{children:["Conversely, if ",e.jsx(i,{math:"c \\mid b",inline:!0})," and ",e.jsx(i,{math:"c \\mid r",inline:!0}),", then ",e.jsx(i,{math:"c \\mid (bq + r) = a",inline:!0}),". So every common divisor of ",e.jsx("em",{children:"b"})," and ",e.jsx("em",{children:"r"})," also divides ",e.jsx("em",{children:"a"}),"."]}),e.jsxs("p",{children:["Therefore, ",e.jsx(i,{math:"\\{",inline:!0}),"common divisors of ",e.jsx("em",{children:"a"}),", ",e.jsx("em",{children:"b"}),e.jsx(i,{math:"\\}",inline:!0})," = ",e.jsx(i,{math:"\\{",inline:!0}),"common divisors of ",e.jsx("em",{children:"b"}),", ",e.jsx("em",{children:"r"}),e.jsx(i,{math:"\\}",inline:!0}),", and so ",e.jsx(i,{math:"\\gcd(a,b) = \\gcd(b, r)",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Termination:"})," The sequence of remainders ",e.jsx(i,{math:"r_1, r_2, r_3, \\ldots",inline:!0})," is strictly decreasing and nonnegative, so it must eventually reach 0. When ",e.jsx(i,{math:"r_k = 0",inline:!0}),", we have ",e.jsx(i,{math:"\\gcd(r_{k-2}, r_{k-1}) = r_{k-1}",inline:!0}),", and by the chain of equalities, this equals ",e.jsx(i,{math:"\\gcd(a, b)",inline:!0}),"."]})]}),children:["To compute ",e.jsx(i,{math:"\\gcd(a, b)",inline:!0})," where ",e.jsx(i,{math:"a > b > 0",inline:!0}),":",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Divide ",e.jsx("em",{children:"a"})," by ",e.jsx("em",{children:"b"})," to get remainder ",e.jsx("em",{children:"r"})]}),e.jsxs("li",{children:["If ",e.jsx("em",{children:"r = 0"}),", then ",e.jsx(i,{math:"\\gcd(a, b) = b",inline:!0})]}),e.jsxs("li",{children:["Otherwise, replace ",e.jsx("em",{children:"a"})," by ",e.jsx("em",{children:"b"}),", ",e.jsx("em",{children:"b"})," by ",e.jsx("em",{children:"r"}),", and repeat"]})]})]}),e.jsxs(s,{title:"Computing GCD(252, 198)",children:[e.jsxs("div",{className:"font-mono text-sm space-y-1",children:[e.jsx("p",{children:"252 = 198 × 1 + 54"}),e.jsx("p",{children:"198 = 54 × 3 + 36"}),e.jsx("p",{children:"54 = 36 × 1 + 18"}),e.jsx("p",{children:"36 = 18 × 2 + 0"})]}),e.jsxs("p",{className:"mt-2",children:["Therefore, ",e.jsx(i,{math:"\\gcd(252, 198) = 18",inline:!0}),"."]})]}),e.jsx("h3",{children:"Time Complexity of the Euclidean Algorithm"}),e.jsxs(n,{title:"Euclidean Algorithm Time Bound",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Bounding the number of steps:"})," Let the sequence of remainders be ",e.jsx(i,{math:"r_0 = a, r_1 = b, r_2, \\ldots, r_n = 0",inline:!0}),"."]}),e.jsxs("p",{children:["We claim that ",e.jsx(i,{math:"r_{i+2} < \\frac{1}{2} r_i",inline:!0})," for all valid ",e.jsx("em",{children:"i"}),". There are two cases:"]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Case 1:"})," If ",e.jsx(i,{math:"r_{i+1} \\leq \\frac{1}{2} r_i",inline:!0}),", then ",e.jsx(i,{math:"r_{i+2} < r_{i+1} \\leq \\frac{1}{2} r_i",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Case 2:"})," If ",e.jsx(i,{math:"r_{i+1} > \\frac{1}{2} r_i",inline:!0}),", then ",e.jsx(i,{math:"r_i = 1 \\cdot r_{i+1} + r_{i+2}",inline:!0})," (the quotient is 1), so ",e.jsx(i,{math:"r_{i+2} = r_i - r_{i+1} < r_i - \\frac{1}{2} r_i = \\frac{1}{2} r_i",inline:!0}),"."]}),e.jsxs("p",{children:["Since the remainder is halved every two steps, after ",e.jsx(i,{math:"2k",inline:!0})," steps where ",e.jsx(i,{math:"k = \\lfloor \\log_2 b \\rfloor + 1",inline:!0}),", the remainder becomes 0."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Bit operations per step:"})," Each step involves dividing numbers with at most ",e.jsx("em",{children:"k"})," bits. Division of a ",e.jsx("em",{children:"k"}),"-bit number by a ",e.jsx("em",{children:"k"}),"-bit number requires ",e.jsx(i,{math:"O(k^2)",inline:!0})," bit operations."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Total:"})," ",e.jsx(i,{math:"O(2k) \\cdot O(k^2) = O(k^3) = O((\\log b)^3)",inline:!0})," bit operations. With more careful analysis using that remainders shrink, this improves to ",e.jsx(i,{math:"O((\\log b)^2)",inline:!0}),"."]})]}),children:["The Euclidean algorithm to compute ",e.jsx(i,{math:"\\gcd(a, b)",inline:!0})," requires at most",e.jsx(i,{math:"O((\\log b)^2)",inline:!0})," bit operations, where the logarithm is base 2.",e.jsxs("p",{className:"mt-2",children:["More precisely, if ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"})," are both k-bit integers, the algorithm terminates in at most ",e.jsx(i,{math:"2k",inline:!0})," steps, each requiring ",e.jsx(i,{math:"O(k^2)",inline:!0}),"bit operations for the division."]})]}),e.jsx(r,{type:"info",children:"The Euclidean algorithm is remarkably efficient - it can compute the GCD of two 1000-digit numbers in a fraction of a second on modern computers."}),e.jsx("h3",{children:"Extended Euclidean Algorithm"}),e.jsxs(n,{title:"Bezout's Identity",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We prove this by strong induction on ",e.jsx(i,{math:"\\min(|a|, |b|)",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Base case:"})," If ",e.jsx(i,{math:"b = 0",inline:!0}),", then ",e.jsx(i,{math:"\\gcd(a, 0) = |a| = a \\cdot 1 + 0 \\cdot 0",inline:!0})," (assuming ",e.jsx(i,{math:"a > 0",inline:!0}),"; otherwise use ",e.jsx(i,{math:"a \\cdot (-1)",inline:!0}),")."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Inductive step:"})," Assume the result holds for all pairs with smaller minimum. Let ",e.jsx(i,{math:"a = bq + r",inline:!0})," where ",e.jsx(i,{math:"0 \\leq r < b",inline:!0}),"."]}),e.jsxs("p",{children:["By the inductive hypothesis, there exist integers ",e.jsx(i,{math:"x', y'",inline:!0})," such that:"]}),e.jsx(i,{math:"bx' + ry' = \\gcd(b, r) = \\gcd(a, b)"}),e.jsxs("p",{children:["Substituting ",e.jsx(i,{math:"r = a - bq",inline:!0}),":"]}),e.jsx(i,{math:"bx' + (a - bq)y' = \\gcd(a, b)"}),e.jsx(i,{math:"ay' + b(x' - qy') = \\gcd(a, b)"}),e.jsxs("p",{children:["Setting ",e.jsx(i,{math:"x = y'",inline:!0})," and ",e.jsx(i,{math:"y = x' - qy'",inline:!0}),", we obtain ",e.jsx(i,{math:"ax + by = \\gcd(a, b)",inline:!0}),"."]}),e.jsx("p",{children:"The extended Euclidean algorithm computes these coefficients by tracking the linear combinations at each step."})]}),children:["For any integers ",e.jsx("em",{children:"a"})," and ",e.jsx("em",{children:"b"}),", not both zero, there exist integers ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"}),"such that:",e.jsx(i,{math:"ax + by = \\gcd(a, b)"}),"The integers ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"})," can be found by running the Euclidean algorithm backwards."]}),e.jsxs(s,{title:"Extended Euclidean Algorithm",children:[e.jsxs("p",{children:["Find integers ",e.jsx("em",{children:"x"})," and ",e.jsx("em",{children:"y"})," such that ",e.jsx(i,{math:"252x + 198y = 18",inline:!0}),"."]}),e.jsx("p",{className:"mt-2",children:"Working backwards from the Euclidean algorithm:"}),e.jsxs("div",{className:"font-mono text-sm space-y-1 mt-2",children:[e.jsx("p",{children:"18 = 54 - 36 × 1"}),e.jsx("p",{children:"18 = 54 - (198 - 54 × 3) = 54 × 4 - 198"}),e.jsx("p",{children:"18 = (252 - 198) × 4 - 198 = 252 × 4 - 198 × 5"})]}),e.jsxs("p",{className:"mt-2",children:["Therefore, ",e.jsx("em",{children:"x = 4"})," and ",e.jsx("em",{children:"y = -5"}),"."]})]}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Cryptographic Application:"})," The extended Euclidean algorithm is essential for computing modular inverses, which are used in RSA encryption, digital signatures, and many other cryptographic protocols."]}),e.jsx("h3",{children:"Properties of GCD"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Key Properties"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx(i,{math:"\\gcd(a, b) = \\gcd(b, a)",inline:!0})," (commutativity)"]}),e.jsxs("li",{children:[e.jsx(i,{math:"\\gcd(a, b) = \\gcd(a - b, b)",inline:!0})," if ",e.jsx(i,{math:"a > b",inline:!0})]}),e.jsx("li",{children:e.jsx(i,{math:"\\gcd(a, b) = \\gcd(a \\mod b, b)",inline:!0})}),e.jsx("li",{children:e.jsx(i,{math:"\\gcd(a, 0) = |a|",inline:!0})}),e.jsx("li",{children:e.jsx(i,{math:"\\gcd(a, 1) = 1",inline:!0})}),e.jsxs("li",{children:["If ",e.jsx(i,{math:"\\gcd(a, b) = 1",inline:!0})," and ",e.jsx(i,{math:"a \\mid bc",inline:!0}),", then ",e.jsx(i,{math:"a \\mid c",inline:!0})]})]})]})]})}export{g as default};
