import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as l,T as i,D as t,C as n,E as r}from"./Callout-CVmmxFk2.js";import{M as s}from"./MathBlock-pVcpo8VG.js";import"./vendor-react-Drj8qL0h.js";import"./index-Ct81wkAO.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-DY5kfYst.js";function f(){return e.jsxs(l,{sectionId:14,children:[e.jsx("h2",{children:"The Rho Method"}),e.jsx("p",{children:"Pollard's rho algorithm is an elegant factoring method that uses very little memory. It exploits the birthday paradox to find collisions in a pseudo-random sequence, revealing factors of the target number."}),e.jsx("h3",{children:"The Birthday Paradox"}),e.jsxs(i,{title:"Birthday Paradox",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["We compute the probability of ",e.jsx("em",{children:"no"})," collision among ",e.jsx("em",{children:"k"})," samples from a set of size ",e.jsx("em",{children:"n"}),"."]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Exact probability:"})}),e.jsxs("p",{className:"mt-2",children:["The probability that all ",e.jsx("em",{children:"k"})," samples are distinct is:"]}),e.jsx(s,{math:"P(\\text{no collision}) = \\frac{n}{n} \\cdot \\frac{n-1}{n} \\cdot \\frac{n-2}{n} \\cdots \\frac{n-k+1}{n} = \\prod_{i=0}^{k-1} \\left(1 - \\frac{i}{n}\\right)"}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Approximation:"})}),e.jsxs("p",{className:"mt-2",children:["Using ",e.jsx(s,{math:"1 - x \\approx e^{-x}",inline:!0})," for small ",e.jsx("em",{children:"x"}),":"]}),e.jsx(s,{math:"P(\\text{no collision}) \\approx \\prod_{i=0}^{k-1} e^{-i/n} = e^{-\\sum_{i=0}^{k-1} i/n} = e^{-k(k-1)/(2n)}"}),e.jsxs("p",{className:"mt-2",children:["For large ",e.jsx("em",{children:"k"}),", this is approximately ",e.jsx(s,{math:"e^{-k^2/(2n)}",inline:!0}),"."]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"50% collision threshold:"})}),e.jsxs("p",{className:"mt-2",children:["We want ",e.jsx(s,{math:"P(\\text{collision}) = 1 - P(\\text{no collision}) = 0.5",inline:!0}),":"]}),e.jsx(s,{math:"e^{-k^2/(2n)} = 0.5"}),e.jsx(s,{math:"-\\frac{k^2}{2n} = \\ln(0.5) = -\\ln 2"}),e.jsx(s,{math:"k^2 = 2n \\ln 2"}),e.jsx(s,{math:"k = \\sqrt{2n \\ln 2} \\approx 1.177\\sqrt{n}"}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"General bound:"})}),e.jsxs("p",{className:"mt-2",children:["For any constant probability ",e.jsx("em",{children:"p"})," of collision:"]}),e.jsx(s,{math:"k = \\sqrt{2n \\ln\\frac{1}{1-p}} = O(\\sqrt{n})"}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Classic example:"})," With ",e.jsx(s,{math:"n = 365",inline:!0})," days, we need only ",e.jsx(s,{math:"k = 23",inline:!0})," people for 50% collision probability (",e.jsx(s,{math:"\\sqrt{2 \\cdot 365 \\cdot \\ln 2} \\approx 22.5",inline:!0}),")."]})]}),children:["In a group of ",e.jsx(s,{math:"\\sqrt{2n \\ln 2} \\approx 1.18\\sqrt{n}",inline:!0})," randomly chosen people from a population of ",e.jsx("em",{children:"n"}),", there is a 50% chance of a repeated birthday. More generally, after ",e.jsx(s,{math:"O(\\sqrt{n})",inline:!0})," samples, we expect a collision."]}),e.jsxs("p",{children:["The rho method applies this principle: if we can detect a collision in a sequence modulo a factor ",e.jsx("em",{children:"p"})," of ",e.jsx("em",{children:"n"}),", we can likely find ",e.jsx("em",{children:"p"}),"."]}),e.jsx("h3",{children:"Pollard's Rho Algorithm"}),e.jsxs(t,{title:"Pollard's Rho",children:["To factor ",e.jsx("em",{children:"n"}),":",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Choose a polynomial ",e.jsx(s,{math:"f(x) = x^2 + c \\bmod n",inline:!0})," (typically c = 1)"]}),e.jsxs("li",{children:["Start with ",e.jsx(s,{math:"x_0 = 2",inline:!0})," (or random)"]}),e.jsxs("li",{children:["Generate sequence: ",e.jsx(s,{math:"x_{i+1} = f(x_i)",inline:!0})]}),e.jsxs("li",{children:["After ",e.jsx(s,{math:"O(\\sqrt{p})",inline:!0})," steps for smallest factor ",e.jsx("em",{children:"p"}),", expect collision mod ",e.jsx("em",{children:"p"})]}),e.jsxs("li",{children:["Use ",e.jsx(s,{math:"d = \\gcd(x_i - x_j, n)",inline:!0})," to find factor"]})]})]}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:'Why "Rho"?'})," The sequence ",e.jsx(s,{math:"x_0, x_1, x_2, \\ldots",inline:!0})," eventually enters a cycle (by pigeonhole principle), forming a shape like the Greek letter ρ."]}),e.jsx("h3",{children:"Floyd's Cycle Detection"}),e.jsx("p",{children:`Rather than storing all values to detect collisions (expensive in memory), we use Floyd's "tortoise and hare" algorithm:`}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Floyd's Algorithm"}),e.jsxs("div",{className:"font-mono text-sm text-dark-300",children:[e.jsx("p",{children:"x = y = 2 (starting value)"}),e.jsx("p",{children:"repeat:"}),e.jsx("p",{className:"ml-4",children:"x = f(x)          // tortoise: one step"}),e.jsx("p",{className:"ml-4",children:"y = f(f(y))       // hare: two steps"}),e.jsx("p",{className:"ml-4",children:"d = gcd(|x - y|, n)"}),e.jsx("p",{className:"ml-4",children:"if 1 < d < n: return d"}),e.jsx("p",{className:"ml-4",children:"if d = n: try different c"})]})]}),e.jsxs(r,{title:"Pollard Rho Example",children:[e.jsxs("p",{children:["Factor ",e.jsx(s,{math:"n = 8051",inline:!0})," using ",e.jsx(s,{math:"f(x) = x^2 + 1",inline:!0})]}),e.jsxs("table",{className:"w-full mt-2 text-sm",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"py-1 text-left",children:"i"}),e.jsx("th",{className:"py-1 text-left",children:"x (tortoise)"}),e.jsx("th",{className:"py-1 text-left",children:"y (hare)"}),e.jsx("th",{className:"py-1 text-left",children:"|x - y|"}),e.jsx("th",{className:"py-1 text-left",children:"gcd"})]})}),e.jsxs("tbody",{className:"text-dark-300",children:[e.jsxs("tr",{children:[e.jsx("td",{children:"0"}),e.jsx("td",{children:"2"}),e.jsx("td",{children:"2"}),e.jsx("td",{children:"0"}),e.jsx("td",{children:"-"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"1"}),e.jsx("td",{children:"5"}),e.jsx("td",{children:"26"}),e.jsx("td",{children:"21"}),e.jsx("td",{children:"1"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"2"}),e.jsx("td",{children:"26"}),e.jsx("td",{children:"7474"}),e.jsx("td",{children:"7448"}),e.jsx("td",{children:"1"})]}),e.jsxs("tr",{children:[e.jsx("td",{children:"3"}),e.jsx("td",{children:"677"}),e.jsx("td",{children:"871"}),e.jsx("td",{children:"194"}),e.jsx("td",{children:"97"})]})]})]}),e.jsxs("p",{className:"mt-2",children:["Found factor: ",e.jsx(s,{math:"97",inline:!0}),". Check: ",e.jsx(s,{math:"8051 = 97 \\times 83",inline:!0})]})]}),e.jsx("h3",{children:"Complexity Analysis"}),e.jsxs(i,{title:"Rho Complexity",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We analyze Pollard's rho using the birthday paradox framework."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Setup:"})}),e.jsxs("p",{className:"mt-2",children:["Let ",e.jsx(s,{math:"n = pq",inline:!0})," with ",e.jsx(s,{math:"p \\leq q",inline:!0}),". The iteration function ",e.jsx(s,{math:"f(x) = x^2 + c \\bmod n",inline:!0})," induces a function on ",e.jsx(s,{math:"\\mathbb{Z}/p\\mathbb{Z}",inline:!0}),":"]}),e.jsx(s,{math:"\\bar{f}(x \\bmod p) = f(x) \\bmod p"}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Collision detection:"})}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"x_i \\equiv x_j \\pmod{p}",inline:!0})," but ",e.jsx(s,{math:"x_i \\not\\equiv x_j \\pmod{n}",inline:!0}),", then:"]}),e.jsx(s,{math:"p \\mid (x_i - x_j) \\text{ but } n \\nmid (x_i - x_j)"}),e.jsxs("p",{className:"mt-2",children:["Therefore ",e.jsx(s,{math:"\\gcd(x_i - x_j, n)",inline:!0})," equals ",e.jsx("em",{children:"p"})," (or a multiple, but not ",e.jsx("em",{children:"n"}),")."]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Birthday analysis mod p:"})}),e.jsxs("p",{className:"mt-2",children:["The sequence ",e.jsx(s,{math:"x_0, x_1, x_2, \\ldots",inline:!0})," reduced mod ",e.jsx("em",{children:"p"})," behaves like random samples from ",e.jsx(s,{math:"\\mathbb{Z}/p\\mathbb{Z}",inline:!0}),". By the birthday paradox, we expect a collision mod ",e.jsx("em",{children:"p"})," after approximately:"]}),e.jsx(s,{math:"O(\\sqrt{p})"}),e.jsx("p",{className:"mt-2",children:"iterations."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Factor size bound:"})}),e.jsxs("p",{className:"mt-2",children:["The smallest factor satisfies ",e.jsx(s,{math:"p \\leq \\sqrt{n}",inline:!0})," (otherwise ",e.jsx(s,{math:"p > \\sqrt{n}",inline:!0})," and ",e.jsx(s,{math:"q \\geq p",inline:!0})," implies ",e.jsx(s,{math:"n = pq > n",inline:!0}),", contradiction)."]}),e.jsx(s,{math:"\\sqrt{p} \\leq \\sqrt[4]{n} = n^{1/4}"}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Bit complexity:"})}),e.jsx("p",{className:"mt-2",children:"Each iteration requires:"}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["One squaring mod ",e.jsx("em",{children:"n"}),": ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0})," bit operations"]}),e.jsxs("li",{children:["One addition mod ",e.jsx("em",{children:"n"}),": ",e.jsx(s,{math:"O(\\log n)",inline:!0})," bit operations"]}),e.jsxs("li",{children:["One GCD computation: ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0})," bit operations (Euclidean algorithm)"]})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Total complexity:"})}),e.jsx(s,{math:"O(\\sqrt{p}) \\cdot O((\\log n)^2) = O(n^{1/4} (\\log n)^2)"}),e.jsxs("p",{className:"mt-3",children:[e.jsx("strong",{children:"Heuristic assumption:"})," This analysis assumes ",e.jsx(s,{math:"f(x) = x^2 + c",inline:!0})," behaves like a random function mod ",e.jsx("em",{children:"p"}),". While not provably random, extensive empirical evidence supports this behavior for most ",e.jsx("em",{children:"c"}),"."]})]}),children:["For ",e.jsx(s,{math:"n = pq",inline:!0})," with ",e.jsx(s,{math:"p \\leq q",inline:!0}),", Pollard's rho finds factor ",e.jsx("em",{children:"p"})," in expected time ",e.jsx(s,{math:"O(\\sqrt{p})",inline:!0})," iterations. Since ",e.jsx(s,{math:"p \\leq \\sqrt{n}",inline:!0}),", this is ",e.jsx(s,{math:"O(n^{1/4})",inline:!0}),".",e.jsxs("p",{className:"mt-2",children:["Each iteration requires ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0})," bit operations, so total: ",e.jsx(s,{math:"O(n^{1/4} (\\log n)^2)",inline:!0})]})]}),e.jsxs(n,{type:"success",children:[e.jsx("strong",{children:"Memory Efficient:"})," Unlike baby-step giant-step which needs"," ",e.jsx(s,{math:"O(\\sqrt{p})",inline:!0})," storage, Pollard's rho uses only ",e.jsx(s,{math:"O(1)",inline:!0})," memory."]}),e.jsx("h3",{children:"Brent's Improvement"}),e.jsxs(t,{title:"Brent's Optimization",children:["Instead of Floyd's cycle detection, Brent's method:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"Keeps one pointer fixed while advancing the other"}),e.jsx("li",{children:'Doubles the interval at each "cycle"'}),e.jsx("li",{children:"Provides ~24% speedup in practice"})]})]}),e.jsx("h3",{children:"Batch GCD Computation"}),e.jsx("p",{children:"Computing many individual GCDs is expensive. We can batch them:"}),e.jsxs(i,{title:"Batching Strategy",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We prove correctness and analyze the trade-offs of batch GCD computation."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Correctness:"})}),e.jsxs("p",{className:"mt-2",children:["Suppose ",e.jsx(s,{math:"x_i \\equiv y_i \\pmod{p}",inline:!0})," for some factor ",e.jsx("em",{children:"p"})," of ",e.jsx("em",{children:"n"})," and some index ",e.jsx("em",{children:"i"})," in the batch. Then ",e.jsx(s,{math:"p \\mid (x_i - y_i)",inline:!0}),", which implies:"]}),e.jsx(s,{math:"p \\mid \\prod_{j=1}^{m} (x_j - y_j) = Q"}),e.jsx("p",{className:"mt-2",children:"Therefore:"}),e.jsx(s,{math:"\\gcd(Q, n) \\geq p > 1"}),e.jsx("p",{className:"mt-2",children:"The batch GCD detects the factor if any individual GCD would have detected it."}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Complexity improvement:"})}),e.jsxs("p",{className:"mt-2",children:["Without batching, after ",e.jsx("em",{children:"k"})," iterations we compute ",e.jsx("em",{children:"k"})," GCDs, each costing ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0}),". Total: ",e.jsx(s,{math:"O(k (\\log n)^2)",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["With batching (batch size ",e.jsx("em",{children:"m"}),"):"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Multiplications: ",e.jsx(s,{math:"k",inline:!0})," products mod ",e.jsx("em",{children:"n"}),", each ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0})]}),e.jsxs("li",{children:["GCDs: ",e.jsx(s,{math:"k/m",inline:!0})," computations, each ",e.jsx(s,{math:"O((\\log n)^2)",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:["GCD cost reduced by factor of ",e.jsx("em",{children:"m"}),": ",e.jsx(s,{math:"O((k/m)(\\log n)^2)",inline:!0})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Trade-off:"})}),e.jsxs("p",{className:"mt-2",children:["If ",e.jsx(s,{math:"\\gcd(Q, n) = n",inline:!0}),", the batch is uninformative (all differences might share different factors summing to ",e.jsx("em",{children:"n"}),"). We must then:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"Fall back to individual GCDs within the batch, OR"}),e.jsx("li",{children:"Binary search to find which sub-batch contains the collision"})]}),e.jsx("p",{className:"mt-3",children:e.jsx("strong",{children:"Optimal batch size:"})}),e.jsxs("p",{className:"mt-2",children:["Typical choice: ",e.jsx(s,{math:"m \\approx 100",inline:!0})," to ",e.jsx(s,{math:"m \\approx 1000",inline:!0}),". This balances:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Reducing GCD overhead (larger ",e.jsx("em",{children:"m"})," better)"]}),e.jsxs("li",{children:["Avoiding overshooting the collision (smaller ",e.jsx("em",{children:"m"})," better)"]}),e.jsxs("li",{children:["Managing the cost of fallback when ",e.jsx(s,{math:"\\gcd = n",inline:!0})]})]}),e.jsx("p",{className:"mt-3",children:"In practice, batching provides a significant constant-factor speedup without changing the asymptotic complexity."})]}),children:["Accumulate products: ",e.jsx(s,{math:"Q = \\prod_{i=1}^{m} (x_i - y_i) \\bmod n",inline:!0}),"then compute ",e.jsx(s,{math:"\\gcd(Q, n)",inline:!0})," once every ",e.jsx("em",{children:"m"})," iterations. This reduces the number of GCD computations by factor of ",e.jsx("em",{children:"m"}),"."]}),e.jsx("h3",{children:"Pollard's Rho for DLP"}),e.jsxs("p",{children:["The same idea works for discrete logarithms. Given ",e.jsx(s,{math:"h = g^x",inline:!0}),", find ",e.jsx("em",{children:"x"})," by detecting collisions in a sequence that depends on both ",e.jsx("em",{children:"g"})," and ",e.jsx("em",{children:"h"}),"."]}),e.jsxs(t,{title:"Rho for DLP",children:["Define three sets partitioning the group, and iteration function:",e.jsx(s,{math:"(a_{i+1}, b_{i+1}, x_{i+1}) = \\begin{cases} (a_i, b_i+1, x_i \\cdot h) & x_i \\in S_1 \\\\ (2a_i, 2b_i, x_i^2) & x_i \\in S_2 \\\\ (a_i+1, b_i, x_i \\cdot g) & x_i \\in S_3 \\end{cases}"}),"Collision ",e.jsx(s,{math:"x_i = x_j",inline:!0})," gives ",e.jsx(s,{math:"g^{a_i} h^{b_i} = g^{a_j} h^{b_j}",inline:!0}),", yielding ",e.jsx(s,{math:"x = (a_i - a_j)(b_j - b_i)^{-1} \\bmod q",inline:!0}),"."]}),e.jsx("h3",{children:"Practical Performance"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Rho Method Performance"}),e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Smallest Factor"}),e.jsx("th",{className:"text-left py-2",children:"Expected Iterations"}),e.jsx("th",{className:"text-left py-2",children:"Time (rough)"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"20 digits"}),e.jsx("td",{className:"py-2",children:"~10^10"}),e.jsx("td",{className:"py-2",children:"Seconds"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"30 digits"}),e.jsx("td",{className:"py-2",children:"~10^15"}),e.jsx("td",{className:"py-2",children:"Days"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"40 digits"}),e.jsx("td",{className:"py-2",children:"~10^20"}),e.jsx("td",{className:"py-2",children:"Years"})]})]})]})]}),e.jsxs(n,{type:"info",children:[e.jsx("strong",{children:"Best Use Case:"})," Pollard's rho is ideal for finding small factors quickly. For balanced semiprimes (RSA moduli where p ≈ q), more sophisticated methods like the quadratic sieve are needed."]})]})}export{f as default};
