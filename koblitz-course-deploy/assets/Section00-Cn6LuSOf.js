import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as o,D as t,E as s,T as n,C as r}from"./Callout-CVmmxFk2.js";import{M as i}from"./MathBlock-pVcpo8VG.js";import"./vendor-react-Drj8qL0h.js";import"./index-Ct81wkAO.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-DY5kfYst.js";function g(){return e.jsxs(o,{sectionId:0,children:[e.jsx("h2",{children:"Time Estimates for Doing Arithmetic"}),e.jsxs("p",{children:["One topic that plays a central role in cryptography is estimating the number of",e.jsx("strong",{children:" bit operations"})," needed to perform various number theoretic tasks by computer. Understanding computational complexity helps us determine which cryptographic algorithms are secure and which can be broken in reasonable time."]}),e.jsx("h3",{children:"Numbers in Different Bases"}),e.jsxs(t,{title:"Base-b Representation",children:["A nonnegative integer ",e.jsx("em",{children:"n"})," written to the ",e.jsx("strong",{children:"base b"})," is a notation of the form"," ",e.jsx(i,{math:"(d_{k-1}d_{k-2} \\cdots d_1 d_0)_b"}),"where the ",e.jsx("em",{children:"d"}),"'s are ",e.jsx("strong",{children:"digits"}),", i.e., symbols for integers between 0 and b - 1. This notation means:",e.jsx(i,{math:"n = d_{k-1}b^{k-1} + d_{k-2}b^{k-2} + \\cdots + d_1 b + d_0"}),"If the first digit ",e.jsxs("em",{children:["d",e.jsx("sub",{children:"k-1"})]})," is not zero, we call ",e.jsx("em",{children:"n"})," a ",e.jsx("strong",{children:"k-digit base-b number"}),"."]}),e.jsxs("p",{children:["Any number between ",e.jsx(i,{math:"b^{k-1}",inline:!0})," and ",e.jsx(i,{math:"b^k",inline:!0})," is a k-digit number to the base b. The most common bases are:"]}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 my-4 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Decimal (b = 10)"})," - The standard system we use daily"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Binary (b = 2)"})," - Used by computers; digits are 0 and 1 (called ",e.jsx("em",{children:"bits"}),")"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Hexadecimal (b = 16)"})," - Compact representation using digits 0-9 and A-F"]})]}),e.jsxs(s,{title:"Base Conversions",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"(a)"})," ",e.jsx(i,{math:"(11001001)_2 = 201",inline:!0})," in decimal"]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(b)"})," When b = 26, using letters A-Z for digits 0-25: ",e.jsx(i,{math:"(BAD)_{26} = 679",inline:!0})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"(c)"})," Converting ",e.jsx(i,{math:"10^6",inline:!0})," to different bases:"]}),e.jsx(i,{math:"10^6 = (11110100001001000000)_2 = (11333311)_7 = (CEXHO)_{26}"})]}),e.jsx("h3",{children:"Number of Digits"}),e.jsxs("p",{children:["An integer ",e.jsx("em",{children:"n"})," satisfying ",e.jsx(i,{math:"b^{k-1} \\leq n < b^k",inline:!0})," has ",e.jsx("em",{children:"k"})," digits to the base ",e.jsx("em",{children:"b"}),". Using the definition of logarithms:"]}),e.jsxs(n,{title:"Number of Digits Formula",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Let ",e.jsx("em",{children:"n"})," be a positive integer with ",e.jsx("em",{children:"k"})," digits in base ",e.jsx("em",{children:"b"}),". By definition of base-",e.jsx("em",{children:"b"})," representation:"]}),e.jsx(i,{math:"b^{k-1} \\leq n < b^k"}),e.jsxs("p",{children:["Taking logarithms base ",e.jsx("em",{children:"b"})," of all parts of this inequality:"]}),e.jsx(i,{math:"k - 1 \\leq \\log_b n < k"}),e.jsxs("p",{children:["This means ",e.jsx(i,{math:"\\lfloor \\log_b n \\rfloor = k - 1",inline:!0}),", and therefore:"]}),e.jsx(i,{math:"k = \\lfloor \\log_b n \\rfloor + 1"}),e.jsxs("p",{children:["Using the change of base formula ",e.jsx(i,{math:"\\log_b n = \\frac{\\log n}{\\log b}",inline:!0}),", we obtain the equivalent form:"]}),e.jsx(i,{math:"\\text{number of digits} = \\left\\lfloor \\frac{\\log n}{\\log b} \\right\\rfloor + 1"})]}),children:["The number of base-b digits in a positive integer ",e.jsx("em",{children:"n"})," is:",e.jsx(i,{math:"\\text{number of digits} = \\lfloor \\log_b n \\rfloor + 1 = \\left\\lfloor \\frac{\\log n}{\\log b} \\right\\rfloor + 1"}),"where ",e.jsx(i,{math:"\\lfloor \\cdot \\rfloor",inline:!0})," denotes the floor (greatest integer) function."]}),e.jsx("h3",{children:"Bit Operations"}),e.jsx("p",{children:"Let's analyze binary addition in detail. When adding two k-bit numbers, we repeat these steps k times:"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Binary Addition Steps"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 text-dark-300",children:[e.jsx("li",{children:"Look at the top and bottom bit, and check for a carry"}),e.jsx("li",{children:"If both bits are 0 and no carry: put down 0"}),e.jsx("li",{children:"If exactly one bit is 1 and no carry (or both 0 with carry): put down 1"}),e.jsx("li",{children:"If both bits are 1 and no carry (or one bit is 1 with carry): put down 0, carry 1"}),e.jsx("li",{children:"If both bits are 1 and there is a carry: put down 1, carry 1"})]})]}),e.jsxs(t,{title:"Bit Operation",children:["A ",e.jsx("strong",{children:"bit operation"})," is a single step in binary arithmetic. The time a computer takes to perform a task is essentially proportional to the number of bit operations required."]}),e.jsxs(r,{type:"info",children:["Adding two k-bit numbers requires exactly ",e.jsx("strong",{children:"k bit operations"}),"."]}),e.jsx("h3",{children:"Time Complexity of Multiplication"}),e.jsxs("p",{children:["Consider multiplying a k-bit integer ",e.jsx("em",{children:"n"})," by an l-bit integer ",e.jsx("em",{children:"m"}),". Using the standard long multiplication algorithm, we obtain at most l rows, each requiring k bit operations to add."]}),e.jsxs(n,{title:"Multiplication Time Bound",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Consider the standard long multiplication algorithm for multiplying a ",e.jsx("em",{children:"k"}),"-bit integer ",e.jsx("em",{children:"n"})," by an ",e.jsx("em",{children:"l"}),"-bit integer ",e.jsx("em",{children:"m"}),"."]}),e.jsxs("p",{children:["Write ",e.jsx("em",{children:"m"})," in binary as ",e.jsx(i,{math:"m = \\sum_{i=0}^{\\ell-1} m_i \\cdot 2^i",inline:!0})," where each ",e.jsx(i,{math:"m_i \\in \\{0, 1\\}",inline:!0}),"."]}),e.jsx("p",{children:"The product can be computed as:"}),e.jsx(i,{math:"n \\cdot m = \\sum_{i=0}^{\\ell-1} m_i \\cdot n \\cdot 2^i"}),e.jsxs("p",{children:["This sum has at most ",e.jsx("em",{children:"l"})," nonzero terms (one for each bit of ",e.jsx("em",{children:"m"}),"). Each term ",e.jsx(i,{math:"n \\cdot 2^i",inline:!0})," is simply ",e.jsx("em",{children:"n"})," shifted left by ",e.jsx("em",{children:"i"})," positions, which is a ",e.jsx(i,{math:"(k+i)",inline:!0}),"-bit number."]}),e.jsxs("p",{children:["Adding two numbers with at most ",e.jsx(i,{math:"(k + \\ell)",inline:!0})," bits requires at most ",e.jsx(i,{math:"k + \\ell",inline:!0})," bit operations. We perform at most ",e.jsx(i,{math:"\\ell - 1",inline:!0})," such additions."]}),e.jsxs("p",{children:["Each partial product computation involves examining one bit of ",e.jsx("em",{children:"m"})," and potentially adding a shifted copy of ",e.jsx("em",{children:"n"}),". The total work is bounded by:"]}),e.jsx(i,{math:"\\text{Total bit operations} < \\ell \\cdot k = k\\ell"}),e.jsxs("p",{children:["When ",e.jsx(i,{math:"k = \\ell",inline:!0}),", this gives the bound ",e.jsx(i,{math:"k^2",inline:!0})," bit operations."]})]}),children:[e.jsx(i,{math:"\\text{Time}(\\text{multiply } k\\text{-bit integer by } \\ell\\text{-bit integer}) < k\\ell"}),"As a special case:",e.jsx(i,{math:"\\text{Time}(\\text{multiply } k\\text{-bit by } k\\text{-bit}) < k^2"})]}),e.jsxs(s,{title:"Computing n!",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Problem:"})," Find an upper bound for the number of bit operations to compute n!"]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Solution:"})," If n is a k-bit integer, then every integer less than n has at most k bits, and n! has at most nk bits. In each of the n-2 multiplications, we multiply an integer with at most k bits by one with at most nk bits, requiring at most nk",e.jsx("sup",{children:"2"})," bit operations."]}),e.jsx(i,{math:"\\text{Total bit operations} \\leq (n-2) \\cdot nk^2 = n(n-2)(\\lfloor \\log_2 n \\rfloor + 1)^2 \\approx n^2(\\log_2 n)^2"})]}),e.jsx("h3",{children:"Big-O Notation"}),e.jsxs("p",{children:["When analyzing algorithms, we use ",e.jsx("strong",{children:"Big-O notation"})," to describe how the running time grows as the input size increases:"]}),e.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-2 gap-4 my-6",children:[e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700",children:[e.jsx("h4",{className:"text-lg font-semibold text-emerald-400 mb-2",children:"Polynomial Time"}),e.jsx("p",{className:"text-dark-300 mb-2",children:"Algorithms with time bounded by a polynomial in input size:"}),e.jsxs("p",{className:"font-mono text-emerald-400",children:["O(k), O(k",e.jsx("sup",{children:"2"}),"), O(k",e.jsx("sup",{children:"3"}),")"]}),e.jsx("p",{className:"text-dark-400 text-sm mt-2",children:'These are considered "efficient" or "tractable".'})]}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700",children:[e.jsx("h4",{className:"text-lg font-semibold text-amber-400 mb-2",children:"Exponential Time"}),e.jsx("p",{className:"text-dark-300 mb-2",children:"Algorithms where time grows exponentially:"}),e.jsxs("p",{className:"font-mono text-amber-400",children:["O(2",e.jsx("sup",{children:"k"}),"), O(e",e.jsx("sup",{children:"k"}),")"]}),e.jsx("p",{className:"text-dark-400 text-sm mt-2",children:"These become infeasible for large inputs."})]})]}),e.jsxs(r,{type:"success",children:[e.jsx("strong",{children:"Key Insight for Cryptography:"})," Cryptographic security relies on the existence of one-way functions - operations that are easy (polynomial time) to compute but hard (exponential time) to reverse. For example, multiplication is O(k",e.jsx("sup",{children:"2"}),"), but factoring is believed to require subexponential time."]})]})}export{g as default};
