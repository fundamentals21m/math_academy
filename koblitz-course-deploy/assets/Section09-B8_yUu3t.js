import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as a,D as i,T as n,E as r,C as t}from"./Callout-CVmmxFk2.js";import{M as s}from"./MathBlock-pVcpo8VG.js";import"./vendor-react-Drj8qL0h.js";import"./index-Ct81wkAO.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-math-p018AHG0.js";import"./quizMap-DY5kfYst.js";function g(){return e.jsxs(a,{sectionId:9,children:[e.jsx("h2",{children:"RSA"}),e.jsx("p",{children:"RSA, named after Rivest, Shamir, and Adleman (1977), is the most widely deployed public-key cryptosystem. Its security is based on the difficulty of factoring large integers."}),e.jsx("h3",{children:"Key Generation"}),e.jsxs(i,{title:"RSA Key Generation",children:[e.jsxs("ol",{className:"list-decimal list-inside space-y-2",children:[e.jsxs("li",{children:["Choose two large distinct primes ",e.jsx("em",{children:"p"})," and ",e.jsx("em",{children:"q"})]}),e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"n = pq",inline:!0})," (the modulus)"]}),e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"\\varphi(n) = (p-1)(q-1)",inline:!0})]}),e.jsxs("li",{children:["Choose ",e.jsx("em",{children:"e"})," with ",e.jsx(s,{math:"1 < e < \\varphi(n)",inline:!0})," and ",e.jsx(s,{math:"\\gcd(e, \\varphi(n)) = 1",inline:!0})]}),e.jsxs("li",{children:["Compute ",e.jsx(s,{math:"d \\equiv e^{-1} \\pmod{\\varphi(n)}",inline:!0})]})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Public key:"})," ",e.jsx(s,{math:"(n, e)",inline:!0})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Private key:"})," ",e.jsx(s,{math:"d",inline:!0})," (or equivalently ",e.jsx("em",{children:"p, q"}),")"]})]}),e.jsx("h3",{children:"Encryption and Decryption"}),e.jsxs(n,{title:"RSA Encryption/Decryption",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Well-definedness:"})," We must verify that decryption recovers the original message, i.e., that ",e.jsx(s,{math:"(M^e)^d \\equiv M \\pmod{n}",inline:!0})," for all ",e.jsx(s,{math:"M \\in \\mathbb{Z}_n",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["By construction, ",e.jsx(s,{math:"ed \\equiv 1 \\pmod{\\varphi(n)}",inline:!0}),", so we can write",e.jsx(s,{math:"ed = 1 + k\\varphi(n)",inline:!0})," for some integer ",e.jsx(s,{math:"k \\geq 0",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Case 1:"})," If ",e.jsx(s,{math:"\\gcd(M, n) = 1",inline:!0}),", then by Euler's theorem:"]}),e.jsx(s,{math:"M^{\\varphi(n)} \\equiv 1 \\pmod{n}"}),e.jsx("p",{className:"mt-2",children:"Therefore:"}),e.jsx(s,{math:"M^{ed} = M^{1 + k\\varphi(n)} = M \\cdot (M^{\\varphi(n)})^k \\equiv M \\cdot 1^k = M \\pmod{n}"}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Case 2:"})," If ",e.jsx(s,{math:"\\gcd(M, n) \\neq 1",inline:!0}),", then since ",e.jsx(s,{math:"n = pq",inline:!0})," with",e.jsx(s,{math:"p \\neq q",inline:!0})," prime, we have ",e.jsx(s,{math:"M \\equiv 0 \\pmod{p}",inline:!0})," or",e.jsx(s,{math:"M \\equiv 0 \\pmod{q}",inline:!0})," (or both)."]}),e.jsxs("p",{className:"mt-2",children:["Suppose ",e.jsx(s,{math:"M \\equiv 0 \\pmod{p}",inline:!0})," but ",e.jsx(s,{math:"\\gcd(M, q) = 1",inline:!0}),". Then ",e.jsx(s,{math:"M^{ed} \\equiv 0 \\equiv M \\pmod{p}",inline:!0}),". By Fermat's little theorem, ",e.jsx(s,{math:"M^{q-1} \\equiv 1 \\pmod{q}",inline:!0}),", and since",e.jsx(s,{math:"(p-1) \\mid \\varphi(n)",inline:!0}),":"]}),e.jsx(s,{math:"M^{ed} = M \\cdot M^{k\\varphi(n)} = M \\cdot (M^{q-1})^{k(p-1)} \\equiv M \\cdot 1 = M \\pmod{q}"}),e.jsxs("p",{className:"mt-2",children:["By the Chinese Remainder Theorem, ",e.jsx(s,{math:"M^{ed} \\equiv M \\pmod{n}",inline:!0}),"."]})]}),children:["For message ",e.jsx(s,{math:"M \\in \\{0, 1, \\ldots, n-1\\}",inline:!0}),":",e.jsx("p",{className:"mt-2",children:e.jsx("strong",{children:"Encryption:"})}),e.jsx(s,{math:"C = M^e \\bmod n"}),e.jsx("p",{children:e.jsx("strong",{children:"Decryption:"})}),e.jsx(s,{math:"M = C^d \\bmod n"})]}),e.jsxs(n,{title:"RSA Correctness",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:["Since ",e.jsx(s,{math:"ed \\equiv 1 \\pmod{\\varphi(n)}",inline:!0}),", we can write",e.jsx(s,{math:"ed = 1 + k\\varphi(n)",inline:!0})," for some non-negative integer ",e.jsx(s,{math:"k",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["For ",e.jsx(s,{math:"M",inline:!0})," coprime to ",e.jsx(s,{math:"n",inline:!0}),", by Euler's theorem",e.jsx(s,{math:"M^{\\varphi(n)} \\equiv 1 \\pmod{n}",inline:!0}),":"]}),e.jsx(s,{math:"M^{ed} = M^{1+k\\varphi(n)} = M \\cdot (M^{\\varphi(n)})^k \\equiv M \\cdot 1^k = M \\pmod{n}"}),e.jsxs("p",{className:"mt-2",children:["For the case when ",e.jsx(s,{math:"\\gcd(M, n) \\neq 1",inline:!0}),", we use the Chinese Remainder Theorem by verifying the congruence modulo ",e.jsx(s,{math:"p",inline:!0})," and modulo ",e.jsx(s,{math:"q",inline:!0})," separately, applying Fermat's little theorem to each prime factor."]})]}),children:["Decryption recovers the original message: ",e.jsx(s,{math:"(M^e)^d \\equiv M \\pmod{n}",inline:!0})]}),e.jsxs(r,{title:"Small RSA Example",children:[e.jsx("p",{children:e.jsx("strong",{children:"Key Generation:"})}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Choose ",e.jsx(s,{math:"p = 61, q = 53",inline:!0})]}),e.jsx("li",{children:e.jsx(s,{math:"n = 61 \\times 53 = 3233",inline:!0})}),e.jsx("li",{children:e.jsx(s,{math:"\\varphi(n) = 60 \\times 52 = 3120",inline:!0})}),e.jsxs("li",{children:["Choose ",e.jsx(s,{math:"e = 17",inline:!0})," (coprime to 3120)"]}),e.jsx("li",{children:e.jsx(s,{math:"d = 17^{-1} \\bmod 3120 = 2753",inline:!0})})]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Encryption:"})," Encrypt ",e.jsx(s,{math:"M = 65",inline:!0})]}),e.jsx(s,{math:"C = 65^{17} \\bmod 3233 = 2790"}),e.jsx("p",{children:e.jsx("strong",{children:"Decryption:"})}),e.jsx(s,{math:"M = 2790^{2753} \\bmod 3233 = 65"})]}),e.jsx("h3",{children:"Security of RSA"}),e.jsxs(i,{title:"RSA Problem",children:["Given the public key ",e.jsx(s,{math:"(n, e)",inline:!0})," and ciphertext ",e.jsx("em",{children:"C"}),", find the plaintext ",e.jsx("em",{children:"M"})," such that ",e.jsx(s,{math:"C \\equiv M^e \\pmod{n}",inline:!0}),"."]}),e.jsxs(t,{type:"info",children:[e.jsx("strong",{children:"Factoring Connection:"})," If we can factor ",e.jsx("em",{children:"n"})," into ",e.jsx("em",{children:"p"})," and ",e.jsx("em",{children:"q"}),", we can compute ",e.jsx(s,{math:"\\varphi(n)",inline:!0}),", then ",e.jsx("em",{children:"d"}),", breaking RSA. Conversely, knowing ",e.jsx("em",{children:"d"})," allows efficient factoring. Thus RSA security is closely tied to the factoring problem."]}),e.jsx("h3",{children:"Implementation Considerations"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Key Size Recommendations"}),e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Security Level"}),e.jsx("th",{className:"text-left py-2",children:"RSA Modulus"}),e.jsx("th",{className:"text-left py-2",children:"Use Until"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"80-bit"}),e.jsx("td",{className:"py-2",children:"1024 bits"}),e.jsx("td",{className:"py-2",children:"Deprecated"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"112-bit"}),e.jsx("td",{className:"py-2",children:"2048 bits"}),e.jsx("td",{className:"py-2",children:"2030"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"128-bit"}),e.jsx("td",{className:"py-2",children:"3072 bits"}),e.jsx("td",{className:"py-2",children:"Beyond 2030"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"256-bit"}),e.jsx("td",{className:"py-2",children:"15360 bits"}),e.jsx("td",{className:"py-2",children:"Long-term"})]})]})]})]}),e.jsx("h3",{children:"CRT Optimization"}),e.jsxs(n,{title:"RSA with Chinese Remainder Theorem",proof:e.jsxs(e.Fragment,{children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Correctness:"})," We show that the CRT-based computation yields ",e.jsx(s,{math:"M = C^d \\bmod n",inline:!0}),"."]}),e.jsxs("p",{className:"mt-2",children:["By Fermat's little theorem, for any ",e.jsx(s,{math:"x",inline:!0})," and prime ",e.jsx(s,{math:"p",inline:!0}),":"]}),e.jsx(s,{math:"x^{p-1} \\equiv 1 \\pmod{p} \\quad \\text{if } \\gcd(x, p) = 1"}),e.jsxs("p",{className:"mt-2",children:["Since ",e.jsx(s,{math:"d_p = d \\bmod (p-1)",inline:!0}),", we can write ",e.jsx(s,{math:"d = d_p + k(p-1)",inline:!0})," for some integer ",e.jsx(s,{math:"k",inline:!0}),". Then:"]}),e.jsx(s,{math:"C^d \\equiv C^{d_p + k(p-1)} = C^{d_p} \\cdot (C^{p-1})^k \\equiv C^{d_p} \\cdot 1^k = C^{d_p} \\pmod{p}"}),e.jsxs("p",{className:"mt-2",children:["Similarly, ",e.jsx(s,{math:"C^d \\equiv C^{d_q} \\pmod{q}",inline:!0}),". So:"]}),e.jsx(s,{math:"M_p = C^{d_p} \\bmod p \\equiv M \\pmod{p}"}),e.jsx(s,{math:"M_q = C^{d_q} \\bmod q \\equiv M \\pmod{q}"}),e.jsxs("p",{className:"mt-2",children:["The CRT reconstruction formula ",e.jsx(s,{math:"M = M_q + q \\cdot (q_{\\text{inv}} \\cdot (M_p - M_q) \\bmod p)",inline:!0})," gives the unique value in ",e.jsx(s,{math:"[0, n-1]",inline:!0})," satisfying both congruences."]}),e.jsxs("p",{className:"mt-2",children:[e.jsx("strong",{children:"Efficiency:"})," Exponentiations ",e.jsx(s,{math:"C^{d_p} \\bmod p",inline:!0})," and ",e.jsx(s,{math:"C^{d_q} \\bmod q",inline:!0})," each use operands of half the bit-length. Since modular exponentiation is ",e.jsx(s,{math:"O(k^3)",inline:!0})," where ",e.jsx(s,{math:"k",inline:!0})," is the bit-length, two half-size exponentiations cost ",e.jsx(s,{math:"2 \\cdot (k/2)^3 = k^3/4",inline:!0}),", yielding a ~4× speedup."]})]}),children:["Decryption can be sped up ~4× using CRT. Precompute:",e.jsx(s,{math:"d_p = d \\bmod (p-1), \\quad d_q = d \\bmod (q-1), \\quad q_{\\text{inv}} = q^{-1} \\bmod p"}),"Then compute:",e.jsx(s,{math:"M_p = C^{d_p} \\bmod p, \\quad M_q = C^{d_q} \\bmod q"}),e.jsx(s,{math:"M = M_q + q \\cdot (q_{\\text{inv}} \\cdot (M_p - M_q) \\bmod p)"})]}),e.jsx("h3",{children:"Attacks on RSA"}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"Known Attacks"}),e.jsxs("ul",{className:"list-disc list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Factoring:"})," If ",e.jsx("em",{children:"n"})," can be factored, RSA is broken"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Small e attacks:"})," If ",e.jsx(s,{math:"M^e < n",inline:!0}),", take ",e.jsx("em",{children:"e"}),"-th root"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Common modulus:"})," Never use same ",e.jsx("em",{children:"n"})," for different users"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Timing attacks:"})," Measure computation time to leak ",e.jsx("em",{children:"d"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Bleichenbacher's attack:"})," Against PKCS#1 v1.5 padding"]})]})]}),e.jsxs(t,{type:"warning",children:[e.jsx("strong",{children:"Textbook RSA is Insecure!"})," Raw RSA is deterministic (same message → same ciphertext) and malleable. Always use proper padding schemes like OAEP."]}),e.jsx("h3",{children:"RSA Signatures"}),e.jsxs(i,{title:"RSA Signature Scheme",children:[e.jsxs("p",{children:[e.jsx("strong",{children:"Sign:"})," ",e.jsx(s,{math:"\\sigma = H(M)^d \\bmod n",inline:!0})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Verify:"})," Check that ",e.jsx(s,{math:"\\sigma^e \\equiv H(M) \\pmod{n}",inline:!0})]}),e.jsxs("p",{className:"mt-2",children:["where ",e.jsx(s,{math:"H",inline:!0})," is a cryptographic hash function."]})]}),e.jsxs(r,{title:"RSA Signature",children:[e.jsxs("p",{children:["Using keys from earlier (",e.jsx(s,{math:"n = 3233, e = 17, d = 2753",inline:!0}),"):"]}),e.jsxs("p",{className:"mt-2",children:["Sign message hash ",e.jsx(s,{math:"H(M) = 100",inline:!0}),":"]}),e.jsx(s,{math:"\\sigma = 100^{2753} \\bmod 3233 = 1951"}),e.jsxs("p",{children:["Verify: ",e.jsx(s,{math:"1951^{17} \\bmod 3233 = 100 = H(M)",inline:!0})," ✓"]})]}),e.jsxs(t,{type:"success",children:[e.jsx("strong",{children:"RSA's Legacy:"})," Despite being nearly 50 years old, RSA remains widely used for key exchange and digital signatures. Its mathematical elegance and well-understood security properties have made it a cornerstone of internet security."]})]})}export{g as default};
