import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as r,T as s,D as n,C as t,E as l}from"./Callout-DzP_hyKf.js";import{M as i}from"./MathBlock-DHMt0FrA.js";import"./vendor-react-Drj8qL0h.js";import"./index-BWUjVAcL.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-core-BXWtuYvb.js";import"./quizMap-CQDzgGif.js";function u(){return e.jsxs(r,{sectionId:20,children:[e.jsx("h2",{children:"Elliptic Curve Primality Test"}),e.jsx("p",{children:"Elliptic curves provide a powerful approach to primality testing. The Goldwasser-Kilian algorithm and later ECPP (Elliptic Curve Primality Proving) can prove primality of numbers with thousands of digits, producing verifiable certificates."}),e.jsx("h3",{children:"Primality and Group Order"}),e.jsxs(s,{title:"Key Observation",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We establish how elliptic curve group structure reveals primality."}),e.jsxs("p",{children:[e.jsx("strong",{children:"Well-definedness:"})," When ",e.jsx("em",{children:"n"})," is prime, ",e.jsx(i,{math:"\\mathbb{F}_n = \\mathbb{Z}/n\\mathbb{Z}",inline:!0})," is a field, and the elliptic curve equation ",e.jsx(i,{math:"y^2 = x^3 + ax + b",inline:!0})," with ",e.jsx(i,{math:"4a^3 + 27b^2 \\not\\equiv 0 \\pmod{n}",inline:!0})," defines a non-singular curve. The group law (point addition) is well-defined since all required field operations (especially division) are valid."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Hasse's bound:"})," For prime ",e.jsx("em",{children:"n"}),", Hasse's theorem gives:"]}),e.jsx(i,{math:"|n + 1 - \\#E(\\mathbb{F}_n)| \\leq 2\\sqrt{n}"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Primality criterion:"})," Suppose ",e.jsx(i,{math:"\\#E(\\mathbb{F}_n) = m = kq",inline:!0})," where ",e.jsx("em",{children:"q"})," is prime with ",e.jsx(i,{math:"q > (n^{1/4} + 1)^2",inline:!0}),". If we find a point ",e.jsx("em",{children:"P"})," such that:"]}),e.jsx(i,{math:"mP = \\mathcal{O} \\quad \\text{but} \\quad (m/q)P \\neq \\mathcal{O}"}),e.jsxs("p",{children:["then ",e.jsx("em",{children:"P"})," has order divisible by ",e.jsx("em",{children:"q"}),". By Lagrange's theorem, ",e.jsx(i,{math:"q \\mid \\#E(\\mathbb{F}_n)",inline:!0}),"."]}),e.jsxs("p",{children:["If ",e.jsx("em",{children:"n"})," were composite with a prime factor ",e.jsx(i,{math:"p \\mid n",inline:!0}),", then ",e.jsx("em",{children:"E"})," mod ",e.jsx("em",{children:"p"})," would have at most ",e.jsx(i,{math:"p + 1 + 2\\sqrt{p} < (p^{1/2} + 1)^2",inline:!0})," points. But ",e.jsx(i,{math:"q > (n^{1/4}+1)^2 > (p^{1/2}+1)^2",inline:!0})," for any ",e.jsx(i,{math:"p \\leq \\sqrt{n}",inline:!0}),", contradicting ",e.jsx(i,{math:"q \\mid \\#E(\\mathbb{F}_p)",inline:!0}),"."]})]}),children:["If ",e.jsx("em",{children:"n"})," is prime, then for any elliptic curve ",e.jsx("em",{children:"E"})," over ",e.jsx(i,{math:"\\mathbb{F}_n",inline:!0}),":",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["The group ",e.jsx(i,{math:"E(\\mathbb{F}_n)",inline:!0})," is well-defined"]}),e.jsxs("li",{children:["By Hasse: ",e.jsx(i,{math:"n + 1 - 2\\sqrt{n} \\leq \\#E(\\mathbb{F}_n) \\leq n + 1 + 2\\sqrt{n}",inline:!0})]}),e.jsxs("li",{children:["If we can show the group order has a large prime factor, ",e.jsx("em",{children:"n"})," must be prime"]})]})]}),e.jsx("h3",{children:"The Goldwasser-Kilian Algorithm"}),e.jsxs(n,{title:"Basic Idea",children:["To prove ",e.jsx("em",{children:"n"})," is prime:",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Find an elliptic curve ",e.jsx("em",{children:"E"})," over ",e.jsx(i,{math:"\\mathbb{Z}/n\\mathbb{Z}",inline:!0})]}),e.jsxs("li",{children:["Compute ",e.jsx(i,{math:"m = \\#E",inline:!0})," (using Schoof's algorithm)"]}),e.jsxs("li",{children:["Factor ",e.jsx(i,{math:"m = kq",inline:!0})," where ",e.jsx("em",{children:"q"})," is a probable prime ",e.jsx(i,{math:"> \\sqrt{n}",inline:!0})]}),e.jsxs("li",{children:["Find a point ",e.jsx("em",{children:"P"})," with ",e.jsx(i,{math:"mP = \\mathcal{O}",inline:!0})," but ",e.jsx(i,{math:"(m/q)P \\neq \\mathcal{O}",inline:!0})]}),e.jsxs("li",{children:["Recursively prove ",e.jsx("em",{children:"q"})," is prime"]})]})]}),e.jsxs(s,{title:"Why This Works",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We prove correctness of the Goldwasser-Kilian primality criterion."}),e.jsxs("p",{children:["Suppose all computations succeed mod ",e.jsx("em",{children:"n"}),", and we have verified that ",e.jsx("em",{children:"q"})," is prime with ",e.jsx(i,{math:"q > \\sqrt{n}",inline:!0}),". Assume for contradiction that ",e.jsx("em",{children:"n"})," is composite."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Case 1:"})," If during point additions we needed to invert some ",e.jsx(i,{math:"d",inline:!0})," with ",e.jsx(i,{math:"\\gcd(d, n) = g",inline:!0}),", ",e.jsx(i,{math:"1 < g < n",inline:!0}),", then the extended Euclidean algorithm would have revealed ",e.jsx("em",{children:"g"})," as a nontrivial factor. Since computations succeeded, this didn't happen."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Case 2:"})," Computations succeeded, meaning all slopes ",e.jsx(i,{math:"\\lambda",inline:!0})," in point additions were well-defined mod ",e.jsx("em",{children:"n"}),". Let ",e.jsx(i,{math:"p",inline:!0})," be the smallest prime factor of ",e.jsx("em",{children:"n"}),", so ",e.jsx(i,{math:"p \\leq \\sqrt{n}",inline:!0}),"."]}),e.jsxs("p",{children:["The point ",e.jsx("em",{children:"P"})," reduces to some point ",e.jsx(i,{math:"\\bar{P}",inline:!0})," on ",e.jsx(i,{math:"E(\\mathbb{F}_p)",inline:!0}),". Since ",e.jsx(i,{math:"mP = \\mathcal{O}",inline:!0})," mod ",e.jsx("em",{children:"n"}),", we have ",e.jsx(i,{math:"m\\bar{P} = \\mathcal{O}",inline:!0})," mod ",e.jsx("em",{children:"p"}),". Thus ",e.jsx(i,{math:"\\text{ord}(\\bar{P}) \\mid m",inline:!0}),"."]}),e.jsxs("p",{children:["Since ",e.jsx(i,{math:"(m/q)P \\neq \\mathcal{O}",inline:!0})," mod ",e.jsx("em",{children:"n"}),", we have ",e.jsx(i,{math:"(m/q)\\bar{P} \\neq \\mathcal{O}",inline:!0})," mod ",e.jsx("em",{children:"p"})," (otherwise all coordinates would be divisible by ",e.jsx("em",{children:"p"}),", detectable). Thus ",e.jsx(i,{math:"q \\mid \\text{ord}(\\bar{P})",inline:!0}),"."]}),e.jsxs("p",{children:["By Lagrange's theorem, ",e.jsx(i,{math:"\\text{ord}(\\bar{P}) \\mid \\#E(\\mathbb{F}_p)",inline:!0}),". So ",e.jsx(i,{math:"q \\mid \\#E(\\mathbb{F}_p)",inline:!0}),". By Hasse:"]}),e.jsx(i,{math:"\\#E(\\mathbb{F}_p) \\leq p + 1 + 2\\sqrt{p} < (\\sqrt{p} + 1)^2 \\leq (\\sqrt[4]{n} + 1)^2 < \\sqrt{n} < q"}),e.jsxs("p",{children:["This contradicts ",e.jsx(i,{math:"q \\mid \\#E(\\mathbb{F}_p)",inline:!0}),". Therefore ",e.jsx("em",{children:"n"})," must be prime."]})]}),children:["If computations succeed modulo ",e.jsx("em",{children:"n"})," and ",e.jsx("em",{children:"q"})," is prime with ",e.jsx(i,{math:"q > \\sqrt{n}",inline:!0}),", then ",e.jsx("em",{children:"n"})," must be prime. If ",e.jsx("em",{children:"n"})," were composite, the group operations would fail (denominators not invertible) or produce inconsistent results."]}),e.jsx("h3",{children:"Schoof's Algorithm"}),e.jsxs(n,{title:"Computing Group Order",children:[e.jsx("strong",{children:"Schoof's algorithm"})," (1985) computes ",e.jsx(i,{math:"\\#E(\\mathbb{F}_p)",inline:!0})," ","in polynomial time ",e.jsx(i,{math:"O((\\log p)^8)",inline:!0}),":",e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["For small primes ",e.jsx(i,{math:"\\ell",inline:!0}),", compute ",e.jsx(i,{math:"t \\bmod \\ell",inline:!0})," ","using division polynomials"]}),e.jsxs("li",{children:["Use CRT to combine: ",e.jsx(i,{math:"t \\bmod \\prod \\ell",inline:!0})]}),e.jsxs("li",{children:["Since ",e.jsx(i,{math:"|t| \\leq 2\\sqrt{p}",inline:!0}),", enough primes determine ",e.jsx("em",{children:"t"})]}),e.jsx("li",{children:e.jsx(i,{math:"\\#E = p + 1 - t",inline:!0})})]})]}),e.jsxs(t,{type:"info",children:[e.jsx("strong",{children:"Improvement:"})," The Schoof-Elkies-Atkin (SEA) algorithm improves complexity to ",e.jsx(i,{math:"O((\\log p)^4)",inline:!0}),", making it practical for large primes."]}),e.jsx("h3",{children:"ECPP: Elliptic Curve Primality Proving"}),e.jsxs(n,{title:"ECPP Algorithm",children:["Atkin-Morain's ECPP improves on Goldwasser-Kilian:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsx("li",{children:"Uses complex multiplication (CM) to construct curves with known order"}),e.jsx("li",{children:"Avoids point counting by using theory of complex multiplication"}),e.jsxs("li",{children:["Order is given by ",e.jsx(i,{math:"m = p + 1 - t",inline:!0})," where ",e.jsx("em",{children:"t"})," comes from CM theory"]}),e.jsx("li",{children:"Much faster in practice"})]})]}),e.jsxs("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:[e.jsx("h4",{className:"text-lg font-semibold text-primary-400 mb-3",children:"ECPP Overview"}),e.jsxs("ol",{className:"list-decimal list-inside space-y-2 text-dark-300",children:[e.jsxs("li",{children:["Find discriminant ",e.jsx(i,{math:"-D",inline:!0})," with ",e.jsx(i,{math:"4n = t^2 + Ds^2",inline:!0}),' ("cornacchia")']}),e.jsxs("li",{children:["Use Hilbert class polynomial ",e.jsx(i,{math:"H_D(x)",inline:!0})," to get curve parameters"]}),e.jsxs("li",{children:["Curve order is ",e.jsx(i,{math:"m = n + 1 - t",inline:!0})," or ",e.jsx(i,{math:"m = n + 1 + t",inline:!0})]}),e.jsxs("li",{children:["Find point of order ",e.jsx("em",{children:"m"}),", factor ",e.jsx("em",{children:"m"})," to get recursive target"]}),e.jsx("li",{children:"Output certificate (curve, point, recursive proof)"})]})]}),e.jsx("h3",{children:"Primality Certificates"}),e.jsxs(s,{title:"ECPP Certificate",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We prove the soundness and verifiability of ECPP certificates."}),e.jsxs("p",{children:[e.jsx("strong",{children:"Certificate structure:"})," An ECPP certificate for ",e.jsx("em",{children:"n"})," consists of a descending chain ",e.jsx(i,{math:"n = n_0 > n_1 > \\cdots > n_k",inline:!0})," where each step contains:"]}),e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["Curve parameters ",e.jsx(i,{math:"(a_i, b_i)",inline:!0})," defining ",e.jsx(i,{math:"E_i: y^2 = x^3 + a_i x + b_i",inline:!0})," mod ",e.jsx(i,{math:"n_i",inline:!0})]}),e.jsxs("li",{children:["A point ",e.jsx(i,{math:"P_i = (x_i, y_i)",inline:!0})," on ",e.jsx(i,{math:"E_i",inline:!0})]}),e.jsxs("li",{children:["The group order ",e.jsx(i,{math:"m_i = c_i \\cdot n_{i+1}",inline:!0})," with ",e.jsx(i,{math:"n_{i+1} > (n_i^{1/4} + 1)^2",inline:!0})]})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Verification:"})," For each level ",e.jsx("em",{children:"i"}),", the verifier checks:"]}),e.jsxs("ol",{className:"list-decimal list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(i,{math:"P_i",inline:!0})," lies on ",e.jsx(i,{math:"E_i",inline:!0}),": verify ",e.jsx(i,{math:"y_i^2 \\equiv x_i^3 + a_i x_i + b_i \\pmod{n_i}",inline:!0})]}),e.jsxs("li",{children:["Non-singularity: verify ",e.jsx(i,{math:"4a_i^3 + 27b_i^2 \\not\\equiv 0 \\pmod{n_i}",inline:!0})]}),e.jsxs("li",{children:["Order verification: compute ",e.jsx(i,{math:"m_i P_i",inline:!0})," and check it equals ",e.jsx(i,{math:"\\mathcal{O}",inline:!0})]}),e.jsxs("li",{children:["Divisibility: compute ",e.jsx(i,{math:"(m_i/n_{i+1})P_i",inline:!0})," and check it's not ",e.jsx(i,{math:"\\mathcal{O}",inline:!0})]}),e.jsxs("li",{children:["Size: verify ",e.jsx(i,{math:"n_{i+1} > (n_i^{1/4} + 1)^2",inline:!0})]})]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Complexity:"})," Each scalar multiplication costs ",e.jsx(i,{math:"O(\\log m_i)",inline:!0})," group operations, each operation is ",e.jsx(i,{math:"O((\\log n_i)^2)",inline:!0})," for arithmetic mod ",e.jsx(i,{math:"n_i",inline:!0}),". Total verification is polynomial in ",e.jsx(i,{math:"\\log n",inline:!0}),"."]}),e.jsxs("p",{children:["The chain terminates at ",e.jsx(i,{math:"n_k",inline:!0})," small enough for direct verification (e.g., by trial division or a lookup table)."]})]}),children:["ECPP produces a certificate consisting of:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:["A chain of primes ",e.jsx(i,{math:"n = n_0 > n_1 > \\cdots > n_k",inline:!0})," where ",e.jsx(i,{math:"n_k",inline:!0})," is small"]}),e.jsxs("li",{children:["For each ",e.jsx(i,{math:"n_i",inline:!0}),": curve ",e.jsx(i,{math:"E_i",inline:!0}),", point ",e.jsx(i,{math:"P_i",inline:!0}),", order ",e.jsx(i,{math:"m_i",inline:!0})]}),e.jsxs("li",{children:[e.jsx(i,{math:"m_i = c_i \\cdot n_{i+1}",inline:!0})," where ",e.jsx(i,{math:"n_{i+1}",inline:!0})," is the next prime to verify"]})]}),"The certificate can be verified in polynomial time without trusting the prover."]}),e.jsxs(l,{title:"Certificate Structure",children:[e.jsx("p",{children:"To prove 31 is prime (toy example):"}),e.jsxs("ul",{className:"list-disc list-inside mt-2",children:[e.jsxs("li",{children:["Curve: ",e.jsx(i,{math:"y^2 = x^3 + x + 5",inline:!0})," over ",e.jsx(i,{math:"\\mathbb{F}_{31}",inline:!0})]}),e.jsxs("li",{children:["Order: ",e.jsx(i,{math:"m = 28 = 4 \\times 7",inline:!0})]}),e.jsxs("li",{children:["Point ",e.jsx(i,{math:"P = (0, 9)",inline:!0})," has order 28"]}),e.jsxs("li",{children:[e.jsx(i,{math:"7P \\neq \\mathcal{O}",inline:!0})," but ",e.jsx(i,{math:"28P = \\mathcal{O}",inline:!0})]}),e.jsxs("li",{children:["Since ",e.jsx(i,{math:"7 > \\sqrt{31}",inline:!0}),", this proves 31 is prime (given 7 is prime)"]})]})]}),e.jsx("h3",{children:"Complexity"}),e.jsxs(s,{title:"ECPP Complexity",proof:e.jsxs(e.Fragment,{children:[e.jsx("p",{children:"We analyze the expected running time of ECPP under standard heuristics."}),e.jsxs("p",{children:[e.jsx("strong",{children:"Chain length:"})," At each step, we reduce ",e.jsx(i,{math:"n_i",inline:!0})," to ",e.jsx(i,{math:"n_{i+1} \\approx n_i / c",inline:!0})," for some small cofactor ",e.jsx("em",{children:"c"}),". The chain has length ",e.jsx(i,{math:"O(\\log n)",inline:!0}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Finding suitable discriminant:"})," For each ",e.jsx(i,{math:"n_i",inline:!0}),", we need a negative discriminant ",e.jsx(i,{math:"-D",inline:!0})," such that:"]}),e.jsx(i,{math:"4n_i = t^2 + D s^2"}),e.jsxs("p",{children:["for integers ",e.jsx("em",{children:"t, s"})," with ",e.jsx(i,{math:"|t| \\leq 2\\sqrt{n_i}",inline:!0}),". By Cornacchia's algorithm, this costs ",e.jsx(i,{math:"O((\\log n_i)^2)",inline:!0})," per discriminant tried."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Heuristic:"})," The density of suitable discriminants is believed to be ",e.jsx(i,{math:"O(1/\\log n_i)",inline:!0}),", so we expect to try ",e.jsx(i,{math:"O(\\log n_i)",inline:!0})," discriminants. However, we want ",e.jsx(i,{math:"m_i = n_i + 1 - t",inline:!0})," to have a large prime factor, which succeeds with probability ",e.jsx(i,{math:"\\Omega(1/\\log n_i)",inline:!0})," (by number-theoretic estimates on smooth numbers)."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Hilbert class polynomial:"})," Computing ",e.jsx(i,{math:"H_D(x)",inline:!0})," mod ",e.jsx(i,{math:"n_i",inline:!0})," costs ",e.jsx(i,{math:"O(|D| \\cdot (\\log n_i)^2)",inline:!0}),". Under GRH, class numbers grow as ",e.jsx(i,{math:"O(\\sqrt{D} \\log D)",inline:!0}),", and suitable ",e.jsx("em",{children:"D"})," values are ",e.jsx(i,{math:"O((\\log n_i)^2)",inline:!0})," on average."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Total per level:"})," ",e.jsx(i,{math:"O((\\log n_i)^3)",inline:!0})," operations, where each operation is ",e.jsx(i,{math:"O((\\log n_i)^{1+\\epsilon})",inline:!0})," using fast multiplication."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Summing over chain:"})," Total time is ",e.jsx(i,{math:"\\sum_{i=0}^{O(\\log n)} O((\\log n_i)^{4+\\epsilon}) = O((\\log n)^{5+\\epsilon})",inline:!0})," under conservative estimates, or ",e.jsx(i,{math:"O((\\log n)^{4+\\epsilon})",inline:!0})," under optimistic heuristics about discriminant search."]})]}),children:["Under reasonable heuristics, ECPP runs in expected time:",e.jsx(i,{math:"O((\\log n)^{4+\\epsilon})"}),"This is significantly faster than the deterministic AKS test in practice."]}),e.jsx("h3",{children:"Comparison of Primality Methods"}),e.jsx("div",{className:"bg-dark-800/50 rounded-xl p-4 border border-dark-700 my-4",children:e.jsxs("table",{className:"w-full text-dark-300",children:[e.jsx("thead",{children:e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("th",{className:"text-left py-2",children:"Method"}),e.jsx("th",{className:"text-left py-2",children:"Type"}),e.jsx("th",{className:"text-left py-2",children:"Output"}),e.jsx("th",{className:"text-left py-2",children:"Speed"})]})}),e.jsxs("tbody",{children:[e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"Miller-Rabin"}),e.jsx("td",{className:"py-2",children:"Probabilistic"}),e.jsx("td",{className:"py-2",children:"No proof"}),e.jsx("td",{className:"py-2",children:"Fastest"})]}),e.jsxs("tr",{className:"border-b border-dark-700",children:[e.jsx("td",{className:"py-2",children:"AKS"}),e.jsx("td",{className:"py-2",children:"Deterministic"}),e.jsx("td",{className:"py-2",children:"Proof"}),e.jsx("td",{className:"py-2",children:"Slowest"})]}),e.jsxs("tr",{children:[e.jsx("td",{className:"py-2",children:"ECPP"}),e.jsx("td",{className:"py-2",children:"Deterministic"}),e.jsx("td",{className:"py-2",children:"Certificate"}),e.jsx("td",{className:"py-2",children:"Fast (practical)"})]})]})]})}),e.jsxs(t,{type:"success",children:[e.jsx("strong",{children:"Record Primes:"})," ECPP has been used to prove primality of numbers with over 30,000 decimal digits. The certificate can be verified much faster than it takes to generate, enabling distributed verification."]})]})}export{u as default};
