import{j as e}from"./vendor-animation-0o8UKZ_1.js";import{L as r,C as i}from"./Callout-aFgfQJgX.js";import{I as s,M as n}from"./MathBlock-uz1iP4cD.js";import"./vendor-react-Drj8qL0h.js";import"./index-BFwc5v7Y.js";import"./vendor-math-p018AHG0.js";import"./vendor-firebase-functions-DDqfDrvm.js";import"./vendor-firebase-core-CzRQL6VN.js";import"./vendor-firebase-auth-C4l3lITM.js";import"./quizMap-u-JE_pu_.js";function m(){return e.jsxs(r,{sectionId:0,children:[e.jsx("h2",{children:"Basics: Sets, Functions, and Relations"}),e.jsx("p",{children:"Before diving into abstract algebra, we need to establish the foundational language of mathematics. This section reviews the essential concepts of sets, functions, and relations that underpin all of modern algebra."}),e.jsx("h3",{children:"Sets and Set Operations"}),e.jsxs("p",{children:["A ",e.jsx("strong",{children:"set"})," is a well-defined collection of distinct objects, called ",e.jsx("strong",{children:"elements"}),"or ",e.jsx("strong",{children:"members"}),". We write ",e.jsx(s,{children:"a \\in A"})," to indicate that ",e.jsx(s,{children:"a"})," is an element of the set ",e.jsx(s,{children:"A"}),", and ",e.jsx(s,{children:"a \\notin A"})," if it is not."]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," A set ",e.jsx(s,{children:"A"})," is a ",e.jsx("strong",{children:"subset"})," of ",e.jsx(s,{children:"B"}),", written ",e.jsx(s,{children:"A \\subseteq B"}),", if every element of ",e.jsx(s,{children:"A"})," is also an element of ",e.jsx(s,{children:"B"}),". We write ",e.jsx(s,{children:"A = B"})," if both ",e.jsx(s,{children:"A \\subseteq B"})," and ",e.jsx(s,{children:"B \\subseteq A"}),"."]}),e.jsx("p",{children:"The fundamental set operations are:"}),e.jsxs("ul",{className:"list-disc list-inside text-dark-300 mb-6 space-y-2",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Union:"})," ",e.jsxs(s,{children:["A \\cup B = \\","{","x : x \\in A \\text","{"," or ","}"," x \\in B\\","}"]})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Intersection:"})," ",e.jsxs(s,{children:["A \\cap B = \\","{","x : x \\in A \\text","{"," and ","}"," x \\in B\\","}"]})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Difference:"})," ",e.jsxs(s,{children:["A \\setminus B = \\","{","x : x \\in A \\text","{"," and ","}"," x \\notin B\\","}"]})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Cartesian Product:"})," ",e.jsxs(s,{children:["A \\times B = \\","{","(a, b) : a \\in A, b \\in B\\","}"]})]})]}),e.jsx("h3",{children:"Functions"}),e.jsxs("p",{children:["A ",e.jsx("strong",{children:"function"})," ",e.jsx(s,{children:"f: A \\to B"})," is a rule that assigns to each element ",e.jsx(s,{children:"a \\in A"})," exactly one element ",e.jsx(s,{children:"f(a) \\in B"}),". The set ",e.jsx(s,{children:"A"})," is called the ",e.jsx("strong",{children:"domain"})," and ",e.jsx(s,{children:"B"})," is called the ",e.jsx("strong",{children:"codomain"}),"."]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," Let ",e.jsx(s,{children:"f: A \\to B"})," be a function.",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx(s,{children:"f"})," is ",e.jsx("strong",{children:"injective"})," (one-to-one) if ",e.jsx(s,{children:"f(a_1) = f(a_2)"})," implies ",e.jsx(s,{children:"a_1 = a_2"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"f"})," is ",e.jsx("strong",{children:"surjective"})," (onto) if for every ",e.jsx(s,{children:"b \\in B"}),", there exists ",e.jsx(s,{children:"a \\in A"})," with ",e.jsx(s,{children:"f(a) = b"})]}),e.jsxs("li",{children:[e.jsx(s,{children:"f"})," is ",e.jsx("strong",{children:"bijective"})," if it is both injective and surjective"]})]})]}),e.jsxs("p",{children:["If ",e.jsx(s,{children:"f: A \\to B"})," and ",e.jsx(s,{children:"g: B \\to C"}),", their ",e.jsx("strong",{children:"composition"})," is the function ",e.jsx(s,{children:"g \\circ f: A \\to C"})," defined by ",e.jsx(s,{children:"(g \\circ f)(a) = g(f(a))"}),"."]}),e.jsx("h3",{children:"Relations"}),e.jsxs("p",{children:["A ",e.jsx("strong",{children:"relation"})," on a set ",e.jsx(s,{children:"A"})," is a subset ",e.jsx(s,{children:"R \\subseteq A \\times A"}),". We often write ",e.jsx(s,{children:"a \\sim b"})," or ",e.jsx(s,{children:"aRb"})," to indicate that ",e.jsx(s,{children:"(a, b) \\in R"}),"."]}),e.jsxs(i,{type:"info",children:[e.jsx("strong",{children:"Definition:"})," An ",e.jsx("strong",{children:"equivalence relation"})," on ",e.jsx(s,{children:"A"})," is a relation ",e.jsx(s,{children:"\\sim"})," satisfying:",e.jsxs("ul",{className:"list-disc list-inside mt-2 space-y-1",children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Reflexive:"})," ",e.jsx(s,{children:"a \\sim a"})," for all ",e.jsx(s,{children:"a \\in A"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Symmetric:"})," ",e.jsx(s,{children:"a \\sim b"})," implies ",e.jsx(s,{children:"b \\sim a"})]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Transitive:"})," ",e.jsx(s,{children:"a \\sim b"})," and ",e.jsx(s,{children:"b \\sim c"})," implies ",e.jsx(s,{children:"a \\sim c"})]})]})]}),e.jsxs("p",{children:["For an equivalence relation ",e.jsx(s,{children:"\\sim"}),", the ",e.jsx("strong",{children:"equivalence class"})," of ",e.jsx(s,{children:"a"})," is:"]}),e.jsxs(n,{children:["[a] = \\","{","b \\in A : b \\sim a\\","}"]}),e.jsx("h3",{children:"Example: Congruence Modulo n"}),e.jsxs("p",{children:["A fundamental example of an equivalence relation is ",e.jsx("strong",{children:"congruence modulo n"})," on the integers. For a positive integer ",e.jsx(s,{children:"n"}),", we define:"]}),e.jsxs(n,{children:["a \\equiv b \\pmod","{","n","}"," \\iff n \\mid (a - b)"]}),e.jsxs("p",{children:["The equivalence classes are the residue classes ",e.jsx(s,{children:"[0], [1], \\ldots, [n-1]"}),", and the set of all equivalence classes forms ",e.jsxs(s,{children:["\\mathbb","{","Z","}","/n\\mathbb","{","Z","}"]}),"."]}),e.jsx("h3",{children:"The Well-Ordering Principle"}),e.jsxs("p",{children:["A key property of the natural numbers is the ",e.jsx("strong",{children:"Well-Ordering Principle"}),": every non-empty subset of ",e.jsxs(s,{children:["\\mathbb","{","N","}"," = \\","{","0, 1, 2, \\ldots\\","}"]})," has a least element."]}),e.jsxs("p",{children:["This principle is equivalent to the ",e.jsx("strong",{children:"Principle of Mathematical Induction"})," and will be used extensively throughout abstract algebra, particularly in proving existence and uniqueness results."]}),e.jsxs(i,{type:"success",children:[e.jsx("strong",{children:"Summary:"})," Sets, functions, and relations form the foundational language of abstract algebra. Equivalence relations partition sets into equivalence classes, and bijective functions establish structural correspondences between sets. These concepts will be generalized as we study algebraic structures."]})]})}export{m as default};
