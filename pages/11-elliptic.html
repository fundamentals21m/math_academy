<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Elliptic Curves - Magic Internet Math</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../styles/main.css">
</head>
<body>
  <nav>
    <div class="nav-content">
      <a href="../index.html" class="logo">Magic Internet Math</a>
      <ul class="nav-links">
        <li><a href="../index.html">Home</a></li>
        <li><a href="1-intro.html" class="active">Lessons</a></li>
        <li><a href="12-quiz.html">Quiz</a></li>
      </ul>
    </div>
  </nav>

  <main class="container">
    <div class="progress-bar">
      <div class="progress-fill" style="width: 92%"></div>
    </div>

    <h1>Elliptic Curves</h1>

    <p><strong>Elliptic Curve Cryptography (ECC)</strong> achieves the same security as RSA with much smaller key sizes. A 256-bit ECC key provides similar security to a 3072-bit RSA key!</p>

    <div class="callout callout-info">
      <strong>Why Elliptic Curves?</strong> The discrete log problem on elliptic curves is even harder than in regular modular arithmetic. This allows for smaller, faster keys.
    </div>

    <h2>The Curve Equation</h2>

    <p>An elliptic curve over a prime field is defined by:</p>

    <div class="math-block">
      y² = x³ + ax + b (mod p)
    </div>

    <p>Points on the curve form a group under a special "addition" operation.</p>

    <h2>Visualize the Curve</h2>

    <div class="canvas-container">
      <canvas id="curveCanvas" width="400" height="400"></canvas>

      <div class="controls" style="justify-content: flex-start; flex-wrap: wrap;">
        <div class="input-group">
          <label for="curveA">a:</label>
          <input type="number" id="curveA" value="2" style="width: 60px;">
        </div>
        <div class="input-group">
          <label for="curveB">b:</label>
          <input type="number" id="curveB" value="3" style="width: 60px;">
        </div>
        <div class="input-group">
          <label for="curveP">p:</label>
          <input type="number" id="curveP" value="17" min="5" max="31" style="width: 60px;">
        </div>
        <button class="btn btn-primary btn-small" onclick="updateCurve()">Draw Curve</button>
      </div>

      <div id="curvePoints" class="output-panel" style="margin-top: 0.5rem; max-height: 100px; overflow-y: auto;">
        <span class="muted">Points will appear here...</span>
      </div>
    </div>

    <h2>Point Addition</h2>

    <p>We can "add" two points on the curve to get a third point. Geometrically, draw a line through P and Q; it intersects the curve at a third point, then reflect over the x-axis.</p>

    <div class="demo-section">
      <h3>Add Two Points</h3>

      <div class="controls" style="justify-content: flex-start; flex-wrap: wrap;">
        <span style="color: var(--text-muted);">P = (</span>
        <input type="number" id="p1x" value="5" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">,</span>
        <input type="number" id="p1y" value="1" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">) +</span>
        <span style="color: var(--text-muted);">Q = (</span>
        <input type="number" id="p2x" value="6" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">,</span>
        <input type="number" id="p2y" value="3" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">)</span>
        <button class="btn btn-primary btn-small" onclick="addPoints()">Add</button>
      </div>

      <div id="addResult" class="output-panel">
        <span class="muted">Result will appear here...</span>
      </div>
    </div>

    <h2>Scalar Multiplication</h2>

    <p>Adding a point to itself repeatedly: nP = P + P + ... + P (n times). This is the EC equivalent of exponentiation!</p>

    <div class="demo-section">
      <h3>Compute nG</h3>

      <div class="controls" style="justify-content: flex-start; flex-wrap: wrap;">
        <div class="input-group">
          <label for="scalarN">n:</label>
          <input type="number" id="scalarN" value="5" min="1" max="50" style="width: 60px;">
        </div>
        <span style="color: var(--text-muted);">× G = (</span>
        <input type="number" id="gx" value="5" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">,</span>
        <input type="number" id="gy" value="1" style="width: 50px; padding: 0.25rem; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text);">
        <span style="color: var(--text-muted);">)</span>
        <button class="btn btn-primary btn-small" onclick="scalarMultiply()">Compute</button>
      </div>

      <div id="scalarResult" class="output-panel">
        <span class="muted">Result will appear here...</span>
      </div>
    </div>

    <h2>ECDH Key Exchange</h2>

    <p>Elliptic Curve Diffie-Hellman works just like regular DH, but uses point multiplication instead of exponentiation:</p>

    <div class="card">
      <ol style="margin-left: 1.5rem; color: var(--text-muted); line-height: 2;">
        <li>Public: Curve parameters and generator point G</li>
        <li>Alice picks secret a, computes A = aG</li>
        <li>Bob picks secret b, computes B = bG</li>
        <li>Shared secret: Alice computes aB = a(bG) = abG</li>
        <li>Shared secret: Bob computes bA = b(aG) = abG</li>
      </ol>
    </div>

    <h2>Why ECC is More Efficient</h2>

    <div class="card">
      <table class="data-table">
        <thead>
          <tr>
            <th>Security Level</th>
            <th>RSA Key Size</th>
            <th>ECC Key Size</th>
            <th>Ratio</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>80-bit</td>
            <td>1024 bits</td>
            <td>160 bits</td>
            <td>6.4x</td>
          </tr>
          <tr>
            <td>128-bit</td>
            <td>3072 bits</td>
            <td>256 bits</td>
            <td>12x</td>
          </tr>
          <tr>
            <td>256-bit</td>
            <td>15360 bits</td>
            <td>512 bits</td>
            <td>30x</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="callout callout-success">
      <strong>Real-World Usage:</strong> Bitcoin uses the secp256k1 curve. TLS 1.3 primarily uses X25519 (an elliptic curve). Modern secure messaging apps rely heavily on ECC.
    </div>

    <div class="page-nav">
      <a href="10-diffie-hellman.html" class="btn btn-secondary">Previous: Diffie-Hellman</a>
      <a href="12-quiz.html" class="btn btn-primary">Next: Final Quiz</a>
    </div>
  </main>

  <script src="../scripts/main.js"></script>
  <script src="../scripts/ellipticCurves.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      CurveVisualizer.init('curveCanvas');
      updateCurve();
    });

    function updateCurve() {
      const a = parseInt(document.getElementById('curveA').value);
      const b = parseInt(document.getElementById('curveB').value);
      const p = parseInt(document.getElementById('curveP').value);

      const points = CurveVisualizer.setCurve(a, b, p);

      const pointsDisplay = document.getElementById('curvePoints');
      if (points.length > 0) {
        const pointStrs = points.map(([x, y]) => `(${x}, ${y})`).join(', ');
        pointsDisplay.innerHTML = `<span class="success">${points.length} points:</span> <span class="muted">${pointStrs}</span>`;
      } else {
        pointsDisplay.innerHTML = '<span class="error">No points found (curve may be singular)</span>';
      }
    }

    function addPoints() {
      const a = parseInt(document.getElementById('curveA').value);
      const p = parseInt(document.getElementById('curveP').value);

      const P = [
        parseInt(document.getElementById('p1x').value),
        parseInt(document.getElementById('p1y').value)
      ];
      const Q = [
        parseInt(document.getElementById('p2x').value),
        parseInt(document.getElementById('p2y').value)
      ];

      // Check if points are on curve
      const b = parseInt(document.getElementById('curveB').value);

      if (!EllipticCurve.isOnCurve(P[0], P[1], a, b, p)) {
        document.getElementById('addResult').innerHTML = `<span class="error">P = (${P[0]}, ${P[1]}) is not on the curve!</span>`;
        return;
      }

      if (!EllipticCurve.isOnCurve(Q[0], Q[1], a, b, p)) {
        document.getElementById('addResult').innerHTML = `<span class="error">Q = (${Q[0]}, ${Q[1]}) is not on the curve!</span>`;
        return;
      }

      const R = EllipticCurve.addPoints(P, Q, a, p);

      CurveVisualizer.state.selectedPoint = R;
      CurveVisualizer.state.highlightedPoints = [P, Q];
      CurveVisualizer.draw();

      if (R === null) {
        document.getElementById('addResult').innerHTML = `
          <span class="success">P + Q = O (point at infinity)</span>
          <span class="muted">P and Q are inverses of each other</span>
        `;
      } else {
        document.getElementById('addResult').innerHTML = `
          <span class="success">P + Q = (${R[0]}, ${R[1]})</span>
          <span class="muted">(${P[0]}, ${P[1]}) + (${Q[0]}, ${Q[1]}) = (${R[0]}, ${R[1]})</span>
        `;
      }
    }

    function scalarMultiply() {
      const a = parseInt(document.getElementById('curveA').value);
      const b = parseInt(document.getElementById('curveB').value);
      const p = parseInt(document.getElementById('curveP').value);
      const n = parseInt(document.getElementById('scalarN').value);

      const G = [
        parseInt(document.getElementById('gx').value),
        parseInt(document.getElementById('gy').value)
      ];

      if (!EllipticCurve.isOnCurve(G[0], G[1], a, b, p)) {
        document.getElementById('scalarResult').innerHTML = `<span class="error">G = (${G[0]}, ${G[1]}) is not on the curve!</span>`;
        return;
      }

      const multiples = CurveVisualizer.highlightMultiples(G, n);

      const R = EllipticCurve.scalarMultiply(n, G, a, p);

      let html = '';
      if (R === null) {
        html = `<span class="success">${n}G = O (point at infinity)</span>`;
      } else {
        html = `<span class="success">${n}G = (${R[0]}, ${R[1]})</span>`;
      }

      html += '\n<span class="muted">Multiples: ';
      multiples.forEach((pt, i) => {
        html += `${i + 1}G=(${pt[0]},${pt[1]}) `;
      });
      html += '</span>';

      document.getElementById('scalarResult').innerHTML = html;
    }
  </script>
</body>
</html>
